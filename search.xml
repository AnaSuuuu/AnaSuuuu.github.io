<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>学习笔记 | 多项式与生成函数</title>
      <link href="/2023/06/28/Poly/"/>
      <url>/2023/06/28/Poly/</url>
      
        <content type="html"><![CDATA[<p>浅挖个坑，期末考完填上</p><span id="more"></span>]]></content>
      
      
      
        <tags>
            
            <tag> 算法竞赛 </tag>
            
            <tag> 数学 </tag>
            
            <tag> 自学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客搭建踩坑指北</title>
      <link href="/2023/06/27/Cross-The-Hole/"/>
      <url>/2023/06/27/Cross-The-Hole/</url>
      
        <content type="html"><![CDATA[<p>从踩坑到掉坑里</p><span id="more"></span><p>本博客采用 Hexo + GitHub 搭建，具体教程网上很多不再赘述</p><p>下面分享一些自己踩过的坑</p><h3 id="公式块中公式无法正常换行"><a href="#公式块中公式无法正常换行" class="headerlink" title="公式块中公式无法正常换行"></a>公式块中公式无法正常换行</h3><h4 id="问题简述"><a href="#问题简述" class="headerlink" title="问题简述"></a>问题简述</h4><p>用 $$ 插入公式块时，本地上用 typora 显示公式换行，但网页上未显示出来</p><p><code>\\</code> 无法正常换行</p><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>在公式块前面加上 <code>\begin&#123;gather&#125;</code> 末尾加上 <code>\end&#123;gather&#125;</code> 即可</p><h3 id="Majax-渲染"><a href="#Majax-渲染" class="headerlink" title="Majax 渲染"></a>Majax 渲染</h3><h4 id="问题简述-1"><a href="#问题简述-1" class="headerlink" title="问题简述"></a>问题简述</h4><ol><li><p>无法正常渲染二重闭曲面积分</p></li><li><pre><code class="latex">$\iiint_&#123;\Omega&#125;(\frac&#123;\partial P&#125;&#123;\partial x&#125; + \frac&#123;\partial Q&#125;&#123;\partial y&#125; + \frac&#123;\partial R&#125;&#123;\partial z&#125;)dV = \unicode&#123;8751&#125;_&#123;\sum&#125;Pdydz + Qdzdx + Rdxdy $<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> 可以正常渲染出来</span><br><span class="line"></span><br><span class="line">$\iiint_&#123;\Omega&#125;(\frac&#123;\partial P&#125;&#123;\partial x&#125; + \frac&#123;\partial Q&#125;&#123;\partial y&#125; + \frac&#123;\partial R&#125;&#123;\partial z&#125;)dV = \unicode&#123;8751&#125;_&#123;\sum&#125;Pdydz + Qdzdx + Rdxdy $</span><br><span class="line"></span><br><span class="line">```latex</span><br><span class="line">$\unicode&#123;8751&#125;_&#123;\sum&#125;Pdydz + Qdzdx + Rdxdy = \iiint_&#123;\Omega&#125;(\frac&#123;\partial P&#125;&#123;\partial x&#125; + \frac&#123;\partial Q&#125;&#123;\partial y&#125; + \frac&#123;\partial R&#125;&#123;\partial z&#125;)dV$</span><br></pre></td></tr></table></figure>渲染异常$\unicode&#123;8751&#125;_&#123;\sum&#125;Pdydz + Qdzdx + Rdxdy = \iiint_&#123;\Omega&#125;(\frac&#123;\partial P&#125;&#123;\partial x&#125; + \frac&#123;\partial Q&#125;&#123;\partial y&#125; + \frac&#123;\partial R&#125;&#123;\partial z&#125;)dV$</code></pre></li></ol><h4 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h4><ol><li><p>用 <code>\unicode&#123;8751&#125;</code> 表示即可</p></li><li><p>很神奇的问题，解决方法也很玄学，将</p> <figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\unicode</span>&#123;8751&#125;<span class="built_in">_</span>&#123;<span class="keyword">\sum</span>&#125;Pdydz + Qdzdx + Rdxdy = <span class="keyword">\iiint</span><span class="built_in">_</span>&#123;<span class="keyword">\Omega</span>&#125;(<span class="keyword">\frac</span>&#123;<span class="keyword">\partial</span> P&#125;&#123;<span class="keyword">\partial</span> x&#125; + <span class="keyword">\frac</span>&#123;<span class="keyword">\partial</span> Q&#125;&#123;<span class="keyword">\partial</span> y&#125; + <span class="keyword">\frac</span>&#123;<span class="keyword">\partial</span> R&#125;&#123;<span class="keyword">\partial</span> z&#125;)dV</span><br></pre></td></tr></table></figure><p> 改为</p> <figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\unicode</span>&#123;8751&#125;<span class="built_in">_</span>&#123;<span class="keyword">\sum</span>&#125; Pdydz + Qdzdx + Rdxdy = <span class="keyword">\iiint</span><span class="built_in">_</span><span class="keyword">\Omega</span>(<span class="keyword">\frac</span>&#123;<span class="keyword">\partial</span> P&#125;&#123;<span class="keyword">\partial</span> x&#125; + <span class="keyword">\frac</span>&#123;<span class="keyword">\partial</span> Q&#125;&#123;<span class="keyword">\partial</span> y&#125; + <span class="keyword">\frac</span>&#123;<span class="keyword">\partial</span> R&#125;&#123;<span class="keyword">\partial</span> z&#125;)dV</span><br></pre></td></tr></table></figure><p> 即可</p><p> $\unicode{8751}_\sum Pdydz + Qdzdx + Rdxdy = \iiint_\Omega(\frac{\partial P}{\partial x} + \frac{\partial Q}{\partial y} + \frac{\partial R}{\partial z})dV$</p><p> 感觉可能是 <code>&#123;&#125;</code> 和 mathjax 渲染有一些冲突，具体原因还不完全清楚（？）</p></li></ol><h3 id="表格中的"><a href="#表格中的" class="headerlink" title="表格中的 |"></a>表格中的 |</h3><h4 id="问题简述-2"><a href="#问题简述-2" class="headerlink" title="问题简述"></a>问题简述</h4><p>由于 markdown 本身的语法，我们无法直接在表格中打出竖线 |</p><h4 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案"></a>解决方案</h4><ul><li>当表格内容不用 $\LaTeX$ 时，可通过转义符 <code>\|</code> 或 <code>&amp;#124;</code> 来实现竖杠或绝对值； </li><li>但是用 $\LaTeX$ 时第一个会显示为 “∥”，第二个会报错，故要用 <code>\vert</code> </li></ul><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://blog.csdn.net/skytruine/article/details/105710349">Markdown表格数学公式中使用绝对值“| |”或竖杠”|”</a></p><h3 id="背景-和-透明度"><a href="#背景-和-透明度" class="headerlink" title="背景 和 透明度"></a>背景 和 透明度</h3><h4 id="问题简述-3"><a href="#问题简述-3" class="headerlink" title="问题简述"></a>问题简述</h4><p>在 Hexo 7.x 版本下设置 背景 和 透明度</p><h4 id="解决方案-3"><a href="#解决方案-3" class="headerlink" title="解决方案"></a>解决方案</h4><ul><li><p>新建 _custom.styl 文件，并在 main.styl 中引用该文件</p>  <figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//个人添加</span></span><br><span class="line"><span class="keyword">@import</span> <span class="string">&quot;_custom.styl&quot;</span></span><br></pre></td></tr></table></figure></li><li><pre><code class="stylus"><span class="comment">//背景图片</span><span class="selector-tag">body</span> &#123;    background:url(https://pic.heson10.com/img/image-20200712231958010.png);    <span class="attribute">background-repeat</span>: no-repeat;    <span class="attribute">background-attachment</span>:fixed;    <span class="attribute">background-size</span>: cover;    <span class="attribute">background-position</span>:<span class="number">50%</span> <span class="number">50%</span>;&#125;<span class="comment">//博客内容透明化</span><span class="comment">//文章内容的透明度设置</span><span class="selector-class">.content-wrap</span> &#123;  <span class="attribute">opacity</span>: <span class="number">0.9</span>;&#125;<span class="comment">//侧边框的透明度设置</span><span class="selector-class">.sidebar</span> &#123;  <span class="attribute">opacity</span>: <span class="number">0.9</span>;&#125;<span class="comment">//菜单栏的透明度设置</span><span class="selector-class">.header-inner</span> &#123;  <span class="attribute">background</span>: rgba(<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>,<span class="number">0.9</span>);&#125;<span class="comment">//搜索框（local-search）的透明度设置</span><span class="selector-class">.popup</span> &#123;  <span class="attribute">opacity</span>: <span class="number">0.9</span>;&#125;</code></pre></li></ul><h4 id="参考-1"><a href="#参考-1" class="headerlink" title="参考"></a>参考</h4><p><a href="https://www.heson10.com/volantis/posts/52911.html">Hexo+Next7.X 博客美化教程合集</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 博客搭建 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CodeForces 补全计划（其一）</title>
      <link href="/2023/06/26/CF-Instrumentality-Project-I/"/>
      <url>/2023/06/26/CF-Instrumentality-Project-I/</url>
      
        <content type="html"><![CDATA[<p>记录一下 2023 上半年 CodeForces Contest 的补题情况</p><span id="more"></span><h2 id="Codeforces-Round-871-Div-4"><a href="#Codeforces-Round-871-Div-4" class="headerlink" title="Codeforces Round 871 (Div. 4)"></a><a href="https://codeforces.com/contest/1829">Codeforces Round 871 (Div. 4)</a></h2><h3 id="G-Hits-Different"><a href="#G-Hits-Different" class="headerlink" title="G. Hits Different"></a><a href="https://codeforces.com/contest/1829/problem/G">G. Hits Different</a></h3><h4 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h4><p><img src="1829G.png" alt="1829G"></p><p>若干块以金字塔状摆放，用球击倒下方的，上方也会倒下，第 $n$ 块分数 $n^2$，问用球打第 $n$ 块能得多少分</p><h4 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h4><p>方法一：</p><p>​    动态规划， $f[i]$ 表示击打第 $i$ 块能得的分数，$f[i] = f[左上] + f[右上] - f[公共]$，因为左上和右上是有公共部分会多算，所以简单容斥一下</p><p>方法二：</p><p>​    还是动态规划，先把图倾斜 $45°$</p><p>​    <img src="1829G-sol1.png" alt="1829G-sol1"></p><p>​    感觉变好看了一点（？）</p><p>​    再转45°</p><p><img src="1829G-sol2.png" alt="1829G-sol2"></p><p>​    嗯，变成一个简单二维DP就能解决的问题了</p><h4 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h4><p>方法一</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e6</span> + <span class="number">5</span>;</span><br><span class="line">ll f[N], num[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">  </span><br><span class="line">  num[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(ll i = <span class="number">1</span>; i &lt;= <span class="number">2000</span>; i++) num[i] = <span class="number">1ll</span> * i * (i + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">  f[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(ll i = <span class="number">2</span>; i &lt;= <span class="number">2e6</span>; i++) &#123;</span><br><span class="line">    ll sta = <span class="built_in">sqrt</span>(i * <span class="number">2</span>), kdl;</span><br><span class="line">    <span class="keyword">if</span>(num[sta] &lt; i) kdl = sta + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> kdl = sta;</span><br><span class="line">    <span class="comment">//if(i == 2) cout &lt;&lt; kdl &lt;&lt; endl;</span></span><br><span class="line">    f[i] = f[num[kdl - <span class="number">2</span>] + (i - num[kdl - <span class="number">1</span>]) - <span class="number">1</span>] * (i != num[kdl - <span class="number">1</span>] + <span class="number">1</span>) + f[num[kdl - <span class="number">2</span>] + (i - num[kdl - <span class="number">1</span>])] * (i != num[kdl]) + <span class="number">1ll</span> * i * i;</span><br><span class="line">    <span class="keyword">if</span>(i != num[kdl - <span class="number">1</span>] + <span class="number">1</span> &amp;&amp; i != num[kdl]) &#123;</span><br><span class="line">      ll x = num[kdl - <span class="number">2</span>] + (i - num[kdl - <span class="number">1</span>]) - <span class="number">1</span>;</span><br><span class="line">      f[i] -= f[num[kdl - <span class="number">3</span>] + (x - num[kdl - <span class="number">2</span>])];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> t;</span><br><span class="line">  cin &gt;&gt; t;</span><br><span class="line">  <span class="keyword">while</span>(t--) &#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    cout &lt;&lt; f[n] &lt;&lt; endl;  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法二</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">3e6</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M = <span class="number">1505</span>;</span><br><span class="line">ll f[M][M], num[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">  </span><br><span class="line">  f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  ll cnt = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">1500</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = i; j &gt;= <span class="number">1</span>; j--) &#123;</span><br><span class="line">      f[j][i - j + <span class="number">1</span>] = f[j][i - j] + f[j - <span class="number">1</span>][i - j + <span class="number">1</span>] - f[j - <span class="number">1</span>][i - j] + (cnt + <span class="number">1</span>) * (cnt + <span class="number">1</span>);</span><br><span class="line">      num[++cnt] = f[j][i - j + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> t;</span><br><span class="line">  cin &gt;&gt; t;</span><br><span class="line">  <span class="keyword">while</span>(t--) &#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    cout &lt;&lt; num[n] &lt;&lt; endl;  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Educational-Codeforces-Round-149-Rated-for-Div-2"><a href="#Educational-Codeforces-Round-149-Rated-for-Div-2" class="headerlink" title="Educational Codeforces Round 149 (Rated for Div. 2)"></a><a href="https://codeforces.com/contest/1837">Educational Codeforces Round 149 (Rated for Div. 2)</a></h2><h3 id="E-Playoff-Fixing"><a href="#E-Playoff-Fixing" class="headerlink" title="E. Playoff Fixing"></a><a href="https://codeforces.com/contest/1837/problem/E">E. Playoff Fixing</a></h3><h4 id="Description-1"><a href="#Description-1" class="headerlink" title="Description"></a>Description</h4><p>给定数 $k$，一共有 $2^k$ 个人参加比赛，序号越小的实力越强。每轮第 $2i$ 和 $2i-1$ 进行比赛，一共进行 $k$ 轮，最后要求序号为 $1$ 的一直留到最后一轮，序号为 $2$ 的留到倒数第二轮，序号为 $3 \sim 4$ 的留到倒数第三轮，以此类推，序号 $2^{k - 1} + 1$ 到 $2^k$ 的人要求第一轮淘汰，给定部分人当前位置，如果这个位置上还没确定选手就用 $-1$ 表示，问一共又有多少种表示合法方案</p><h4 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h4><p>第一轮中，我们可以知道序号 $2^{k - 1} + 1$ 到 $2^k$ 的人可以安排在哪里，一定是在 $\{1,2\}$，$\{3,4\},\cdots, \{2^k - 1,2^k\}$ 中各选一个，如果两个都没选则两个位置都可以放，记一下这种情况的个数是 $cnt1$，如果一个位置放了小于 $2^{k-1}$ 的序号，那么只能选另一个位置放，如果两个位置都被选了且不合法，那么就返回 $0$，设一共有 $cnt2$ 个可以放的位置，那么这轮方案数是 $2^{cnt1} \times cnt1 !$ 而且这一轮放置的人下一轮都被淘汰了，所以无后效性，然后下一轮其实就变为规模折半的子问题，不断迭代计算即可</p><h4 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">19</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line">ll a[(<span class="number">1</span> &lt;&lt; N) + <span class="number">5</span>], n;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">cal1</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">  ll num = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span>(x) &#123;</span><br><span class="line">    num *= x;</span><br><span class="line">    num %= mod;</span><br><span class="line">    x--;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> num % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">cal2</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">  ll num = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span>(x) &#123;</span><br><span class="line">    num *= <span class="number">2</span>;</span><br><span class="line">    num %= mod;</span><br><span class="line">    x--;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> num % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">solve</span><span class="params">(vector &lt;<span class="type">int</span>&gt; q)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  vector &lt;<span class="type">int</span>&gt; p;</span><br><span class="line">  <span class="type">int</span> cnt1 = <span class="number">0</span>, cnt2 = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">//cout &lt;&lt; n &lt;&lt; &quot;BBB&quot; &lt;&lt; endl;</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i += <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(q[i] != <span class="number">-1</span> &amp;&amp; q[i + <span class="number">1</span>] != <span class="number">-1</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span>((q[i] &gt; n / <span class="number">2</span>) == (q[i + <span class="number">1</span>] &gt; n / <span class="number">2</span>)) &#123;</span><br><span class="line">        <span class="comment">//cout &lt;&lt; &quot;AAA&quot; &lt;&lt; endl;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> p.<span class="built_in">push_back</span>(<span class="built_in">min</span>(q[i], q[i + <span class="number">1</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span>(q[i] == <span class="number">-1</span> &amp;&amp; q[i + <span class="number">1</span>] == <span class="number">-1</span>) cnt1++, cnt2++, p.<span class="built_in">push_back</span>(<span class="number">-1</span>);</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(q[i] &gt; n / <span class="number">2</span> || q[i + <span class="number">1</span>] &gt; n / <span class="number">2</span>) p.<span class="built_in">push_back</span>(<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">else</span> p.<span class="built_in">push_back</span>(<span class="built_in">max</span>(q[i], q[i + <span class="number">1</span>])), cnt2++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;  </span><br><span class="line">  n /= <span class="number">2</span>;</span><br><span class="line">  <span class="comment">//cout &lt;&lt; n &lt;&lt; endl;</span></span><br><span class="line">  <span class="comment">//cout &lt;&lt;  cnt1 &lt;&lt; &#x27; &#x27; &lt;&lt; cnt2 &lt;&lt; endl;</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">cal2</span>(cnt1) * <span class="built_in">cal1</span>(cnt2) % mod * <span class="built_in">solve</span>(p) % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">  std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">  vector &lt;<span class="type">int</span>&gt; q;</span><br><span class="line">  <span class="type">int</span> k;</span><br><span class="line">  cin &gt;&gt; k;</span><br><span class="line">  n = (<span class="number">1</span> &lt;&lt; k);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    cin &gt;&gt; x;</span><br><span class="line">    q.<span class="built_in">push_back</span>(x);</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; <span class="built_in">solve</span>(q) &lt;&lt; endl;;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="F-Editorial-for-Two"><a href="#F-Editorial-for-Two" class="headerlink" title="F. Editorial for Two"></a><a href="https://codeforces.com/contest/1837/problem/F">F. Editorial for Two</a></h3><h4 id="Description-2"><a href="#Description-2" class="headerlink" title="Description"></a>Description</h4><p>$n$ 个数中选 $k$ 个数（不改变在原序列中顺序），要求这 $k$ 个数分为前后两半后，这前后两部分和的最大值尽可能小</p><h4 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h4><p>这道题可以用二分来做，对于二分值 $lim$，先正着扫一遍，再倒着扫一遍，扫到第 $i$ 位置时，我们只要算一下前 $i - 1$ 位置中 和不超过 $lim$ 的最多可以选的数的个数 + 后 $i$ 到 $n$ 位置中 和不超过 $k$ 的最多可以选的数的个数  之和是不是大于 $k$ 即可</p><h4 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">3e5</span> + <span class="number">5</span>;</span><br><span class="line">ll a[N], n, k, num[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(ll lim)</span> </span>&#123;</span><br><span class="line">  priority_queue&lt;ll&gt; q;</span><br><span class="line">  ll s = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    s += a[i];</span><br><span class="line">    q.<span class="built_in">push</span>(a[i]);</span><br><span class="line">    <span class="keyword">while</span>(s &gt; lim) s -= q.<span class="built_in">top</span>(), q.<span class="built_in">pop</span>(); </span><br><span class="line">    num[i] = q.<span class="built_in">size</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  s = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(q.<span class="built_in">size</span>()) q.<span class="built_in">pop</span>();</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = n; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">    s += a[i];</span><br><span class="line">    q.<span class="built_in">push</span>(a[i]);</span><br><span class="line">    <span class="keyword">while</span>(s &gt; lim) s -= q.<span class="built_in">top</span>(), q.<span class="built_in">pop</span>(); </span><br><span class="line">    <span class="keyword">if</span>(num[i - <span class="number">1</span>] + q.<span class="built_in">size</span>() &gt;= k) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ll l = <span class="number">0</span>, r = <span class="number">0</span>, ans;</span><br><span class="line">  std::cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) std::cin &gt;&gt; a[i], r += a[i];</span><br><span class="line">  <span class="comment">//cout &lt;&lt; l &lt;&lt; &#x27; &#x27; &lt;&lt; r &lt;&lt; endl;</span></span><br><span class="line">  <span class="keyword">while</span>(r &gt;= l) &#123;</span><br><span class="line">    ll mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">check</span>(mid)) &#123;</span><br><span class="line">      ans = mid;</span><br><span class="line">      r = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">  std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> t;</span><br><span class="line">  std::cin &gt;&gt; t;</span><br><span class="line">  <span class="keyword">while</span>(t--) &#123;</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法竞赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大学笔记 | 大学物理BI</title>
      <link href="/2023/06/06/Physics-I/"/>
      <url>/2023/06/06/Physics-I/</url>
      
        <content type="html"><![CDATA[<p>从入门到放弃</p><span id="more"></span><p>公式汇总<br>$$<br>\begin{gather}<br>热力学\\ \<br>内能 \ \Delta E = \frac{i}{2}\frac{m}{M}R\Delta T = \frac{i}{2}pV\\ \<br>热量 \ Q = \frac{m}{M}C_k \Delta T \\ \<br>等体过程\ C_V = \frac{i}{2}R \ \ 等压过程\ C_p = \frac{i + 2}{2}R\\ \<br>等温过程\ A = \frac{m}{M}RTln\frac{V_2}{V_1}\\ \\<br>一般PV围成的面积减小是放热，增大是吸热\\ \\<br>p = nkT(微观形式)\\ \<br>\varepsilon_k = \frac{3}{2}kT\\ \<br>电场\\ \<br>均匀带电圆环轴线上电场 \ E = \frac{qx}{4\pi \varepsilon_0 (R^2 + x^2) ^{3/2}}\\ \<br>圆电流圆心处电场 \ E = 0\\ \<br>平板电容\ C = \frac{\varepsilon S}{d}\ 圆柱形电容\ C = \frac{2\pi \varepsilon l}{ln\frac{R_B}{R_A}}\ 平板电容\ C = \frac{4\pi\varepsilon R_A R_B}{R_A - R_B}\ \\ \<br>磁场 \\ \<br>圆电流轴线上磁场 \ B = \frac{\mu_0 I R^2}{2(R^2 + x^2)^{3 / 2}}\\ \<br>圆电流圆心处产生磁场 \ B = \frac{\mu I}{2R} \\ \<br>\end{gather}<br>$$</p><h2 id="第三章-刚体的定轴转动"><a href="#第三章-刚体的定轴转动" class="headerlink" title="第三章 刚体的定轴转动"></a>第三章 刚体的定轴转动</h2><ul><li>常见几何体的转动惯量<ul><li>细圆环 &amp; 薄圆环 $MR^2$</li><li>薄圆盘 &amp; 圆柱体 $\frac{1}{2}MR^2$</li><li>细棒 中心轴 $\frac{1}{12}MR^2$ 一端 $\frac{1}{3}ML^2$</li><li>薄球壳 $\frac{2}{3}MR^2$</li><li>球体 $\frac{2}{5}MR^2$</li></ul></li></ul><h2 id="第六章-热力学基础"><a href="#第六章-热力学基础" class="headerlink" title="第六章 热力学基础"></a>第六章 热力学基础</h2><h3 id="S-6-1-热力学第一定律"><a href="#S-6-1-热力学第一定律" class="headerlink" title="$\S 6.1$ 热力学第一定律"></a>$\S 6.1$ 热力学第一定律</h3><ul><li><p>热力学过程，准静态过程(曲线描述， 方程描述)</p><p>  <strong>只有准静态过程才能用曲线描述出来</strong></p></li><li><p>内能， 热量， 功</p><p>​    </p><p>​    </p></li></ul><h3 id="6-2-理想气体的典型热力学过程"><a href="#6-2-理想气体的典型热力学过程" class="headerlink" title="$6.2$ 理想气体的典型热力学过程"></a>$6.2$ 理想气体的典型热力学过程</h3><ul><li><p>等体过程$$\begin{cases} 功 &amp; \\ 内能 &amp; \\ 热量 &amp; \end{cases}$$</p></li><li><p>等压过程$$\begin{cases} 功 &amp; \\ 内能 &amp; \\ 热量 &amp; \end{cases}$$</p></li><li><p>等温过程$$\begin{cases} 功 &amp; \\ 内能 &amp; \\ 热量 &amp; \end{cases}$$</p></li><li><p>绝热过程$$\begin{cases} 功 &amp; \\ 内能 &amp; \\ 热量 &amp; \end{cases}$$</p></li></ul><h3 id="S-6-3-循环过程"><a href="#S-6-3-循环过程" class="headerlink" title="$\S 6.3$ 循环过程"></a>$\S 6.3$ 循环过程</h3><h3 id="S-6-4-热力学第二定律"><a href="#S-6-4-热力学第二定律" class="headerlink" title="$\S 6.4$ 热力学第二定律"></a>$\S 6.4$ 热力学第二定律</h3><h2 id="第七章-静电场"><a href="#第七章-静电场" class="headerlink" title="第七章 静电场"></a>第七章 静电场</h2><h4 id="第七章总结"><a href="#第七章总结" class="headerlink" title="第七章总结"></a>第七章总结</h4><ol><li><p>$k = \frac{1}{4\pi \varepsilon_0}$ ，$F = \frac{q_1q_2}{4\pi \varepsilon r^2}$</p></li><li><p>无限长均匀带电直线和均匀带电半圆弧对圆心处场强相等</p></li><li><p>电位移矢量 $\vec D = \varepsilon_0\varepsilon_r\vec E = \varepsilon \vec E$ ，很多时候 $\vec D$ 和 $\vec E$ 很相像，只是 $D$ 既与 $E$ 有关，又与电介质有关 </p></li><li><p>$\oint \vec D \cdot d\vec S = q$ ，多用对称做</p></li><li><p>$W_e = \frac{1}{2}U_{ab}Q, w_e = \frac{1}{2}DE$</p></li><li><p>平行板电容 $C = \frac{\varepsilon S}{d}$ ，圆柱形电容 $C = \frac{2 \pi \varepsilon l}{ln\frac{R_B}{R_A}}$， 球形电容 $C = \frac{4\pi \varepsilon R_A R_B}{R_B - R_A}$</p></li></ol><h3 id="S-7-1-点电荷-库仑定律"><a href="#S-7-1-点电荷-库仑定律" class="headerlink" title="$\S 7.1$ 点电荷 库仑定律"></a>$\S 7.1$ 点电荷 库仑定律</h3><ul><li>电荷的分类，电荷的量子化，电荷守恒定律，点电荷</li><li>库伦定律<ul><li>真空中， $\vec{F} = k\frac{q_1q_2}{r^2}\vec{e_r} = \frac{1}{4\pi\varepsilon_0}\frac{q_1q_2}{r^2}\vec{e_r}$</li><li>电介质中，$\vec{F} = \frac{1}{4\pi\varepsilon_0\varepsilon_r}\frac{q_1q_2}{r^2}\vec{e_r} = \frac{1}{4\pi\varepsilon}\frac{q_1q_2}{r^2}\vec{e_r}$</li></ul></li></ul><h3 id="S-7-2-电场-电场强度"><a href="#S-7-2-电场-电场强度" class="headerlink" title="$\S 7.2$ 电场 电场强度"></a>$\S 7.2$ 电场 电场强度</h3><p>​    电荷之间的作用是通过电场实现的</p><ul><li><p>电场强度 $\vec{E}= \frac{\vec{F}}{q_0} $</p></li><li><p>场强叠加原理</p></li><li><p>场强计算</p><ul><li><p>点电荷 $\vec{E} = \frac{q}{4\pi\varepsilon_0r^2}\vec{e_r}$</p></li><li><p>电偶极子（偶极矩 $\vec{p} = q\vec{l}$）（特殊情况下场强用中垂线和轴线场强叠加得到）</p><p>  中垂线上场强 $E_B = \frac{ql}{4\pi\varepsilon_0(r^2 + \frac{l^2}{4})^{3/2}}\approx \frac{-\vec{p}}{4\pi\varepsilon_0r^3}$</p><p>  轴线上场强 $E_A = \frac{1}{4\pi\varepsilon_0}[\frac{q}{(r - \frac{l}{2})^2} - \frac{q}{(r + \frac{l}{2})^2}] \approx\frac{ql}{2\pi\varepsilon_0r^3} = \frac{\vec{p}}{2\pi\varepsilon_0r^3}$</p></li><li><p><img src="%E4%BE%8B4.1.png" alt="例4.1"></p><p>  对于一均匀带电直线（$l,q$) 如上图，与其垂直相距 $a$ 的一点场强</p><p>  $E_x = \frac{\lambda}{4\pi\varepsilon_0a}(sin\theta_2 - \sin\theta_1)$</p><p>  $E_y = \frac{\lambda}{4\pi\varepsilon_0a}(cos\theta_1 - \cos\theta_2)$</p><p>  特殊的，中垂线上 $E = E_y = \frac{q}{4\pi\varepsilon_0a\sqrt{a^2 + l^2/4}}$</p><p>  ​                直线无限长时，$E = E_y = \frac{\lambda}{2\pi\varepsilon_0a}$</p></li><li><p>圆环轴线电场计算既可以直接算，也可以把上下分成两部分，各压缩为 $\frac{q}{2}$ 的点电荷来算 $E = \frac{1}{4\pi\varepsilon_0}\frac{qx}{(R^2 + x^2)^{\frac{3}{2}}}$</p></li><li><p>算圆盘电场可看作无数个圆环电场叠加 $E = \int_0^R\frac{1}{4\pi\varepsilon_0}\frac{2x\sigma\pi rdr}{(x^2 + r^2)^{3/2}} = \frac{\sigma}{2\varepsilon_0}[1-\frac{x}{\sqrt{x^2+R^2}}]$</p><p>  特殊的，当 $R \to \infty$，$E = \frac{\sigma}{2\varepsilon_0}$</p><p>  将两个带有等量异种电荷无限大板放一块，板中间 $E = \frac{\sigma}{\varepsilon_0}$，板外是 $0$</p><p>  注：电荷量密度是代数量，本身有正负</p></li><li><p>无限长均匀带电直线和均匀带电半圆弧对圆心产生的q等效</p></li></ul></li></ul><h3 id="S-7-3-静电场中的电介质-电位移"><a href="#S-7-3-静电场中的电介质-电位移" class="headerlink" title="$\S 7.3$ 静电场中的电介质 电位移"></a>$\S 7.3$ 静电场中的电介质 电位移</h3><ul><li><p>电介质，偶极子模型，有极分子，无极分子</p></li><li><p>电介质的极化（一般电场越强，温度越低（温度低使分子无规律性降低），分子排列越有序，极化效果越显著）</p><ul><li><p>位移极化</p><p>  分子中正负电荷各收到电场力，由于正负电荷中心相对位移而极化</p></li><li><p>转向极化</p><p>  分子收到电场产生的力矩作用而有序排列，从而产生的极化</p><p>二者宏观表现相同，一般不刻意区分</p><p>当介质中分子电偶极矩和不为零时，介质被极化</p><p>分子极化导致介质端面上出现的电荷称为束缚电荷，这种现象称为电极化</p><p>介质中电场 $E$ 是由自由电荷电场 $E_0$ 和极化电荷电场 $E’$ 叠加的结果，有 $\vec{E} = \vec{E’} + \vec{E_0}$（$E_0, E’$ 方向相反）</p><p>当介质<strong>均匀充满</strong>电场时，介质中任一点场强 $\vec{E}$ 为原来真空中该处场强 $\vec{E_0}$ 的 $\frac{1}{\varepsilon_r}$，$\varepsilon_r$ 因介质而异</p><p>电介质不被击穿的最大电场强度为该电介质的介电强度</p></li></ul></li><li><p>电极化强度</p><p>  $\vec P = \frac{\sum \vec P_{mole}}{\Delta V}$，单位是 $C·m^{-2}$ ，称为电极化强度矢量，反映了介质内电极化的强弱和方向</p><p>  均匀极化后的电极化强度等于极电荷密度 $\vec P = \sigma’$</p><p>  故有 $\vec E_0 = \frac{\sigma}{\varepsilon_0},\vec E’ = \frac{\sigma’}{\varepsilon_0},\vec E = \frac{\sigma}{\varepsilon_0\varepsilon_r}$，带入三者关系式得 $\sigma’ = \frac{\varepsilon_r - 1}{\varepsilon_r} \sigma$，反映了自由电荷和极化电荷的关系</p><p>  令 $\chi_e = \varepsilon_e - 1$，称为电介质的电极化率，那么 $P = \frac{\varepsilon_r - 1}{\varepsilon_r} \sigma = \varepsilon_0\chi_eE$</p></li><li><p>电位移矢量</p><p>  $\vec D = \varepsilon_0\vec E + \vec P = \varepsilon_0\varepsilon_r\vec E = \varepsilon\vec E$，$\vec D$ 为电位移矢量，$\varepsilon$ 称为介电常数</p></li></ul><h3 id="S-7-4-静电场中高斯定理"><a href="#S-7-4-静电场中高斯定理" class="headerlink" title="$\S 7.4$ 静电场中高斯定理"></a>$\S 7.4$ 静电场中高斯定理</h3><ul><li><p>电场线（有源性，无旋性，互不相交），电位移线，电通量$\Phi_e$（穿出闭合面为正，穿出为负）</p></li><li><p>高斯定理</p><p>  $\oint_S \vec D d\vec S = \sum q_i$ 这里的 $q$ 均为高斯面内部，高斯面并不客观存在</p></li></ul><h3 id="S-7-5-静电场的环路定理-电势"><a href="#S-7-5-静电场的环路定理-电势" class="headerlink" title="$\S 7.5$ 静电场的环路定理 电势"></a>$\S 7.5$ 静电场的环路定理 电势</h3><ul><li><p>静电场的环路定理</p><p>  $\oint_L E·dl = 0$，电场力是保守力，静电场是保守力场（有势场）</p></li><li><p>电势，电势叠加原理，</p></li></ul><h3 id="S-7-6-电场强度与电势梯度的关系"><a href="#S-7-6-电场强度与电势梯度的关系" class="headerlink" title="$\S 7.6$ 电场强度与电势梯度的关系"></a>$\S 7.6$ 电场强度与电势梯度的关系</h3><ul><li><p>等势面，电势梯度</p><p>  $\bigtriangledown = \frac{\partial}{\partial x}\vec i + \frac{\partial}{\partial y}\vec j + \frac{\partial}{\partial z}\vec k \to \vec E = -\bigtriangledown U$</p></li></ul><h3 id="S-7-7-静电场中的导体"><a href="#S-7-7-静电场中的导体" class="headerlink" title="$\S 7.7$ 静电场中的导体"></a>$\S 7.7$ 静电场中的导体</h3><ul><li><p>静电平衡</p><ul><li><p>条件</p><p>  导体内部 $\vec E = 0$，导体表面 $\vec E$ 与导体垂直，故导体为等势体</p></li><li><p>净电荷只分布于表面</p><p>  对于有空腔，空腔内无电荷的导体，净电荷依然只分布在外表面</p><p>  对于有空腔且空腔内有电荷的导体，内空腔表面产生电荷是内空腔电荷代数和为 $0$</p><p>  处于静电平衡的导体表面电荷面密度与该处表面曲率半径成正比</p><p>导体表面<strong>附近</strong>电场强度 $E = \frac{\sigma}{\varepsilon_0}$</p></li></ul></li><li><p>静电屏蔽</p><p>  导体空腔可以使腔内空间不受腔外带电体影响</p><p>  接地导体空腔可以使腔外空间不受腔内带电体影响</p></li><li><p>电容器</p><ol><li><p>平板电容器</p><p> $E = \frac{\sigma}{\varepsilon},U_{AB} = \frac{\sigma}{\varepsilon}d = \frac{qd}{\varepsilon s},C = \frac{q}{U_{AB}} = \frac{\varepsilon S}{d}$</p></li><li><p>圆柱形电容器</p><p> $E = \frac{\lambda}{2\pi\varepsilon r},U_{AB} = \frac{\lambda}{2\pi\varepsilon}ln\frac{R_B}{R_A},C = \frac{q}{U_{AB}} = \frac{2\pi\varepsilon l}{ln\frac{R_B}{R_A}}$</p></li><li><p>球形电容器</p><p> $E = \frac{q}{4\pi\varepsilon r^2},U_{AB} = \frac{q}{4\pi\varepsilon}(\frac{1}{R_A}-\frac{1}{R_B}),C = \frac{q}{U_{AB}} = \frac{4\pi\varepsilon R_A R_B}{R_B-R_A}$</p><p>决定电容器电容的因素是电容器的大小，形状，板间电介质</p></li></ol></li><li><p>电场能量</p><p>  $W_e = \frac{1}{2}U_{ab}Q = \frac{1}{2}CU_{ab}^2 = \frac{1}{2}\frac{Q_{ab}^2}{C}$</p><p>  $w_e = \frac{W_e}{V} = \frac{1}{2}\varepsilon E^2$，$w_e$ 是电场能量密度</p><p>  $W_e = \int_V w_edV$</p></li></ul><h2 id="第八章-稳恒磁场"><a href="#第八章-稳恒磁场" class="headerlink" title="第八章 稳恒磁场"></a>第八章 稳恒磁场</h2><h3 id="S-8-1-恒定电流"><a href="#S-8-1-恒定电流" class="headerlink" title="$\S 8.1$ 恒定电流"></a>$\S 8.1$ 恒定电流</h3><ul><li><p>电流和电流密度</p><p>  $I = \frac{dq}{dt} = qnvs$</p><p>  传导电流：到电介质中电荷的定向移动</p><p>  运流电流：带电导体的机械运动</p><p>  电流密度 $\vec J = \frac{dI}{dS_\tau}\vec e_n = \rho \vec v = nq \vec v$ </p><p>  $dI = JdS \times cos\theta = \vec J \cdot d\vec S,I = \int_S \vec J \cdot d\vec S$</p></li><li><p>欧姆定律</p><p>  $I = \frac{U}{R} = GU$</p><p>  $R = \int \frac{\rho dl}{S}$</p><p>  $J = \sigma E$      $\sigma$ 是电导率，$E$ 是场强</p></li><li><p>电动势</p><p>  电源提供非静电力使正电荷沿逆静电场方向运动</p><p>  电动势是单位正电荷绕闭合回路运动一周非静电力做的功 $\varepsilon = \frac{A}{q} = \oint_L\vec E_k d\vec l$ </p><p>  与电势不同的是，电动势与路径<strong>有关</strong></p></li></ul><h3 id="S-8-2-基本磁现象-安培定律"><a href="#S-8-2-基本磁现象-安培定律" class="headerlink" title="$\S 8.2$ 基本磁现象 安培定律"></a>$\S 8.2$ 基本磁现象 安培定律</h3><ul><li><p>基本磁现象</p></li><li><p>安培定律</p><p>  $F = \frac{\mu_0}{4\pi}\oint_{c_2}I_2d\vec l_2 \times \oint_{c_1} \frac{I_1d\vec l_1 \times \vec r_{12}}{\vec r_{12}^3} $</p><p>  方向：右手法则</p><p>  电流元之间的安培力不满足力的作用力和反作用力定律</p><blockquote><p>可以这样想，看是否满足力的相互作用关系就是看它们是否动量守恒，而两个电流元和它们中间的电磁场作为一个整体是守恒的，而电磁场动量不为 $0$，故不满足作用力与反作用力关系</p></blockquote></li></ul><h3 id="S-8-3-磁场-毕奥-萨伐尔定律"><a href="#S-8-3-磁场-毕奥-萨伐尔定律" class="headerlink" title="$\S 8.3$ 磁场 毕奥-萨伐尔定律"></a>$\S 8.3$ 磁场 毕奥-萨伐尔定律</h3><ul><li><p>磁场 磁感应强度</p><p>  磁场是一种特殊形态的<strong>物质</strong></p><p>  磁矩 $\vec m = IS\vec e_n$ 其中 $\vec e_n$ 与 $I$ 成方向满足右手螺旋定则</p><p>  $B = \frac{F_{max}}{qv} = \frac{dF}{Idl}$ ，$\vec B$ 的方向：$\vec F_{max} \times \vec v$</p></li><li><p>毕奥-萨伐尔定律</p><p>  电流元视为运动电荷的集合 $Id\vec l = dNq\vec v = nsd\vec lq \vec v$</p><p>  $dB = \frac{\mu_0Id\vec l \times \vec r}{4\pi r^3} = N\frac{\mu_0}{4\pi}\frac{q\vec v \times \vec r}{r^3},\ \mu_0 = 4\pi \times 10 ^{-7} N / A^2$</p><p>  方向遵循右手法则 $Id\vec l \times \vec r$</p><ul><li><p>有限长的载流直导线磁场 $B = \frac{\mu_0I}{4\pi x}(cos\theta_1 - cos\theta_2)$</p><p><img src="%E8%BD%BD%E6%B5%81%E7%9B%B4%E5%AF%BC%E7%BA%BF%E7%A3%81%E5%9C%BA.png" alt="载流直导线磁场"></p><p>​    一些特殊情况</p><p>​        点在直导线延长线上时 $B = 0$</p><p>​        无限长的载流直导线磁场 $B = \frac{\mu_0I}{2\pi a}$</p><p>​        半无限长的载流直导线磁场 $B = \frac{\mu_0I}{4\pi a}$</p><p>​        圆电流轴线上的磁场</p><p>​        $B = \frac{\mu_0IR^2\vec i}{2(R^2 + x^2)^{3/2}}$</p></li><li><p>圆电流直线上磁场磁场 $B = \frac{\mu_0IR^2\vec i}{2(R^2 + x^2)^{3/2}}$</p><p>  <img src="%E5%9C%86%E7%94%B5%E6%B5%81%E8%BD%B4%E7%BA%BF%E4%B8%8A%E7%9A%84%E7%A3%81%E5%9C%BA.png" alt="圆电流轴线上的磁场"></p><p>  一些说明</p><p>  ​            x=0时 $B = \frac{\mu_0 I}{2R}$</p><p>  ​            方向满足右手螺旋定则</p><p>  ​            N匝时， $B = N\frac{\mu_0IR^2\vec i}{2(R^2 + x^2)^{3/2}}$</p><p>  半无限长的载流直导线磁场 $B = \frac{\mu_0I}{4\pi a}$</p></li><li><p>载流直螺线管内部磁场 $B = \frac{\mu_0 nI}{2}(cos \beta_2 - cos\beta_1)$</p></li></ul></li></ul><p><img src="%E8%9E%BA%E7%BA%BF%E7%AE%A1%E5%86%85%E9%83%A8%E7%A3%81%E5%9C%BA-1.png" alt="螺线管内部磁场-1"></p><p><img src="%E8%9E%BA%E7%BA%BF%E7%AE%A1%E5%86%85%E9%83%A8%E7%A3%81%E5%9C%BA-2.png" alt="螺线管内部磁场-2"></p><p>​        一些特殊情况</p><p>​            无限长螺线管内部磁场 $B = \mu_0nI$</p><p>​            半无限长螺线管内部磁场 $B = \frac{\mu_0nI}{2}$</p><h3 id="S-8-4-磁通量-磁场中的高斯定理"><a href="#S-8-4-磁通量-磁场中的高斯定理" class="headerlink" title="$\S 8.4$ 磁通量 磁场中的高斯定理"></a>$\S 8.4$ 磁通量 磁场中的高斯定理</h3><ul><li>磁场线</li></ul><p>​        该点切线方向为该点磁场方向</p><p>​        不相交，是闭合的，磁场线和形成磁场的电流成右手螺旋关系</p><ul><li><p>磁通量</p><p>  匀强时 $\phi_m = \vec B \cdot \vec S$</p><p>  对任意磁场 $\phi_m = \int \vec B \cdot d\vec S$</p></li><li><p>磁场高斯定理</p><p>  $\oint \vec B \cdot d\vec S = 0$ 说明磁场是无源场</p></li></ul><h3 id="S-8-5-磁场对载流导线和运动电荷的作用"><a href="#S-8-5-磁场对载流导线和运动电荷的作用" class="headerlink" title="$\S 8.5$ 磁场对载流导线和运动电荷的作用"></a>$\S 8.5$ 磁场对载流导线和运动电荷的作用</h3><ul><li><p>安培力</p><p>  磁场中导线受到力的作用 $dF = Id\vec l \times \vec B$</p></li><li><p>磁场对直导线</p><p>  $F = BIlsin \alpha$</p></li><li><p>磁场对线圈</p><p>  当磁场与线圈倾斜一个角度时，会产生力矩 $M = BISsin\phi$</p><p>  定义磁矩 $\vec P_m = NIS\cdot \vec n, \vec M = \vec P_m \times \vec B$</p><p>  磁矩方向和磁场方向对线圈具体影响如下</p><p>  <img src="%E7%A3%81%E5%9C%BA%E6%96%B9%E5%90%91%E5%AF%B9%E7%BA%BF%E5%9C%88%E7%9A%84%E5%BD%B1%E5%93%8D.png" alt="磁场方向对线圈的影响"></p></li><li><p>洛伦兹力</p><p>  $\vec F_m = q\vec v\times \vec B$ 同样符合右手螺旋定则，注意 $q$ 的方向是以电流方向而定</p></li><li><p>霍尔效应</p><p>  霍尔电势差 $U_H = R_H\frac{IB}{b}$，$R_H$ 称为霍尔系数，平衡后电子受到洛伦兹力和电场力平衡<br>  $R_H$ 为正，空穴载流子，$p$ 型半导体；$R_H$ 为负，导体或 $n$ 型半导体</p><p>   <img src="%E9%9C%8D%E5%B0%94%E6%95%88%E5%BA%94-%E5%8D%8A%E5%AF%BC%E4%BD%93%E7%B1%BB%E5%9E%8B.png" alt="霍尔效应-半导体类型"></p></li></ul><h3 id="S-8-6-磁介质-磁化过程"><a href="#S-8-6-磁介质-磁化过程" class="headerlink" title="$\S 8.6$ 磁介质 磁化过程"></a>$\S 8.6$ 磁介质 磁化过程</h3><ul><li><p>磁介质</p><p>  $\vec B = \vec B_0 + \vec B’$ 右式两项同向时，是顺磁质（磁化后使空间磁场变强），反之为抗磁质（磁化后使空间磁场变弱），若未顺磁质且 $\vec B’ &gt;&gt; \vec B_0$ 称为铁磁质</p></li><li><p>分子磁矩</p><p>  物质分子中，每个电子参与两种运动——绕核的轨道运动（轨道磁矩）和自身旋转运动（自旋磁矩）</p><p>  两种磁矩矢量和是分子磁矩，可以用一个圆电流表示，称为分子电流</p></li><li><p>磁化强度</p><p>  $\vec M = \frac{\sum \vec P_m}{\Delta V}$ 单位体积内分子磁矩矢量和</p></li><li><p>磁场强度</p><p>  磁介质存在时，介质中磁感应强度 $\vec B = \vec B_0 + \mu_0 \vec M$</p><p>  引入磁场强度 $\vec H = \frac{\vec B}{\mu_0} - \vec M$</p><p>  研究表明对于各向同性非铁磁介质，磁化强度和磁场强度满足 $\vec M = \chi_m \vec H$，$\chi_m$ 称为介质的磁化率</p><p>  则有 $\vec B = \mu_0(1 + \chi_m)\vec H = \mu_0\mu_r \vec H = \mu \vec H$，其中 $\mu_r = 1 + \chi_m$ $\mu, \mu_r$ 分别被称为磁导率和相对磁导率，$\vec H = \frac{\vec B}{\mu}$</p><p>  <img src="%E7%A3%81%E4%BB%8B%E8%B4%A8%E6%95%B0%E5%80%BC.png" alt="磁介质数值"></p></li><li><p>铁磁质</p><p>  磁导率大，磁饱和现象，磁滞回线</p></li></ul><h3 id="S-8-7-安培环路定理"><a href="#S-8-7-安培环路定理" class="headerlink" title="$\S 8.7$ 安培环路定理"></a>$\S 8.7$ 安培环路定理</h3><ul><li>安培环路定理</li></ul><p>​        $\oint \vec B \cdot d\vec l = \mu_0 \sum I_内$ 或 $\oint \vec H \cdot d\vec l = \sum I_内$ 电流方向有正有负，和 $B$ 成右手螺旋关系则为正，反之为负 </p><p>​        积分回路是 $N$ 圈时，$\oint \vec H \cdot d\vec l = N\sum I_内$</p><p>​        无限长线圈场内 $B = \mu_0 n I$ </p><p>​        无限大平面（线密度 $I$） $B = \frac{\mu_0 I}{2}$</p><h2 id="第九章-电磁感应与麦克斯韦方程组"><a href="#第九章-电磁感应与麦克斯韦方程组" class="headerlink" title="第九章 电磁感应与麦克斯韦方程组"></a>第九章 电磁感应与麦克斯韦方程组</h2><h3 id="S-9-1-电磁感应的基本规律"><a href="#S-9-1-电磁感应的基本规律" class="headerlink" title="$\S 9.1$ 电磁感应的基本规律"></a>$\S 9.1$ 电磁感应的基本规律</h3><ul><li><p>法拉第电磁感应定律</p><p>  $\varepsilon = -N\frac{d\phi}{dt} \rightarrow q = \frac{\phi_1 - \phi_2}{R}$</p></li><li><p>楞次定律</p><p>  感应电流总是反抗磁场引起的变化</p></li></ul><h3 id="S-9-2-动生电动势与感生电动势"><a href="#S-9-2-动生电动势与感生电动势" class="headerlink" title="$\S 9.2$ 动生电动势与感生电动势"></a>$\S 9.2$ 动生电动势与感生电动势</h3><ul><li><p>动手电动势</p><p>  $\varepsilon = Bvl$，方向：右手法 / 楞次定律 </p></li><li><p>感生电动势</p><p>  $\varepsilon = -\frac{d\phi_m}{dt} = \frac{\partial\vec B}{\partial t}\cdot dS$</p></li><li><p>涡流与趋肤效应</p></li></ul><h3 id="S-9-3-自感与互感"><a href="#S-9-3-自感与互感" class="headerlink" title="$\S 9.3$ 自感与互感"></a>$\S 9.3$ 自感与互感</h3><ul><li><p>自感</p><p>  $N\phi_m = LI  \rightarrow L = N\frac{\phi}{I} \rightarrow \varepsilon = -N\frac{d\phi_m}{dt} = -NL\frac{dI}{dt}$</p></li><li><p>互感</p><p>  $\varepsilon_1 = -M\frac{dI_2}{dt},\varepsilon_2 = -M\frac{dI_1}{dt}$ ，$M$ 只与线圈各属性和磁介质情况有关 </p></li></ul><h3 id="S-9-4-磁场的能量"><a href="#S-9-4-磁场的能量" class="headerlink" title="$\S 9.4$ 磁场的能量"></a>$\S 9.4$ 磁场的能量</h3><p>磁场能量密度 $w_m = \frac{B^2}{2\mu} = \frac{1}{2}\mu H^2 = \frac{1}{2}BH \rightarrow W_m = \int w_mdV$</p><h3 id="S-9-5-位移电流"><a href="#S-9-5-位移电流" class="headerlink" title="$\S 9.5$ 位移电流"></a>$\S 9.5$ 位移电流</h3><ul><li><p>位移电流</p><p>  由于变化的磁场也可以产生电流，故麦克斯韦提出可以假设变化的磁场之间（如两个电极板之间）也看作是有电流存在，这个电流被称为位移电流，$I_d = \frac{d\phi}{dt}$ 位移电流密度 $\vec J_d = \frac{d\vec D}{dt}$</p><p>  位移电流的实质其实就是变化的电场，只要有变化的电场，或有磁场使电场变化，则有位移电流</p><p>  值得一提的是，两种电流在产生磁场方面是等效的，但是位移电流不产生焦耳热</p></li><li><p>全电流</p><p>  $I_全 = I + I_d$ </p><p>  安培环路定理完善为 $\oint \vec H\cdot d\vec l = \sum I_全 = \sum I + \sum I_d$</p></li></ul><h3 id="S-9-6-麦克斯韦方程组"><a href="#S-9-6-麦克斯韦方程组" class="headerlink" title="$\S 9.6$ 麦克斯韦方程组"></a>$\S 9.6$ 麦克斯韦方程组</h3><p><img src="%E9%BA%A6%E5%85%8B%E6%96%AF%E9%9F%A6%E6%96%B9%E7%A8%8B%E7%BB%84.png" alt="麦克斯韦方程组"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 大学课程 </tag>
            
            <tag> 物理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大学笔记 | 线性代数</title>
      <link href="/2023/06/06/Linear-Algebra/"/>
      <url>/2023/06/06/Linear-Algebra/</url>
      
        <content type="html"><![CDATA[<p>从入门到入土</p><span id="more"></span><h2 id="第一章-矩阵的运算与初等变换"><a href="#第一章-矩阵的运算与初等变换" class="headerlink" title="第一章 矩阵的运算与初等变换"></a>第一章 矩阵的运算与初等变换</h2><h3 id="S-1-1-矩阵和向量的概念"><a href="#S-1-1-矩阵和向量的概念" class="headerlink" title="$\S 1.1$ 矩阵和向量的概念"></a>$\S 1.1$ 矩阵和向量的概念</h3><ul><li><p>矩阵</p><p>  $m \times n$ 的数表构成 $m$ 行 $n$ 列矩阵，这 $m \times n$ 个数是 $A$ 的元素，简称元</p><p>  实矩阵就是全是实数元素的矩阵</p><p>  复矩阵就是全是复数元素的矩阵</p><ul><li><p>特殊矩阵</p><p>  同型矩阵：行数和列数都分别相等的矩阵（指的是两个矩阵之间的关系）</p><p>  相等矩阵：同型矩阵、对应元素相等<br>  方阵：行数列数相等（就单个矩阵而言）</p><p>  上（下）三角矩阵：主对角线下（上）元素全为 $0$ 的矩阵</p><p>  对角矩阵：只有对角线上元素不为 $0$</p><p>  列矩阵，行矩阵：$1 \times n$，$n \times 1$ 的矩阵</p><p>  单位矩阵：特殊的对角阵，对角线上全为 $1$</p><p>  零矩阵：全为 $0$</p><p>  负矩阵：$-A $ 是 $A$ 的负矩阵</p><p>  对称矩阵：元素关于对角线对称</p><p>  反对称矩阵：元素关于对角线称相反数且对角线上元素全为 $0$</p></li></ul></li></ul><h2 id="第二章-方阵的行列式"><a href="#第二章-方阵的行列式" class="headerlink" title="第二章 方阵的行列式"></a>第二章 方阵的行列式</h2><h3 id="省流"><a href="#省流" class="headerlink" title="省流"></a>省流</h3><p>行列式</p><h2 id="第三章-可逆矩阵"><a href="#第三章-可逆矩阵" class="headerlink" title="第三章 可逆矩阵"></a>第三章 可逆矩阵</h2><h3 id="省流-1"><a href="#省流-1" class="headerlink" title="省流"></a>省流</h3><p>可逆矩阵，行列式的秩，伴随矩阵</p><h2 id="第四章-线性方程组和向量组的线性相关性"><a href="#第四章-线性方程组和向量组的线性相关性" class="headerlink" title="第四章 线性方程组和向量组的线性相关性"></a>第四章 线性方程组和向量组的线性相关性</h2><h3 id="省流-2"><a href="#省流-2" class="headerlink" title="省流"></a>省流</h3><p>方程组数和未知数相等可以直接用卡莱姆法则</p><p>不同的时候，齐次下直接找通解，非齐次是通解和特解叠加</p><h2 id="第五章-方阵的特征值，特征向量与相似化简"><a href="#第五章-方阵的特征值，特征向量与相似化简" class="headerlink" title="第五章 方阵的特征值，特征向量与相似化简"></a>第五章 方阵的特征值，特征向量与相似化简</h2><h3 id="S-5-1-数域-多项式的根"><a href="#S-5-1-数域-多项式的根" class="headerlink" title="$\S 5.1$ 数域 多项式的根"></a>$\S 5.1$ 数域 多项式的根</h3><ul><li><p>数域</p><p>  设 $\mathbb{Q} \subseteq K \subseteq \mathbb{C}$，称 $K$ 为一个数域，当：</p><ol><li>$0, 1 \in K$</li><li>$\forall a, b \in K. a \pm b, ab \in K$， 且对 $b \not= 0, b^{-1} \in K$</li></ol></li><li><p>多项式，根，零点，标准分解式</p></li></ul><h3 id="S-5-2-方阵的特征值与特征向量"><a href="#S-5-2-方阵的特征值与特征向量" class="headerlink" title="$\S 5.2$ 方阵的特征值与特征向量"></a>$\S 5.2$ 方阵的特征值与特征向量</h3><ul><li><p>$n$ 阶 $A$ 矩阵对角线上元素的和称为 $A$ 的迹，记为 $trA$</p></li><li><p>$\lambda E - A$ 称为 $A$ 的特征矩阵，$|\lambda E - A|$ 的值表达式 $\psi(\lambda)$ 是一   </p><p>  个多项式，称为 $A$ 的特征多项式，特征多项式的根称为 $A$ 的特征值，亦称为特征根 </p><ul><li>$\psi(\lambda) = \lambda^n+c_{n-1}\lambda^{n-1}+ \cdots + c_1\lambda + c_0$ 则有 $c_{n - 1} = -trA,c_0 = (-1)^n|A|$</li><li>设 $n$ 阶矩阵 $A$ 的全部特征值 $\lambda_1,\lambda_2,\cdots,\lambda_n$，则有<ol><li>$|A| = \lambda_1\cdots\lambda_n$</li><li>$tr(A) = \lambda_1 + \cdots + \lambda_n$</li><li>由 $(1)$ 可知方阵可逆的充要条件是所有特征值均不为 $0$</li></ol></li></ul></li><li><p>非零特征向量 $a$ 满足对于特征值 $\lambda_0$，有 $Aa = \lambda_0a$ </p><ul><li>若存在数 $\lambda_0$ 以及非零向量 $a$ 使 $Aa = \lambda_0a$ ，则必有 $\lambda_0$ 是 $A$ 的特征值，$a$ 是 $A$ 关于 $\lambda_0$ 的特征向量</li><li>属于不同特征值的特征向量是线性无关的</li><li>对于矩阵 $A$ 的 $r$ 重特征值 $\lambda$ ，属于他的线性无关特征向量个数 $k \le r$</li></ul></li><li><p>一些结论和补充</p><ul><li><p>设 $R(A) = n - 1$ ，则 $A^*$ 的特征值为 $0$ （$n-1$ 重）和 $\sum_{i = 1}^{n}A_{ii}$ （$A_{ii}$ 为 $A$ 的元素 $a_{ii}$  对应的代数余子式）</p></li><li><p>设 $R(A) &lt; n-1$ ，则 $A^*$ 有 $n$ 重零特征值</p></li><li><p>若 $\lambda$ 是 $A$ 的特征值，则 $\varphi(\lambda)$ 是 $\varphi(A)$ 的特征值</p></li><li><table><thead><tr><th align="left"></th><th>$A$</th><th>$\varphi(A)$</th><th>$A^{-1}$</th><th>$A^*$</th><th>$B=P^{-1}AP$</th></tr></thead><tbody><tr><td align="left">特征值</td><td>$\lambda$</td><td>$\varphi(\lambda)$</td><td>$\frac{1}{\lambda}$</td><td>$\frac{\vert A \vert}{\lambda}$</td><td>$\lambda$</td></tr><tr><td align="left">特征向量</td><td>$\alpha$</td><td>$\alpha$</td><td>$\alpha$</td><td>$\alpha$</td><td>$p^{-1}\alpha$</td></tr></tbody></table></li><li><p>$A^T$ 与 $A$ 的特征值相同，但特征向量未必相同</p></li><li><p>幂等矩阵 $A$ （$A^2 = A$）特征值为 $0$ 或 $1$</p><p>  对合矩阵 $A$ （$A^2 = E$）特征值为 $-1$ 或 $1$</p><p>  幂零矩阵 $A$ （$A^2 = 0$）特征值为 $0$</p><p>  正交矩阵 $A$ （$AA^T = E$）特征值不一定为实数，但模长一定为 $1$ </p><p>  $n$ 阶实矩阵 $A$ 满足 $R(A) = n - 1$，特征值 $\lambda_1 = \sum_{i = 1}^na_{ii}$，$\lambda_2=\cdots=\lambda_n = 0$（其实就是方阵秩为 $n-1$ ，其伴随矩阵的特征值）</p></li></ul></li></ul><h3 id="S-5-3-方阵相似于对角矩阵的条件"><a href="#S-5-3-方阵相似于对角矩阵的条件" class="headerlink" title="$\S 5.3$ 方阵相似于对角矩阵的条件"></a>$\S 5.3$ 方阵相似于对角矩阵的条件</h3><ul><li><p>相似矩阵 $P^{-1}AP=B$</p><p>  相似变换，反身性，对称性，传递性</p><ul><li>$A\sim B$，则 $R(A) = R(B)$</li><li>$A\sim B$，则 $|A| = |B|$，即 $A,B$ 同时可逆或不可逆</li><li>$A\sim B$，则 $A^T \sim B^T$，更进一步，$f(A) \sim f(B)$</li><li>$A$ 可逆，$A\sim B$，则 $A^{-1} \sim B^{-1}$</li><li>$A\sim B$，则 $A$ 与 $B$ 特征多项式相同，<strong>从而 $A$ 与 $B$ 的特征值相同，但特征向量未必相同</strong>（BTW，特征多项式相同的矩阵未必相似）</li><li>$A$ 与对角矩阵相似，则对角矩阵上的元素是 $A$ 的 $n$ 个特征值</li></ul></li><li><p>$n$ 阶方阵 $A$ 可以相似对角化的充要条件是 $A$ 有 $n$ 个线性无关的特征向量</p></li><li><p>设 $\lambda_i$ 是方阵 $A$ 的 $n_i$ 重特征值，那么 $A$ 对应于 $\lambda_i$ 的特征向量中线性无关组的向量个数最多为 $n_i$ 个</p></li><li><p>$A$ 的全部特征向量的一个极大无关组，称为 $A$ 的一个特征向量系，其向量个数 $q=\sum_{i=1}^tm_i \le \sum_{t=1}^{t}n_i=n$，$q$ 为 $n$ 时，$A$ 的特征向量时完全的，否则是不完全的，值得注意的是，对于 $A$ 的任一单特征值 $\lambda_i$，必有 $m_i=n_i=1$（$n_i$ 表示第 $i$ 个特征根重数，$m_i$ 表示第 $i$ 个特征根对应方程解的个数）</p></li></ul><h3 id="S-5-4-正交矩阵"><a href="#S-5-4-正交矩阵" class="headerlink" title="$\S 5.4$ 正交矩阵"></a>$\S 5.4$ 正交矩阵</h3><ul><li>内积，向量长度，单位向量</li><li>正交向量组（对于只含一个向量 $a$ 的向量组，当 $a \ne 0$ 时，该向量组也是正交组）<ul><li>正交向量组也线性无关</li></ul></li><li>将一个全是单位向量的且两两正交的向量组称为单位正交向量组</li><li>$Schmidt$ 逐步正交化</li><li>正交矩阵（$AA^T = E$）<ul><li>$n$ 阶实矩阵 $A$ 为正交矩阵的充要条件是 $A$ 的行（列）向量都是两两正交的单位向量</li><li>若 $A$ 是正交矩阵，则 $|A| = 1$ 或 $|A| = -1$ </li><li>若 $A$，$B$ 均是正交矩阵，则 $AB$ 也是正交矩阵，但 $A+B$ 不是</li><li>若 $A$ 是正交矩阵，则 $A^*$，$A^{-k}$ ，$A^k$ 亦为正交矩阵</li><li>若 $A$ 是正交矩阵，且 $\lambda$ 是 $A$ 的特征值，则 $|\lambda| = 1$，且 $\frac{1}{\lambda}$ 也是 $A$ 的特征值</li></ul></li><li>设 $P$ 为正交矩阵， $y = Px$ 为正交变换，正交变换不改变模长</li></ul><h3 id="S-5-5-实对称矩阵的相似对角化"><a href="#S-5-5-实对称矩阵的相似对角化" class="headerlink" title="$\S 5.5$ 实对称矩阵的相似对角化"></a>$\S 5.5$ 实对称矩阵的相似对角化</h3><ul><li>实对称矩阵的特征值<strong>必为实数</strong></li><li>实对称阵 $A$  <strong>不同特征值对应的特征向量正交</strong>，且二者互为充要条件</li><li>实对称阵<strong>一定能相似对角化</strong></li><li>实对称矩阵<strong>非零特征值个数等于它的秩</strong></li><li>若$A$，$B$ 均为实对称阵，且 $A$ 和 $B$ 特征值完全相同，则必有 $A \sim B$</li></ul><h2 id="第六章-二次型与对称矩阵"><a href="#第六章-二次型与对称矩阵" class="headerlink" title="第六章 二次型与对称矩阵"></a>第六章 二次型与对称矩阵</h2><h3 id="S-6-1-二次型及其矩阵"><a href="#S-6-1-二次型及其矩阵" class="headerlink" title="$\S 6.1$ 二次型及其矩阵"></a>$\S 6.1$ 二次型及其矩阵</h3><ul><li><p>二次型，二次型矩阵，二次型的秩，线性变换（可逆变换，不可逆变换）</p></li><li><p>合同变换</p><p>  $P^TAP = B$，则 $A, B$ 合同，记为 $A \simeq B$，$P$ 为合同因子</p><p>  合同必等价，反之不真</p><p>  合同和相似是两个独立概念，合同未必相似，相似未必等价</p></li><li><p>相关结论</p><p>  对实对称矩阵 $A, B$ 若 $A \sim B$，则 $A \simeq B$，但是合同未必相似 如 $diag\{3,3,3\}$ 和 $E$ 合同，但不相似</p><p>  若对实对称矩阵$A, B$ 特征值相同，则 $A \simeq B$，且$A \sim B$</p><p>  若 $A \simeq B$，则 $R(A) = R(B)$</p><p>  若 $A \simeq B$，且 $A$ 为对称矩阵则 $B$ 也为对称矩阵（特殊的若 $A \simeq \Lambda$，则 $A$ 必为对称阵）</p></li></ul><h3 id="S-6-2-二次型的标准型"><a href="#S-6-2-二次型的标准型" class="headerlink" title="$\S 6.2$ 二次型的标准型"></a>$\S 6.2$ 二次型的标准型</h3><ul><li><p>标准型</p><p>  标准型各项系数均是特征值</p></li><li><p>正交变换法</p></li><li><p>拉格朗日配方法</p><p>  如果只有交叉项利用平方差公式凑出平方项</p></li><li><p>相关结论</p><p>  任何二次型必可经过可逆线性变换为标准型</p><p>  任何对称矩阵必可合同于对角矩阵</p></li></ul><h3 id="S-6-3-合同变换与二次型的规范形"><a href="#S-6-3-合同变换与二次型的规范形" class="headerlink" title="$\S 6.3$ 合同变换与二次型的规范形"></a>$\S 6.3$ 合同变换与二次型的规范形</h3><ul><li><p>合同变换法</p><p>  三种初等合同变换。</p><p>  合同变换法 $(A|E) \to (\Lambda|P^T)$。</p></li><li><p>实二次型的规范形</p><p>  任何实对称矩阵必可经过实数域上变换得到如下矩阵<br>  $$<br>  \begin{bmatrix}</p><pre><code>1&amp;  &amp;  &amp;  &amp;  &amp;  &amp;  &amp;  &amp; \\\&amp; \ddots  &amp;  &amp;  &amp;  &amp;  &amp;  &amp;  &amp; \\\&amp;  &amp; 1 &amp;  &amp;  &amp;  &amp;  &amp;  &amp; \\\&amp;  &amp;  &amp; -1 &amp;  &amp;  &amp;  &amp;  &amp; \\\&amp;  &amp;  &amp;  &amp; \ddots &amp;  &amp;  &amp;  &amp; \\\&amp;  &amp;  &amp;  &amp;  &amp; -1 &amp;  &amp;  &amp; \\\&amp;  &amp;  &amp;  &amp;  &amp;  &amp; 0 &amp;  &amp; \\\&amp;  &amp;  &amp;  &amp;  &amp;  &amp;  &amp; \ddots &amp; \\\&amp;  &amp;  &amp;  &amp;  &amp;  &amp;  &amp;  &amp;0</code></pre><p>  \end{bmatrix}<br>  $$</p></li></ul><pre><code>其中 $1$ 的个数 $p$ 称为正惯性指数，$-1$ 个数称为负惯性指数，$p-q$ 称为 $A$ 的符号差，正负惯性指数之和是 $A$ 的秩。两个 $n$ 阶实对称阵合同的充要条件是它们秩相同且正惯性指数也相同。特别地，若两个 $n$ 阶实对称阵的特征值相同，则它们必相似，从而必合同。</code></pre><h3 id="S-6-4-实二次型的分类-正定二次型"><a href="#S-6-4-实二次型的分类-正定二次型" class="headerlink" title="$\S 6.4$ 实二次型的分类 正定二次型"></a>$\S 6.4$ 实二次型的分类 正定二次型</h3><ul><li><p>实二次型的分类</p><p>  对于实二次型 $f(x) = x^TAx$，若对任何非零实向量 $x$ 都有 $f(x)$，则称 $f$ 为正定二次型。</p><p>  可逆线性变化不改变实二次型的正定性。</p></li><li><p>正定二次型与正定矩阵<br>  $n$ 元实二次型正定的充分必要条件是其标准形中 $n$ 个平方项的系数全大于零。<br>  实二次型 $f(x) = x^TAx$ 正定的充分必要条件是 $A$ 的特征值全大于零。<br>  $n$ 元实二次型 $f(x) = x^TAx$ 正定的充分必要条件是它的正惯性指数为 $n$。</p><p>  实二次型 $f(x) = x^TAx$ 正定的充分必要条件是 $A$ 的所有顺次主子式全大于零。</p><p>  对于实对称矩阵$A$，如果实二次$f(x)=x^TAx$ 正定，则称 $A$ 是正定矩阵。</p><p>  实对称矩阵 $A$ 正定的充分必要条件是 $A \simeq E$。</p><p>  实对称矩阵 $A$ 正定的充分必要条件是：有可逆 $P$，使得 $A=P^TP$。</p></li><li><p>正定矩阵的一些简单性质：</p><ol><li>若 $A$ 是正定矩阵，则 $A^T, A^{-1}, A^*, A^k,kA$（ $k$ 为任意正实数）均为正定矩阵。</li><li>若 $A$ 正定，则有 $|A|&gt;0$, 从而 $A$ 必可逆。</li><li>设 $A$ 与 $B$ 是正定矩阵，则 $AB$ 是正定矩阵的充要条件是 $A$ 和 $B$ 可交换。</li><li>设 $A、B$ 都是 $n$ 阶正定矩阵，则 $A+B$ 也是正定矩阵。</li><li>设 $A$ 是 $n$ 阶正定矩阵，则对 $\forall \alpha &gt; 0, |A + \alpha E| &gt; \alpha^n$。</li></ol></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 大学课程 </tag>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大学笔记 | 电路原理</title>
      <link href="/2023/06/05/Circuit-Analysis/"/>
      <url>/2023/06/05/Circuit-Analysis/</url>
      
        <content type="html"><![CDATA[<p>从入门到进门</p><span id="more"></span><h2 id="第一章-电路模型和电路定律"><a href="#第一章-电路模型和电路定律" class="headerlink" title="第一章 电路模型和电路定律"></a>第一章 电路模型和电路定律</h2><h4 id="第一章总结"><a href="#第一章总结" class="headerlink" title="第一章总结"></a>第一章总结</h4><ol><li>研究的电路都满足集总假设条件，默认电路都是集总电路</li><li>激励称为输入，响应称为输出</li><li>关联参考方向：电流与压降方向一致，非关联参考方向：电流与压降方向相反</li><li>支路，节点，回路，网孔，网络</li><li>KCL，KVL</li><li>电阻有负电阻</li><li>受控电压源（?CVS），受控电流源（?CCS）</li></ol><h2 id="第二章-直流电阻电路的等效变换分析"><a href="#第二章-直流电阻电路的等效变换分析" class="headerlink" title="第二章 直流电阻电路的等效变换分析"></a>第二章 直流电阻电路的等效变换分析</h2><h4 id="第二章总结"><a href="#第二章总结" class="headerlink" title="第二章总结"></a>第二章总结</h4><ol><li><p>电流源并联时叠加，串联时要求两个电流源相等且就是这两个电流源大小，电压源串联时叠加，并联要求电压源相等</p></li><li><p>单口网络等效变换</p><p> <img src="%E5%8D%95%E5%8F%A3%E7%BD%91%E7%BB%9C%E7%AD%89%E6%95%88%E5%8F%98%E6%8D%A2.png" alt="单口网络等效变换"></p></li><li><p>Y-Δ变换</p><p> <img src="Y-%CE%94%E5%8F%98%E6%8D%A21.png" alt="Y-Δ变换1"></p><p> <img src="Y-%CE%94%E5%8F%98%E6%8D%A22.png" alt="Y-Δ变换2"></p><p> <img src="Y-%CE%94%E5%8F%98%E6%8D%A23.png" alt="Y-Δ变换3"></p></li></ol><h2 id="第三章-直流电阻电路的一般分析"><a href="#第三章-直流电阻电路的一般分析" class="headerlink" title="第三章 直流电阻电路的一般分析"></a>第三章 直流电阻电路的一般分析</h2><h4 id="第三章总结"><a href="#第三章总结" class="headerlink" title="第三章总结"></a>第三章总结</h4><ol><li><p>网孔分析法 ：每个网孔各设一个电流，利用回路中总电压代数和为 $0$ 列方程，方程左右两边满足 <code>压升 = 压降</code> ，<strong>注意设的电流方向</strong> （本质是 KVL）</p></li><li><p>节点分析法（本质是 KCL）</p><p> <img src="%E8%8A%82%E7%82%B9%E5%88%86%E6%9E%90%E6%B3%95.png" alt="节点分析法"></p><p> 注意右式是以流<strong>进</strong>的电流为正，并且如果某一个支路上要是有电流源了，那么和这个电流源串联的电阻在算自感，互感时都可以忽略不计</p><p> 还要注意的是，如果网络含独立电压源，最好一段接地，另一端直接求出电压</p></li><li><p>回路分析法和网孔分析法本质一样，只是网孔是特殊的回路</p></li></ol><p>例题：</p><p><img src="%E4%BE%8B2.1.png" alt="例2.1"></p><blockquote><p>解：左图可以化简为右图，易得 $I = \frac{2}{3}$</p></blockquote><h2 id="第四章-电路定理"><a href="#第四章-电路定理" class="headerlink" title="第四章 电路定理"></a>第四章 电路定理</h2><h4 id="第四章总结"><a href="#第四章总结" class="headerlink" title="第四章总结"></a>第四章总结</h4><ol><li><p>叠加定理和齐次定理只对线性电路适用</p></li><li><p>注意的是叠加定理每次都是只考虑一个<strong>独立源</strong>，受控源每次都是放在电路中的</p></li><li><p>置换定理：利用电压源 / 电流源替换（例题1， 2）</p></li><li><p>戴维南定理：单口网络可以等效为电压源串电阻，电压源大小为开路电压，电阻为独立源置0后的阻值（注意受控源有阻值） </p></li><li><p>诺顿定理：单口网络等效为电流源（大小为短路电流）并电阻，与戴维南类似（是戴维南定理的对偶形式）</p></li><li><p>求输出电阻常用的方法有：等效电阻法（这里是从端口方向看的），外加电压法（独立源要置0），开短路法（注意后面两个方法适合含受控源的情况）</p></li><li><p>$R_L = R_0$ 时满足最大功率条件，$\eta = \frac{负载产生功率}{总产生功率}$ 注意多个电源存在时有的电源会吸收功率，这个功率不能算在分母里，分母中只能算产生功率，而且算 $\eta$ 时要带回原电路来算，不能盲目认为 $R_L$ 和端口等效电阻相等就认为 $\eta$ 是 $50\%$</p></li></ol><p>例题：</p><p><img src="%E4%BE%8B3.1.png" alt="例3.1"></p><p><img src="%E4%BE%8B3.2.png" alt="例3.2"></p><blockquote><p>当我们知道某支路上的电流 / 电压时，我们可以用<strong>电压源 / 电流源来替换该支路上的其他元件</strong>，这样的话并不改变整个电路结构，研究某一复杂电路时，我们要清楚自己到底想求什么，然后对于<strong>和电流源串联的元件，思考能否舍弃，和电压源并联的元件，思考能否舍弃</strong></p></blockquote><h2 id="第五章-一阶直流动态电路时域分析"><a href="#第五章-一阶直流动态电路时域分析" class="headerlink" title="第五章 一阶直流动态电路时域分析"></a>第五章 一阶直流动态电路时域分析</h2><h4 id="第五章总结"><a href="#第五章总结" class="headerlink" title="第五章总结"></a>第五章总结</h4><ol><li><p>动态元件：元件的伏安关系包含对电流电压的微分 / 积分</p><p> 动态电路：至少含有一个动态元件，含有几个动态元件就称为几阶动态电路</p></li><li><p>电容，电感</p><p> <img src="%E7%94%B5%E5%AE%B9%EF%BC%8C%E7%94%B5%E6%84%9F%E5%85%B3%E7%B3%BB.png" alt="电容，电感关系"></p></li><li><p>完全响应 = 零输入响应 + 零状态响应</p><p> = 固有响应 + 强迫响应</p><p> = 暂态响应 + 稳态响应</p><p> 其实暂态可以粗浅理解为 $e^{-kt}$ 的量</p><p> <img src="%E5%87%A0%E4%B8%AA%E6%A6%82%E5%BF%B5.png" alt="几个概念"></p></li><li><p>$f(t) = f(\infty) + [f(0_+) - f(\infty)]e^{\frac{t}{\tau}}$</p></li></ol><h3 id="S-5-1-一阶电路的零输入响应-amp-零状态响应"><a href="#S-5-1-一阶电路的零输入响应-amp-零状态响应" class="headerlink" title="$\S 5.1$ 一阶电路的零输入响应 &amp; 零状态响应"></a>$\S 5.1$ 一阶电路的零输入响应 &amp; 零状态响应</h3><ul><li>换路定则</li></ul><p>​        换路前后电容电流和电感电压为有限制的情况下， 换路前后瞬间电容电压和电感电流不能跃变。 </p><p>​        该定则常用来判断 $i_L(0_+)与i_L(0_-),u_C(0_+)与u_C(0_-)$ 是否相等</p><ul><li><p>零输入响应公式形式</p><p>  对于电容：$u_c = U_0e^{-\frac{t}{\tau}}, \tau = RC$</p><p>  对于电感：$i_l = I_0e^{-\frac{t}{\tau}}, \tau = \frac{L}{R}$</p></li></ul><p>​        这里电感可以看作是一个电压源，而电容可以看作是一个电流源，<strong>然后这里的 $R$ 是指换路后电路的总电阻值</strong></p><ul><li><p>零状态响应公式</p><p>  对于电容：$u_c = U_{\infty}(1 - e^{-\frac{t}{\tau}}), \tau = RC$</p><p>  对于电感：$i_l = I_{\infty}(1 - e^{-\frac{t}{\tau}}), \tau = \frac{L}{R}$</p></li></ul><h3 id="S-5-2-一阶电路的全响应"><a href="#S-5-2-一阶电路的全响应" class="headerlink" title="$\S 5.2$ 一阶电路的全响应"></a>$\S 5.2$ 一阶电路的全响应</h3><ul><li><p>全响应公式形式</p><p>  对于电容：$u_c = U_0e^{-\frac{t}{\tau}} + U_{\infty}(1 - e^{-\frac{t}{\tau}}), \tau = RC$</p><p>  对于电感：$i_l = I_0e^{-\frac{t}{\tau}} + I_{\infty}(1 - e^{-\frac{t}{\tau}}), \tau = \frac{L}{R}$</p><p>  全响应时的电容电压即零状态时的电容电压加上零响应时的电容电压， 电感电源同理</p><p>  值得注意的是，这里的电阻 $R$ 是<strong>除去储能元件</strong>以及将激励源置零所得到的</p><p>  <strong>可以写作 $f(t) = f(\infty) + [f(0_+) - f(\infty)]e^{\frac{t}{\tau}}$， 这便是三要素法</strong></p><p>  <strong>一阶线性直流电路</strong>中的电感电容<strong>电阻</strong>， 均适用三要素法</p></li></ul><p><img src="%E6%8D%A2%E8%B7%AF%E5%AE%9A%E5%88%99.png" alt="换路定则"></p><p><strong>注意一下换路定理不能盲目用</strong></p><p><img src="%E7%89%B9%E4%BE%8B.png" alt="特例"></p><h3 id="S-5-3-一阶电路的跃阶响应"><a href="#S-5-3-一阶电路的跃阶响应" class="headerlink" title="$\S 5.3$ 一阶电路的跃阶响应"></a>$\S 5.3$ 一阶电路的跃阶响应</h3><ul><li><p>单位跃阶函数时一种奇异函数， 定义 $\varepsilon(t) = \begin{cases} 0 &amp;&amp; t &lt; 0\\ 1 &amp;&amp; t &gt; 0\end{cases}$</p></li><li><p>电路的单位跃阶响应为 $s(t) = (1 - e^{-\frac{t}{\tau}})\varepsilon(t)$ </p></li><li><p>其实可以先求出电压为 $1V$ 时的响应函数，然后用阶跃函数表示电压函数，最后真正响应函数的零状态响应就是阶跃函数 $\times (1 - e^{-\frac{t}{\tau}})$ 然后再加上零输入响应就是完全响应</p></li></ul><p><img src="%E4%BE%8B5.1.jpg" alt="例5.1"></p><p>（有坑）</p><p><img src="%E4%BE%8B5.2.png" alt="例5.2"></p><blockquote><p>首先从状态量入手，算 $0_-$ 时候的<strong>状态量</strong>，研究 $0_+$ 状态时可以把电容变为电压源，电感变为电流源，然后用三要素法分析。但是这题有个坑。无论是状态量还是非状态量，分解成暂态响应和固态响应时都可以直接按 <code>常数</code> + <code>按e指数衰减部分</code> ，但是分解成零输入和零状态时，状态量比较好分解就按照一般方法来，非状态量不可以按照状态量的方法，要列关于 i / u 的方程，然后把 i / u 转化为零输入 / 零状态时的量来求 </p></blockquote><p><img src="%E4%BE%8B5.3.png" alt="例5.3"></p><blockquote><p>分成 $0 &lt; t &lt; 1$ 和 $1 &lt; t$ 区间来处理</p><p>$$t = \begin{cases} 2(1 - e^{-t}) \ , 0 \le t \le 1&amp; \\\ 1 + (1 - 2e^{-1})e^{-2(t - 1)} \ ,t \ge 1 &amp; \end{cases}$$</p></blockquote><p><img src="%E4%BE%8B5.4.png" alt="例5.4"></p><blockquote><p>$$<br>u_s(t) = \varepsilon(t) + 2\varepsilon(t - 1) - 3\varepsilon(t - 3)\<br>t = \begin{cases} 20e^{-\frac{t}{\tau}} + (1 - e^{-\frac{t}{\tau}}) \ , 0 \le t \le 1&amp; \\ 20e^{-\frac{t}{\tau}} + (1 - e^{-\frac{t}{\tau}}) + 2(1 - e^{-\frac{t - 1}{\tau}}) \ ,1 \le t \le 3 &amp; \\ 20e^{-\frac{t}{\tau}} + (1 - e^{-\frac{t}{\tau}}) + 2(1 - e^{-\frac{t - 1}{\tau}}) - 3(1 - e^{-\frac{t - 3}{\tau}}) \ ,t \ge 3\end{cases}<br>$$</p></blockquote><h2 id="第六章-相量法"><a href="#第六章-相量法" class="headerlink" title="第六章 相量法"></a>第六章 相量法</h2><h4 id="第六章总结"><a href="#第六章总结" class="headerlink" title="第六章总结"></a>第六章总结</h4><ol><li><p>我们要建立概念就是复数，三角函数，$e$ 指数之间是可以相互转化的，所以往往可以把他们看作等价的，<strong>都可以表示二维平面上的向量</strong></p></li><li><p>算相量加减法时转化为复数形式，算相量乘除法时转化为 $e$ 指数形式</p></li><li><p>三角函数转化为相量时，除非特殊说明，不然默认相量前面的都是有效值，即峰值的 $\frac{1}{\sqrt 2}$</p></li><li><p>对于相量而言，我们在计算上时可以把它看作和相量相同计算，<strong>但是相量不是向量，向量是真实存在物理量，相量不真实存在，是表示正弦信号的工具</strong></p></li><li><p>当电源电流是三角函数形式，即不断变化时要用相量来表示，$U$ 和 $I$ 上要记得打点，相量是可以用来表征正弦波的，<strong>但不等同</strong></p></li><li><p>对于接下来的正弦稳态电路和之前学的电路<strong>没什么不同</strong>，区别就是电流电压用相量表示，并且电感电容都可以用阻抗来表示，$Z_C= -j\frac{1}{\omega C},Z_L = jL\omega $</p></li></ol><ul><li><p>复数<br>  $$<br>  F = a + jb\<br>  F = |F|(cos\theta + jsin\theta)\<br>  F = |F|e^{j\theta}\<br>  \theta = arg \ F = arctan(\frac{b}{a})\<br>  Re[F] = a\<br>  lm[F] = b\<br>  F^* = a - jb = |F|\angle-\theta<br>  $$<br>  复数加减用代数形式，乘除用指数形式</p></li><li><p>正弦量</p><p>  按正弦规律变化的电流，电压称为正弦量。由振幅（正数），角速度，初相位三要素决定</p><p>  按国家统一标准用cos表示正弦量</p><p>  相量和正弦量不相等，写的时候注意区分</p><p>  峰峰值是振幅的两倍，有效值也称为均方根值</p><p>  化成相量形式时前面的系数是有效值大小，化成正弦量时前面的系数是峰值大小</p></li><li><p>电路定理的相量形式</p><p>  $\omega L$ 感抗  $-\frac{1}{\omega L}$ 感纳   $-\frac{1}{c\omega}$ 容抗  $\omega C$ 容纳   </p><p>  将一般的电路定理全部改成相量形式</p></li></ul><h2 id="第七章-正弦稳态电路的分析"><a href="#第七章-正弦稳态电路的分析" class="headerlink" title="第七章 正弦稳态电路的分析"></a>第七章 正弦稳态电路的分析</h2><h4 id="第七章总结"><a href="#第七章总结" class="headerlink" title="第七章总结"></a>第七章总结</h4><ol><li><p>$|Z| = \frac{U}{I},Z = R + jX,\theta_z = \varphi_u - \varphi_i$ </p><p> $|Z|$ 称为阻抗模，$R$称为等效电阻分量，$X$称为等效电抗分量（$X &gt; 0,\theta_z &gt; 0$ 时称 $Z$ 为感性阻抗，$X&lt;0,\theta_z &lt; 0$ 时称为 $Z$ 容性阻抗）</p></li><li><p>$Y = \frac{I}{U} = G + jB$</p></li><li><p>有功功率 $P$，无功功率 $Q$，视在功率 $S$</p></li><li><p>功率因素 $\lambda = \frac{P}{S}$ 要记得标上电流 超前 / 滞后 电压，往往都是电流 滞后 电压，所以要通过串 / 并联电容来实现</p></li><li><p>最大传递功率：一种是 $R_L$ 任意可调，只需让虚部是 $R_0$ 虚部相反数，实部和 $R_0$ 实部相等。另一种是 $R_L$ 有限制，不能直接满足第一种条件，应该是 $R_L$ 和 $R_0$ 模长相等</p></li></ol><h2 id="第八章-含有耦合电感的电路"><a href="#第八章-含有耦合电感的电路" class="headerlink" title="第八章 含有耦合电感的电路"></a>第八章 含有耦合电感的电路</h2><h4 id="第八章总结"><a href="#第八章总结" class="headerlink" title="第八章总结"></a>第八章总结</h4><ol><li>$u = L\frac{di_1}{dt} + M\frac{di_2}{dt}$ ，并且知道如何判断同名端，如何判断电压电流正负</li><li>$k = \frac{M}{\sqrt {L_1 L_2}}$</li><li>判断等效受控源正负方向：假设电流从一个线圈打点端方向流入，则假设对于另一个线圈支路上的的受控电压源而言，该受控电压源和这条支路上的线圈打点端同向</li><li>遇到复杂，难以处理的电路，优先考虑化为理想线圈加受控源的形式（$\S 8.2$ 方法一）</li><li>记住串联线圈化简的公式和 $T$ 型等效公式</li><li>知道耦合系数是什么并且知道临界状况</li><li>知道反映阻抗法并能灵活运用于戴维南等效电路中</li><li><strong>什么都不知道时一定要会通过理想线圈加受控源的方法转化电路分析</strong></li></ol><h3 id="S-8-1-耦合电感的伏安关系"><a href="#S-8-1-耦合电感的伏安关系" class="headerlink" title="$\S 8.1$ 耦合电感的伏安关系"></a>$\S 8.1$ 耦合电感的伏安关系</h3><ul><li>耦合元件：由一跳以上支路组成，一支路的电压，电流与其他支路的电压，电流直接相关</li><li>在本章学习中，我们大多研究的耦合元件是线圈，线圈在通了电流之后会产生磁，而磁又会生电，从而产生电压，所以对于一个线圈上的电压，往往是由两部分组成，一个是它自身产生的电压，另一个是和它耦合的线圈的电压，自身电流和电磁之间比例系数是自感 $L$，和耦合元件之间是互感 $M$，但是我们有时也能见到 $L_{12}$，这种表示 $2$ 线圈在 $1$ 上的互感系数</li></ul><p><img src="%E8%80%A6%E5%90%88%E7%94%B5%E6%84%9F%E4%BC%8F%E5%AE%89%E5%85%B3%E7%B3%BB.png" alt="耦合电感伏安关系"></p><ul><li>同名端：当电流沿着不同线圈的两个端点流入，若产生的磁通方向相同，则这两个端点称为同名端，往往题目会直接告诉，若两个耦合线圈电流沿着同名端通入，互感 $ML &gt; 0$，反之 $ML &lt; 0$，或者可以理解为 $I_1$ 在线圈 $1$ 打点端通入，那么互感 $M$ 产生的电压 $+$ 极也在线圈 $2$ 打点端</li></ul><h3 id="S-8-2-耦合电感的去耦等效模型"><a href="#S-8-2-耦合电感的去耦等效模型" class="headerlink" title="$\S 8.2$ 耦合电感的去耦等效模型"></a>$\S 8.2$ 耦合电感的去耦等效模型</h3><ul><li>利用受控源来等效：我们可以将线圈 $L$ 转化为纯线圈（不考虑互感）和受控电压源（最本源的方法，当你分析不出来或不太好处理时，都可以这样转化）<ul><li>下图是电流沿着同名端流入时，受控源正负<strong>均</strong>与电流方向一致</li><li>当沿着异名端流入时，受控源正负<strong>均</strong>与电流方向相反</li></ul></li></ul><p><img src="%E5%8E%BB%E8%80%A6%E7%AD%89%E6%95%88%E7%BA%BF%E5%9C%88.png" alt="去耦等效线圈"></p><ul><li><p>耦合电路的串联</p><p>  当两个电感串联且电流沿着同名端流过（此时异名端相连），则可以等效为一个新电感 $L’ = L_1 + L_2 + 2M$</p><p>  <img src="%E7%BA%BF%E5%9C%88%E4%B8%B2%E8%81%94.png" alt="线圈串联"></p><p>  同理若电感串联但电流沿着异名端流过（同名端相连)，那么可以等效为一个新电感 $L’ = L_1 + L_2 - 2M$</p></li><li><p>耦合电路的并联</p><p>  当线圈并联且异名端相连时，可以等效为一个新线圈 $L’ = \frac{L_1L_2 - M^2}{L_1 + L_2 + 2M}$（能记住最好，也可以不记住，用T型等效去推，比较推荐（之后会介绍））</p><p>  当线圈并联且同名端相连时，可以等效为 $L’ = \frac{L_1L_2 - M^2}{L_1 + L_2 - 2M}$</p><p>  <img src="%E7%BA%BF%E5%9C%88%E5%B9%B6%E8%81%94.png" alt="线圈并联"></p></li><li><p>耦合系数</p><p>  我们都知道 $L$ 是大于 $0$ 的，所以在上述串联并联公式中，我们不难发现 $M$ 是要满足一定条件的，这里我们引入耦合系数 $k$ 来表示 $M$ 和 $L$ 之间的关系</p><p>  <img src="%E8%80%A6%E5%90%88%E7%B3%BB%E6%95%B0.png" alt="耦合系数"></p></li><li><p>常见的等效方法</p><ul><li><p>$T$ 型等效</p><p>  <img src="T%E5%9E%8B%E7%AD%89%E6%95%881.png" alt="T型等效1"></p><p>  <img src="T%E5%9E%8B%E7%AD%89%E6%95%882.png" alt="T型等效2"></p><p>  $T$ 型等效在处理并联等问题上十分有效</p><p>  $e.g\ 8.1$</p><p>  <img src="%E4%BE%8B8.1.png" alt="例8.1"></p><blockquote><p> 值得一提的是，这里之所以可以把两个线圈下端相连是因为只连一端不影响回路</p></blockquote><h3 id="S-8-3-空心变压器电路的分析"><a href="#S-8-3-空心变压器电路的分析" class="headerlink" title="$\S 8.3$ 空心变压器电路的分析"></a>$\S 8.3$ 空心变压器电路的分析</h3></li></ul></li><li><p>互感化除法</p><p>  是不是很眼熟，嗯互感化除法其实就是 $T$ 型等效法的一个应用，这两个没什么区别qwq</p><p>  <img src="%E4%BA%92%E6%84%9F%E5%8C%96%E9%99%A4%E6%B3%95.png" alt="互感化除法"></p></li><li><p>回路分析法</p><p>  其实没有用到任何化简，就是我们遇到一个新电路时的常见思路，把线圈变为理想线圈和受控源再分析，这个回路分析法是为接下来的简化方法服务的</p><p>  <img src="%E5%9B%9E%E8%B7%AF%E5%88%86%E6%9E%90%E6%B3%95.png" alt="回路分析法"></p></li><li><p>反映阻抗法</p><p>  仔细观察上一个化简的结果，我们发现初级电路和次级电路可以等效为一个新电路</p><p>  我们设 $Z_{11},Z_{22}$ 为初级电路和次级电路的视在阻值，视在阻值就是不考虑线圈的互感作用，直接计算出的电路的阻值</p><p>  那么初级线圈对新电路的贡献阻值为 $Z_1’ = Z_{11}$ 嗯就是它本身非常好记</p><p>  次级线圈对新电路的贡献阻值为 $Z_2’ = \frac{(\omega M)^2}{Z_{22}}$ 这个结果看起来很真，说明 $M$ 和 $Z_{22}$ 都会对新电路有影响，这个结果也被称为反映阻抗，不难看出其实反映阻抗和同名端位置无关</p><p>  <img src="%E5%8F%8D%E6%98%A0%E9%98%BB%E6%8A%97%E6%B3%95.png" alt="反映阻抗法"></p><p>  <img src="%E5%8F%8D%E6%98%A0%E7%94%B5%E9%98%BB2.png" alt="反映电阻2"></p><p>  所以化简的新电路如上，笔者推荐记住这个结果，比较方便</p><p>  但是记住这种方法要求次级回路中无独立源</p></li><li><p>戴维南等效法</p><p>  有了上述反映阻抗法的铺垫，我们可以利用戴维南等效法，从次级回路的两个端口看去，将其转化为一个新电路，这个新电路的阻值就按反映阻抗法的方法去求，只不过从次级回路来看的话，其实原先的次级回路相当于现在的初级回路，原先的初级回路相当于现在的次级回路</p><p>  但还有一个问题，开路电压 $U_{OC}$ 怎么求，其实也很简单，我们原先不是假设次级线圈是一个理想线圈和受控源吗，这个$U_{OC}$ 就是受控源的电压值，也非常好理解，故 $U_{OC} = j\omega M I_1 = j\omega M \frac{U_s}{Z_{11}}$， $U_{OC}$正负要看具体端口正负以及同名异名情况</p><p>  <img src="%E6%88%B4%E7%BB%B4%E5%8D%97%E7%AD%89%E6%95%88%E6%B3%95.png" alt="戴维南等效法"></p></li></ul><h3 id="S-8-4-理想变压器电路的分析"><a href="#S-8-4-理想变压器电路的分析" class="headerlink" title="$\S 8.4$ 理想变压器电路的分析"></a>$\S 8.4$ 理想变压器电路的分析</h3><p>与先前的耦合线圈不同，理想变压器虽然长得和耦合线圈一样，但是不考虑 $L$ 和 $M$</p><p><img src="%E7%90%86%E6%83%B3%E5%8F%98%E5%8E%8B%E5%99%A8%E7%94%B5%E5%8E%8B%E7%94%B5%E6%B5%81%E5%85%B3%E7%B3%BB.png" alt="理想变压器电压电流关系"></p><p><img src="%E7%90%86%E6%83%B3%E5%8F%98%E5%8E%8B%E5%99%A8%E5%8F%98%E6%8D%A2%E5%85%B3%E7%B3%BB.png" alt="理想变压器变换关系"></p><p><img src="%E4%BE%8B8.2.png" alt="例8.2"></p><p><img src="%E4%BE%8B8.3.png" alt="例8.3"></p><p><img src="%E4%BE%8B8.4.png" alt="例8.4"></p><p><img src="%E4%BE%8B8.5.png" alt="例8.5"></p><h2 id="第九章-三相电路"><a href="#第九章-三相电路" class="headerlink" title="第九章 三相电路"></a>第九章 三相电路</h2><h4 id="第九章总结"><a href="#第九章总结" class="headerlink" title="第九章总结"></a>第九章总结</h4><ol><li><p>$I_a, I_b, I_c$ 是相电流，$I_{ab}, I_{ac}, I_{bc}$ 是线电流</p></li><li><p>$Y$ 型联接中，$U_{ab} = \sqrt 3 U_{a}\angle 30°,I_a = I_{ab}$ </p></li><li><p>$\Delta$ 型联接中，$U_a = U_{ab},I_a = \sqrt 3I_{ab}\angle -30°$ </p></li><li><p>做题时，应将负载和电源都变为 $Y$ 型联接，求出线电流，相电流之后再利用 $2$，$3$ 中的关系来替换</p></li><li><p>$Y$型 和 $\Delta$ 型变换往往利用的是 线电压 / 线电流 不变</p></li><li><p>$Y$ 型电路 $U$ 超前 $I$ 一个$\phi$ 角，这个角是其中一个电阻的辐角</p></li><li><p>$P_总 = 3P_相 = \sqrt 3 P_线$</p></li></ol><h3 id="S-9-1-三相电路"><a href="#S-9-1-三相电路" class="headerlink" title="$\S 9.1$ 三相电路"></a>$\S 9.1$ 三相电路</h3><ul><li><p>三个电压电流分别相差 $120°$ 的相位</p><p>  根据转子转向，三相电路有正负相序之分，一般没说明时默认正序（$B$ 滞后 $A$ $120°$）</p><p>  相比于单相发电机，三相发电机输出功率高，经济好，性能好，易于制造</p></li></ul><p><img src="%E4%B8%89%E7%9B%B8%E4%BA%A4%E6%B5%81%E7%94%B5%E5%8E%8B.png" alt="三相交流电压"></p><ul><li><p>三相电源的联结</p><ul><li><p>$Y$ 型链接</p><p>  $U_a, U_b, U_c$ 是线电压， $U_{ab}, U_{ac}, U_{bc}$ 是项电压</p><p>  利用相量图来理解</p><p>  <img src="Y%E5%9E%8B%E9%93%BE%E6%8E%A5.png" alt="Y型链接"></p></li><li><p>$\Delta$ 形联接</p><p>  电路接反时会很危险，会先接上电压表来判断</p><p>  <img src="%E4%B8%89%E8%A7%92%E9%93%BE%E6%8E%A5.png" alt="三角链接"></p></li></ul></li><li><p>对称三相电路分析</p><ul><li><p>$Y-Y$ 联接</p><p>  通过节点电压法可得 $U_{nn’} = 0$</p><p><img src="YY%E8%81%94%E6%8E%A5.png" alt="YY联接"></p></li><li><p>$\Delta - ?$ 联接</p><p><img src="%E4%B8%89%E8%A7%92-%EF%BC%9F%E8%81%94%E6%8E%A5.png" alt="三角-？联接"></p></li></ul></li></ul><h3 id="S-9-2-对称三相电路的计算"><a href="#S-9-2-对称三相电路的计算" class="headerlink" title="$\S 9.2$ 对称三相电路的计算"></a>$\S 9.2$ 对称三相电路的计算</h3><h3 id="S-9-3-三相电路的功率"><a href="#S-9-3-三相电路的功率" class="headerlink" title="$\S 9.3$ 三相电路的功率"></a>$\S 9.3$ 三相电路的功率</h3><p>二表法适合测对称三相负载的功率，表的示数单独拿出来没有意义，要结合在一起看，而且一定要对称时才可以计算</p><p><img src="%E4%BA%8C%E8%A1%A8%E6%B3%95.png" alt="二表法"></p><p><img src="%E5%AF%B9%E7%A7%B0%E4%B8%89%E7%9B%B8%E8%B4%9F%E8%BD%BD%E5%8A%9F%E7%8E%87.png" alt="对称三相负载功率"></p><p><img src="%E6%B3%A8%E6%84%8F.png" alt="注意"></p><p>$e.g\ 9.1$</p><p><img src="%E4%BE%8B9.1.png" alt="例9.1"></p><blockquote><p>$$</p><p>$$</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 电路 </tag>
            
            <tag> 大学课程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大学笔记 | 微积分</title>
      <link href="/2023/06/05/Calculus/"/>
      <url>/2023/06/05/Calculus/</url>
      
        <content type="html"><![CDATA[<p>从入门到挂科 🤦‍♀️🤦‍♂️</p><span id="more"></span><h2 id="第一章-多元函数的极限和连续性"><a href="#第一章-多元函数的极限和连续性" class="headerlink" title="第一章 多元函数的极限和连续性"></a>第一章 多元函数的极限和连续性</h2><h4 id="第一章总结"><a href="#第一章总结" class="headerlink" title="第一章总结"></a>第一章总结</h4><ol><li>算多元函数极限时往往不能用洛必达，可以用一元函数求极限方法对原函数进行变换然后再求，或者也可以变换为一元函数后再用洛必达</li><li>算极限不存在时，选择不同路径求出不同极限然后可以证出来</li></ol><h2 id="第二章-多元函数的微分学及其应用"><a href="#第二章-多元函数的微分学及其应用" class="headerlink" title="第二章 多元函数的微分学及其应用"></a>第二章 多元函数的微分学及其应用</h2><h4 id="第二章总结"><a href="#第二章总结" class="headerlink" title="第二章总结"></a>第二章总结</h4><ol><li><p>可偏导不一定连续，连续不一定可偏导</p><p> 可微可推出函数连续且可偏导，但推不出偏导数连续（即可偏导不能确定偏导连续）</p><p> 可偏导且偏导连续才可以推出可微</p><p> 任何方向的方向倒数均存在也未必可偏导</p><p> 可微不是方向导数存在的必要条件，但是是其存在的充分条件</p></li><li><p>证明可微即证 $\frac{\Delta Z - F_X\Delta X - F_Y\Delta Y}{\sqrt{(\Delta X)^2 + (\Delta Y)^2}}$ 是否趋向于 $0$</p><p> 证明连续就是证左右极限相等且存在，证明偏导数存在就是证明函数关于每个变量的偏导数均存在</p></li><li><p>复合函数求导法则</p></li><li><p>隐函数求导 $\frac{\partial z}{\partial x} = - \frac{F’_x(x, y, z)}{F’_z(x, y)}$</p></li><li><p>方向导数 $\frac{\partial f}{\partial l} = \frac{\partial f}{\partial x}cos \alpha + \frac{\partial f}{\partial y}cos \beta$，梯度 $grad\ f(x, y) = \frac{\partial f}{\partial x}i + \frac{\partial f}{\partial y}j$，且二者关系 $\frac{\partial f}{\partial l} | _{max} = |grad\ f(x, y)| = \sqrt{(\frac{\partial f}{\partial x})^2 + (\frac{\partial f}{\partial y})^2}$</p></li><li><p>空间曲线的切线和法平面，曲面的切平面和法线</p></li><li><p>二元函数取得极值的充分，必要条件 和 条件极值</p></li><li><p>拉格朗日乘数法</p></li></ol><h2 id="第三章-重积分"><a href="#第三章-重积分" class="headerlink" title="第三章 重积分"></a>第三章 重积分</h2><h4 id="第三章总结"><a href="#第三章总结" class="headerlink" title="第三章总结"></a>第三章总结</h4><ol><li><p>二重积分：直角坐标系下分别积分即可，若利用极坐标，$dxdy = rdrd\theta$</p></li><li><p>三重积分：先一后二 / 先二后一     </p><p> ​                    利用柱面坐标：$dxdydz = r\ d\theta drdz$</p><p> ​                    利用球面坐标：$dxdydz = r^2sin\phi\ d\theta d\phi dr$</p></li></ol><h2 id="第四章-第一型曲线积分与曲面积分"><a href="#第四章-第一型曲线积分与曲面积分" class="headerlink" title="第四章 第一型曲线积分与曲面积分"></a>第四章 第一型曲线积分与曲面积分</h2><h4 id="第四章总结"><a href="#第四章总结" class="headerlink" title="第四章总结"></a>第四章总结</h4><ol><li><p>$\int_Lf(x, y)ds = \int_\alpha^\beta f(x(t), y(t))\sqrt{[x’(t)]^2 + [y’(t)]^2}dt$</p></li><li><p>$\int_Lf(x, y)ds = \int_a^b f(x, y(x))\sqrt{1 + [y’(x)]^2}dx$</p></li><li><p>$\int_Lf(x, y)ds = \int_\alpha^\beta f(r(\theta)cos\theta, r(\theta)sin\theta)\sqrt{r^2(\theta) + [r’(\theta)]^2}d\theta$</p></li><li><p>$\iint_\Sigma f(x, y, z)ds = \iint_{D_{xy}} f(x, y, z(x, y))\sqrt{1 + {z’_x}^2 + {z’_y}^2}dxdy$</p></li></ol><h2 id="第五章-第二型曲线积分和曲面积分"><a href="#第五章-第二型曲线积分和曲面积分" class="headerlink" title="第五章 第二型曲线积分和曲面积分"></a>第五章 第二型曲线积分和曲面积分</h2><h3 id="S-5-1-第二型曲线积分"><a href="#S-5-1-第二型曲线积分" class="headerlink" title="$\S 5.1$ 第二型曲线积分"></a>$\S 5.1$ 第二型曲线积分</h3><ul><li><p>概念 </p><p>  形如 $\int_LP(x, y)dx + Q(x, y)dy$ 的积分（注意第二型曲线是有方向的）</p></li><li><p>计算</p><p>  $\int_LP(x, y)dx + Q(x, y)dy = \int_L[P(x(t), y(y))x’(t)+Q(x(t), y(t))y’(t)]dt$</p><p>  第一二型曲线的关系 $\int_LP(x, y)dx + Q(x, y)dy = \int_L(Pcos\alpha + Qcos\beta)ds $</p></li></ul><h3 id="S-5-2-格林公式"><a href="#S-5-2-格林公式" class="headerlink" title="$\S 5.2$ 格林公式"></a>$\S 5.2$ 格林公式</h3><ul><li><p>单连通域与复连通域（没洞和有洞的区别）</p></li><li><p>区域的正向边界</p><p>  外边界顺时针为正向，内边界逆时针为正向（若沿着边界正向方向走，则该边界始终在此人左侧）</p></li><li><p>格林公式</p><p>  $\oint_LPdx + Qdy = \iint_D(\frac{\partial Q}{\partial x} - \frac{\partial P}{\partial y})dxdy$ （仅针对 $D$ 既是 $X$ 型域又是 $Y$ 型域）</p><p>  特殊的，利用格林公式算面积 $\iint_Ddxdy = \frac{1}{2}\oint_Lxdy - ydx$</p></li><li><p>路径无关</p><p>  若 $G$ 是一个单连通域且 $\frac{\partial Q}{\partial x} = \frac{\partial P}{\partial y}$ 在 $G$ 内恒成立（充要条件），则路径无关</p></li><li><p>全微分求原函数</p><p>  若 $\frac{\partial Q}{\partial x} = \frac{\partial P}{\partial y}$ 在单连通域 $G$ 内恒成立， 则存在 $du = Pdx + Qdy$</p><p>  $u(x, y) = \int_{(x_0, y_0)}^{(x, y)}P(x, y)dx + Q(x, y)dy$</p></li></ul><h3 id="S-5-3-第二型曲面积分"><a href="#S-5-3-第二型曲面积分" class="headerlink" title="$\S 5.3$ 第二型曲面积分"></a>$\S 5.3$ 第二型曲面积分</h3><ul><li><p>本节讨论均是光滑有向双侧曲面</p></li><li><p>概念</p><p>  形如 $\iint_{\sum}P(x, y, z)dydz + Q(x, y, z)dzdx + R(x, y, z)dxdy$</p></li><li><p>计算</p><ol><li><p>$\iint_{\sum}R(x, y, z)dxdy = \pm\iint_{D_{xy}}R(x, y, z(x, y))dxdy$</p></li><li><p>$\iint_{\sum}Pdydz + Qdzdx + Rdxdy = \iint_{\sum}[P(-z_x) + Q(-z_y) + R]dxdy$</p></li><li><p>$\unicode{8751}_\sum Pdydz + Qdzdx + Rdxdy = \iiint_\Omega(\frac{\partial P}{\partial x} + \frac{\partial Q}{\partial y} + \frac{\partial R}{\partial z})dV$</p></li></ol></li></ul><h3 id="S-5-4-高斯公式"><a href="#S-5-4-高斯公式" class="headerlink" title="$\S 5.4$ 高斯公式"></a>$\S 5.4$ 高斯公式</h3><ul><li><p>高斯公式</p><p>  设 $\sum$ 是空间闭区域 $\Omega$ 的边界曲面，取外侧且 $P,Q,R$ 在 $\Omega$ 内有连续偏导数</p><p>  则 $ \iiint_{\Omega}(\frac{\partial P}{\partial x} + \frac{\partial Q}{\partial y} + \frac{\partial R}{\partial z})dV = \unicode{8751}_{\sum}Pdydz + Qdzdx + Rdxdy $</p></li><li><p>通量与散度</p><p>  $\vec A(x, y, z) = P(x, y, z)\vec i + Q(x, y, z)\vec j + R(x, y, z)\vec k$</p><p>  $d\vec S = \vec e_ndS = (cos \alpha, cos\beta, cos\gamma)dS$</p><ul><li><p>通量</p><p>  $\phi = \iint_{\sum}\vec A d\vec S = \iint_{\sum} Pdydz + Qdzdx + Rdxdy$</p></li><li><p>散度</p><p>  $div \vec A = \frac{\partial P}{\partial x} + \frac{\partial Q}{\partial y} + \frac{\partial R}{\partial z}$</p></li></ul></li></ul><h3 id="S-5-5-斯托克斯公式"><a href="#S-5-5-斯托克斯公式" class="headerlink" title="$\S 5.5$ 斯托克斯公式"></a>$\S 5.5$ 斯托克斯公式</h3><ul><li><p>斯托克斯公式</p><p>  设有向闭曲线 $\tau$ 是有向曲面 $\sum$ 的边界，且满足</p><ol><li><p>$\tau$ 和 $\sum$ 的方向符合右手规则</p></li><li><p>$P(x, y, z), Q(x, y, z), R(x, y, z)$ 在包含 $\sum$ 的区域内有连续偏导数</p><p>那么<br>$$<br>\begin{aligned} \oint_{\tau}Pdx + Qdy + Rdz = \iint_{\sum}( \frac{\partial R}{\partial y} - \frac{\partial Q}{\partial z})dydz + ( \frac{\partial P}{\partial z} - \frac{\partial R}{\partial x})dxdz + ( \frac{\partial Q}{\partial x} - \frac{\partial P}{\partial y})dydx \\ = \iint_{\sum}\begin{vmatrix}dydz &amp; dzdx &amp; dxdy \newline \frac{\partial}{\partial x} &amp; \frac{\partial}{\partial y} &amp; \frac{\partial}{\partial z} \\ P &amp; Q &amp; R \end{vmatrix} \end{aligned}<br>$$</p></li></ol></li><li><p>环流量与旋度</p><p>  $\vec A(x, y, z) = P(x, y, z)\vec i + Q(x, y, z)\vec j + R(x, y, z)\vec k$</p><ul><li><p>环流量</p><p>  $\oint_{\tau}\vec A d\vec S = \oint_{\tau} Pdx + Qdy + Rdz$</p></li><li><p>旋度</p><p>  $rot \vec A = (\frac{\partial R}{\partial y} - \frac{\partial Q}{\partial z})\vec i + ( \frac{\partial P}{\partial z} - \frac{\partial R}{\partial x})\vec j + ( \frac{\partial Q}{\partial x} - \frac{\partial P}{\partial y})\vec k$</p></li></ul></li></ul><h2 id="第六章-无穷级数"><a href="#第六章-无穷级数" class="headerlink" title="第六章 无穷级数"></a>第六章 无穷级数</h2><h3 id="S-6-1-数项级数的概念和性质"><a href="#S-6-1-数项级数的概念和性质" class="headerlink" title="$\S 6.1$ 数项级数的概念和性质"></a>$\S 6.1$ 数项级数的概念和性质</h3><ul><li><p>数项级数， 一般项， 部分和， 部分和数列， 敛散性</p></li><li><p>原级数加括号后所得新级数发散， 则原级数也发散， 但若所得新级数收敛， 原级数未必收敛</p></li><li><p>级数收敛的必要条件是 $\lim_{n \to \infty} u_n = 0$</p></li><li><p>级数乘以非零数敛散性不变， 级数前面去掉有限非零项数敛散性也不变</p></li><li><p>几何级数 $\sum_{n = 0}^{\infty} aq^n = a + aq + aq^2 +\cdots + aq^n + \cdots$ </p><p>  调和级数 $\sum_{n = 1}^{\infty} \frac{1}{n} = 1 + \frac{1}{2} + \cdots + \frac{1}{n} + \cdots$</p><p>  $p$ 级数 $\sum_{n = 1}^{\infty} \frac{1}{n^p} = 1 + \frac{1}{2^p} + \cdots + \frac{1}{n^p} + \cdots$ (并且 $p \le 1$ 时收敛， $p &gt; 1$ 时发散)</p><p>  交错级数 $\sum_{n = 1}^{\infty} (-1)^nu_n$</p></li></ul><h3 id="S-6-2-正项级数的敛散性"><a href="#S-6-2-正项级数的敛散性" class="headerlink" title="$\S 6.2 $ 正项级数的敛散性"></a>$\S 6.2 $ 正项级数的敛散性</h3><ul><li><p>比较判别法</p><p>  正项级数 $\sum_{n = 1}^{\infty}u_n$ ,$\sum_{n = 1}^{\infty} v_n$ ,且当 $n &gt; N$ 时， $u_n \le kv_n$</p><ul><li><p>若 $u_n$ 发散，则 $v_n$ 发散</p></li><li><p>若 $v_n$ 收敛，则 $u_n$ 收敛</p><p>使用该方法时常用适当放缩或借助几何级数，调和级数，p级数作为参考</p><p>比较判别法的极限形式</p><p>正项级数 $\sum_{n = 1}^{\infty}u_n$ ,$\sum_{n = 1}^{\infty} v_n$ ,且 $\lim_{n \to \infty} \frac{u_n}{v_n} = l$</p></li><li><p>若 $l = \infty$ , 且 $v_n$ 发散， $u_n$ 发散，</p></li><li><p>若 $l = 0$ , 且 $v_n$ 收敛，则 $u_n$ 收敛</p></li><li><p>若 $0 &lt; l &lt; \infty$ , 则 $u_n$，$v_n$ 敛散性相同</p></li></ul></li><li><p>比值判别法（d’Alembert 判别法）</p><p>  正项级数 $\sum_{n = 1}^{\infty}u_n$  ,且 $\lim_{n \to \infty} \frac{u_{n + 1}}{u_n} = \rho$</p><ul><li>若 $\rho &lt; 1$ ,则 $u_n$ 收敛，</li><li>若 $\rho &gt; 1$ 或 $\rho = \infty$ , 则 $u_n$ 发散</li><li>若$\rho = 1$ , 则$u_n$ 敛散性不确定</li></ul></li><li><p>根植判别法（Cauchy 判别法）</p><p>  正项级数 $\sum_{n = 1}^{\infty}u_n$  ,且 $\lim_{n \to \infty} \sqrt[n]{u_n} = \rho$</p><ul><li>若 $\rho &lt; 1$ ,则 $u_n$ 收敛，</li><li>若 $\rho &gt; 1$ 或 $\rho = \infty$ , 则 $u_n$ 发散</li><li>若$\rho = 1$ , 则$u_n$ 敛散性不确定</li></ul></li></ul><h3 id="S-6-3-任意项级数"><a href="#S-6-3-任意项级数" class="headerlink" title="$\S 6.3$ 任意项级数"></a>$\S 6.3$ 任意项级数</h3><ul><li><p>Cauchy 收敛准则</p><p>  数项级数 $\sum_{n = 1}^{\infty} u_n$ 收敛的充要条件时$\forall \varepsilon &gt; 0, \exists$ 正整数 $N$， 当 $n &gt; N$ 时， 对一切正整数 $p$ 有 $|u_{n + 1} + \cdots + u_{n + p}| &lt; \varepsilon$  </p></li><li><p>Leibniz 判别法 </p><p>  若交错级数满足 $\sum_{n = 1}^{\infty} (-1)^{n + 1}u_n(u_n &gt; 0)$ 满足：</p><ul><li><p>$u_n \ge u_{n + 1}(n = 1, 2, 3, \cdots)$</p></li><li><p>$lim_{n \to \infty} u_n = 0$</p><p>则交错级数 $\sum_{n = 1}^{\infty} (-1)^{n + 1}u_n$ 收敛（注：这是充分条件，即使不满足也不能证明级数发散）</p><p>常用结论：$\sum_{n = 1}^{\infty} (-1)^{n + 1}\frac{1}{n}$ 收敛         </p></li></ul></li><li><p>绝对收敛与条件收敛</p><p>  各项符号无规律级数（如 $\sum_{n = 1} ^{\infty} \frac{sinn\alpha}{n^2}$）称为任意项级数</p><p>  若$\sum_{n = 1}^{\infty} |u_n|$ 收敛，则称级数 $\sum_{n = 1}^{\infty} u_n$ 绝对收敛</p><p>  若 $\sum_{n = 1}^{\infty} u_n$ 收敛， $\sum_{n = 1}^{\infty} |u_n|$ 发散，则称级数 $\sum_{n = 1}^{\infty} u_n$ 条件收敛</p><p>  绝对收敛则必收敛</p></li></ul><h3 id="S-6-4-函数项级数"><a href="#S-6-4-函数项级数" class="headerlink" title="$\S 6.4$ 函数项级数"></a>$\S 6.4$ 函数项级数</h3><ul><li>函数项级数 $\sum_{n = 1}^{\infty} u_n(x)$， 定义区间 $I$<ul><li>对 $x_0 \in I$， 若 $\sum_{n = 1}^{\infty} u_n(x)$ 收敛，则称 $x_0$ 为收敛点，反之称为发散点</li><li>发散点组成的全体称为发散域，收敛点组成的全体称为收敛域</li><li>求收敛域可以用比值或根式判别法来求</li><li>和函数 $s(x) = \sum_{n = 1}^{\infty}u_n(x), x \in$ 收敛域</li><li>余项 $R_n(x) = s(x) - s_n(x), x \in$ 收敛域</li></ul></li></ul><h3 id="S-6-5-幂级数"><a href="#S-6-5-幂级数" class="headerlink" title="$\S 6.5$ 幂级数"></a>$\S 6.5$ 幂级数</h3><ul><li><p>$\sum_{n = 0}^{\infty} a_n(x-x_0)^n$ 称为在点 $x_0$ 的幂级数 （一下研究均是 $x_0 = 0$ 的情况）</p></li><li><p>$Abel$ 定理</p><ul><li><p>若 $\sum_{n = 0}^{\infty} a_nx^n$ 在 $x = x_0$ 点收敛，则满足 $|x| &lt; |x_0|$ 的一切 $x$，$\sum_{n = 1}^{\infty}a_nx^n$ 绝对收敛</p></li><li><p>若 $\sum_{n = 0}^{\infty} a_nx^n$ 在 $x = x_0$ 点发散，则满足 $|x| &gt; |x_0|$ 的一切 $x$，$\sum_{n = 1}^{\infty}a_nx^n$ 发散</p><p>  由 $Abel$ 定理可知，幂级数 $\sum_{n = 1}^{\infty}a_nx^n$ 的收敛域是以原点为中心的区间，收敛半径 $R$ 记为收敛域长度的一半，$(-R, R)$ 记为收敛区间，不是收敛域，该收敛区间加上收敛的端点才是收敛域</p></li></ul></li><li><p>计算收敛半径 $R$ （仅在不缺项的时候可以用，缺项情况要用比值判别法或根式判别法来求）</p><p>  若 $lim_{n \to \infty}|\frac{a_{n+1}}{a_n}| = \rho$ 或 $\lim_{n \to \infty} \sqrt[n]{|a_n|} = \rho$ 则收敛半径 $R = \frac{1}{\rho}$ 特别的，$\rho = 0$ 时 $ R = \infty$ $\rho = \infty$ 时 $R = 0$</p></li><li><p>幂级数代数运算</p><ul><li>幂级数相加可逐项分别相加，且新级数的收敛半径 $R \ge min\{R_1, R_2\}$ （但 $R_1 \ne R_2$ 时，必有 $R = min\{R_1, R_2\}$）</li><li>幂级数相乘，新级数的收敛半径 $R \ge min\{R_1, R_2\}$ </li></ul></li><li><p>幂级数的和函数 $s( x )$</p><ul><li>$s(x)$ 在收敛域内连续</li><li>收敛域内 $s(x)$ 可微， 且对 $s(x)$ 求导可以先对各项求导再相加</li><li>收敛域内 $s(x)$ 可积， 且对 $s(x)$ 积分可以先对各项积分再相加</li></ul></li><li><p>泰勒级数</p><ul><li><p>$f(x)$ 在 $x_0$ 处的泰勒级数为 $\sum_{n = 0}^{\infty} \frac{f^{(n)}(x_0)}{n!}(x-x_0)^n$</p></li><li><p>函数能展开成幂级数的必要条件是在区间 $I$ 内有任意阶导数， 但此时写出的泰勒级数未必收敛于 $f(x)$</p></li><li><p>只有满足 $f(x)$ 在 $x_0$ 某一邻域内有任意阶导数，并且存在 $R &gt; 0$，使 $|x - x_0| &lt; R$ 时，$\lim_{n \to \infty} R_n(x) = \lim_{n \to \infty} \frac{f^{(n + 1)}(\xi)}{(n + 1)!}(x-x_0)^{n + 1} = 0$ ，这时 $f(x)$ 才能在邻域 $U(x_0, R)$ 内展开成泰勒级数</p></li><li><p>特殊的，当 $x_0 = 0$ 时，$f(x)$ 的泰勒级数为 $\sum_{n = 0}^{\infty} \frac{f^{(n)}(0)}{n!}x^n$ 称为 $f(x)$ 的麦克劳林级数或 $x$ 的幂级数</p></li><li><p>常用幂级数展开式<br>  $$<br>  \begin{gather<em>}<br>  \frac{1}{1-x} = \sum_{n = 0}^{\infty}x^{n},\ \frac{1}{1+x} = \sum_{n = 0}^{\infty}(-1)^nx^{n}\ (-1 &lt; x &lt; 1)<br>  \newline e^x = \sum_{n = 0}^{\infty}\frac{x^n}{n!}\ (-\infty &lt; x &lt; \infty)<br>  \newline \sin x = \sum_{n = 0}^{\infty}(-1)^n\frac{x^{2n+1}}{(2n+1)!}\ (-\infty &lt; x &lt; \infty)<br>  \newline \cos x = \sum_{n = 0}^{\infty}(-1)^n\frac{x^{2n}}{(2n)!}\ (-\infty &lt; x &lt; \infty)<br>  \newline \ln(1 + x) = \sum_{n = 0}^{\infty} (-1)^n\frac{x^{n + 1}}{n + 1}\ (-1 &lt; x \le 1)<br>  \newline \arctan x = \sum_{n = 0}^{\infty} (-1)^n\frac{x^{2n + 1}}{2n + 1}\ (-1 \le x \le 1)<br>  \end{gather</em>}<br>  $$<br>  值得注意的是，若 $f(x)$ 能展开成幂级数，那么展开方式必定是唯一的，而且一定是泰勒级数</p></li></ul></li><li><p>欧拉公式</p><ul><li>$e^{ix} = cosx + isinx$ </li><li>$cos x = \frac{e^{ix} + e^{-ix}}{2}$，$sin x = \frac{e^{ix} - e^{-ix}}{2i}$</li><li>$e^{i\pi} + 1 = 0$  <strong>上帝创造的公式！！！</strong></li></ul></li></ul><h3 id="S-6-6-傅里叶级数"><a href="#S-6-6-傅里叶级数" class="headerlink" title="$\S 6.6$ 傅里叶级数"></a>$\S 6.6$ 傅里叶级数</h3><ul><li><p>三角函数系 </p><p>  $1, sinx, cosx, cos2x, sin2x, \cdots, cosnx, sinnx, \cdots$ 其中任意两个相异函数在区间$[-\pi, pi]$ 上的积分等于 $0$，称为三角函数系的正交性</p></li><li><p>函数展开成傅里叶级数</p><p>  设 $f(x)$ 为周期为 $2\pi$ 的可积函数，若 $f(x)$ 能展开成三角级数，即$f(x) = \frac{1}{2}a_0+\sum_{n = 1}^{\infty}(a_ncosnx + b_nsinnx)$</p><p>  则 $a_k = \frac{1}{\pi}\int_{-\pi}^{\pi}f(x)coskxdx$，$b_k = \frac{1}{\pi}\int_{-\pi}^{\pi}f(x)sinkxdx$</p><p>  $f(x)$ 的傅里叶级数记为 $f(x) \sim \frac{a_0}{2} + \sum_{n = 1}^{\infty}(a_ncosnx+b_nsinnx)$，其中 $a_n$，$b_n$ 称为傅里叶系数，注意这里的 $\sim$ 表示 $f(x)$ 和它的傅里叶系数有某种联系关系，这个级数本身可能收敛，可能不收敛，收敛也未必收敛于 $f(x)$</p></li><li><p>狄利克雷收敛定理</p><p>  设 $f(x)$ 为周期为 $2\pi$ 的可积函数，若 $f(x)$ 在 $[-\pi,\pi]$ 上满足狄利克雷条件</p><ul><li>连续或只有有限个第一类间断点</li><li>只有有限个极值点</li></ul><p>  <strong>直观来说就是函数图像在周期内，连续或分段连续且不作无限次振动</strong>，则 $f(x)$ 的傅里叶级数收敛，在 $f(x)$ 的<strong>连续点</strong>，级数收敛于 $f(x)$，而对于 $f(x)$ 的间断点 $x$，级数收敛于间断点处左右极限的中点（注意在满足狄利克雷收敛定理条件下是一定会收敛的，只是收敛会不会收敛于 $f(x)$ 不确定）</p></li><li><p>周期延拓</p></li><li><p>奇函数的傅里叶级数只有正弦项，又称为正弦级数</p><p>  偶函数的傅里叶级数只有余弦项，又称为余弦级数</p></li><li><p>周期为 $2l$ 的函数展成傅里叶级数</p><p>  $f(x) \sim \frac{a_0}{2} + \sum_{n = 1}^{\infty}(a_ncosn\frac{\pi}{l}x + b_nsinn\frac{\pi}{l}x)$</p><ul><li><p>$a_n = \frac{1}{l}\int^{l}_{-l}f(x)cosn\frac{\pi}{l}xdx    $</p></li><li><p>$b_n = \frac{1}{l}\int^{l}_{-l}f(x)sinn\frac{\pi}{l}xdx    $</p><p>只在 $[0, l]$ 上有定义的函数，展开成正弦级数或余弦级数，需做奇延拓或偶延拓</p><p>和差化积公式参考如下<br>$$<br>\begin{gather}<br>{\displaystyle \sin \alpha +\sin \beta =2\sin { \alpha +\beta \over 2}\cos { \alpha -\beta \over 2}} \\ {\displaystyle \sin \alpha -\sin \beta =2\cos {\alpha +\beta \over 2}\sin {\alpha -\beta \over 2}} \\ {\displaystyle \cos \alpha +\cos \beta =2\cos {\alpha +\beta \over 2}\cos {\alpha -\beta \over 2}} \\ {\displaystyle \cos \alpha -\cos \beta =-2\sin {\alpha +\beta \over 2}\sin {\alpha -\beta \over 2}}<br>\\ \newline \newline {\displaystyle \sin \alpha \cos \beta ={\sin(\alpha +\beta )+\sin(\alpha -\beta ) \over 2}} \\ {\displaystyle \cos \alpha \sin \beta ={\sin(\alpha +\beta )-\sin(\alpha -\beta ) \over 2}} \\ {\displaystyle \cos \alpha \cos \beta ={\cos(\alpha +\beta )+\cos(\alpha -\beta ) \over 2}} \\ {\displaystyle \sin \alpha \sin \beta =-{\cos(\alpha +\beta )-\cos(\alpha -\beta ) \over 2}}<br>\end{gather}<br>$$</p></li></ul></li></ul><h2 id="第七章-常微分方程"><a href="#第七章-常微分方程" class="headerlink" title="第七章 常微分方程"></a>第七章 常微分方程</h2><h4 id="第七章总结"><a href="#第七章总结" class="headerlink" title="第七章总结"></a>第七章总结</h4><ol><li><p>本章研究的方程主要有两种：一阶线性微分方程 和 高阶微分方程</p></li><li><p>对于一阶线性微分方程</p><ul><li>首先考虑是不是全微分方程，若满足 $\frac{\partial P}{\partial y} = \frac{\partial Q}{\partial y}$，则化为 $u(x, y) = 0$ 的形式</li><li>不是全微分方程就化为 $\frac{dy}{dx} = \cdots$ 的形式，然后几种情况无非是$\frac{dy}{dx} = f(x)g(x),\frac{dy}{dx} = \varphi(\frac{dy}{dx}),\frac{dy}{dx} = p(x)y,\frac{dy}{dx} = p(x)y + q(x),\frac{dy}{dx} = p(x)y + q(x)y^n$ 这五种形式，其中只有第四，五种要稍微记一下，伯努利方程（第五种）稍微转化一下就是第四种</li><li>化成 $\frac{dy}{dx} = \cdots$ 比较复杂的话就化为 $\frac{dx}{dy} = \cdots$形式</li></ul></li><li><p>对于高阶方程</p><ul><li>可降阶方程本质就是不断积分</li><li>高阶齐次方程记一下特征根的形式，掌握二阶齐次即可，高阶只需了解</li><li>高阶非齐次方程也是主要记一下两种特征根形式，欧拉方程单独记一下</li></ul></li></ol><h3 id="S-7-1-常微分方程的概念"><a href="#S-7-1-常微分方程的概念" class="headerlink" title="$\S 7.1$ 常微分方程的概念"></a>$\S 7.1$ 常微分方程的概念</h3><ul><li><p>微分方程，常微分方程，偏微分方程，方程的阶，线性微分方程，非线性微分方程，显式通解，隐式通解，特解，初始条件，初值问题（Cauchy问题）</p></li><li><p>方程通解的特征是含有任意常数，任意常数个数与方程阶数相同</p><p>  值得注意的是，<strong>通解未必是方程的全部解</strong></p></li></ul><h3 id="S-7-2-可分离变量的方程"><a href="#S-7-2-可分离变量的方程" class="headerlink" title="$\S 7.2$ 可分离变量的方程"></a>$\S 7.2$ 可分离变量的方程</h3><ul><li><p>可分离变量的方程</p><p>  形如 $\frac{dy}{dx} = f(x)g(x)$ ，方法是 $y$ ，$x$ 分别放在等式两边分别积分运算</p><p>  方程特征是化为一般式后，方程右端可分解为只含 $x$ 和只含 $y$ 的两个函数乘积</p></li><li><p>齐次方程</p><p>  形如 $\frac{dy}{dx} = \varphi(\frac{dy}{dx})$ ，方法是令 $u = \frac{y}{x}$，再化为可分离变量方程求解</p><p>  方程特征是各项次数均相同</p></li></ul><h3 id="S-7-3-一阶线性微分方程"><a href="#S-7-3-一阶线性微分方程" class="headerlink" title="$\S 7.3$ 一阶线性微分方程"></a>$\S 7.3$ 一阶线性微分方程</h3><p>一阶线性微分方程的标准形式为 $\frac{dy}{dx} = p(x)y + q(x)$，若 $q(x) \equiv 0$，称为齐次线性方程，若 $q(x) \not\equiv 0$，则称为非齐次方程</p><ul><li><p>一阶齐次线性方程</p><p>  形如 $\frac{dy}{dx} = p(x)y$ ，通解为 $y = Ce^{\int p(x)dx}$</p></li><li><p>一阶非齐次线性方程</p><p>  形如 $\frac{dy}{dx} = p(x)y + q(x)$ ，通解为 $y = e^{\int p(x)dx}(\int q(x)e^{-\int p(x)dx}dx + C)$</p></li><li><p>伯努利（Bernoulli）方程</p><p>  形如 $\frac{dy}{dx} = p(x)y + q(x)y^n$ ，解法是方程两边除以 $y^n$，再凑微分化为一阶非齐次线性方程</p></li></ul><h3 id="S-7-4-全微分方程"><a href="#S-7-4-全微分方程" class="headerlink" title="$\S 7.4$ 全微分方程"></a>$\S 7.4$ 全微分方程</h3><ul><li><p>全微分方程</p><ul><li><p>若 $P(x, y),Q(x, y)$ 在单连通区域 $D$ 内有连续的一阶偏导数，且 $\frac{\partial P}{\partial y} = \frac{\partial Q}{\partial x}$ 则方程， $P(x, y)dx + Q(x, y)dy = 0$ 称为全微分方程</p></li><li><p>对于全微分方程必有 $u(x, y)$ 使 $du(x, y) = P(x, y)dx + Q(x, y)dy = 0$ 从而 $u(x, y) = C$</p></li><li><p>求法 $u(x, y) = \int^x_{x_0}P(x, y_0)dx + \int^y_{y_0}Q(x, y)dy = \int^y_{y_0}Q(x_0, y)dy + \int^x_{x_0}P(x, y)dx$ ，通解 $u(x, y) = C$</p></li></ul></li></ul><h3 id="S-7-5-可降阶的高阶方程"><a href="#S-7-5-可降阶的高阶方程" class="headerlink" title="$\S 7.5$ 可降阶的高阶方程"></a>$\S 7.5$ 可降阶的高阶方程</h3><ul><li><p>$y^{(n)} = f(x)$ 型方程</p><p>  不断积分，方程求特解时，任意常数出现一个确定一个</p></li><li><p>$y’’ = f(x, y’)$ 型方程</p><p>  设 $y’ = p(x)$ 原方程可化为 $\frac{dp}{dx} = f(x, p)$ 再用一阶方程的解法求出通解，最后积分得出 $y$ 的值</p></li><li><p>$y’’ = f(y,y’)$</p><p>  设 $y’ = p(y)$，则原方程可化为 $p\frac{dp}{dy} = f(y, p)$，再用一阶方程解法求通解</p></li></ul><h3 id="S-7-6-高阶齐次线性方程"><a href="#S-7-6-高阶齐次线性方程" class="headerlink" title="$\S 7.6 $ 高阶齐次线性方程"></a>$\S 7.6 $ 高阶齐次线性方程</h3><ul><li><p>方程的线性无（相）关以及判定</p></li><li><p>线性齐次方程组解的结构</p></li><li><p>二阶常系数齐次线性方程 $y’’+py’+qy=0$</p><ul><li>特征方程，特征根</li><li>特征方程有两个不同实根的情况，$y = C_1e^{r_1x} + C_2e^{r_2x}$</li><li>特征方程有两个相同实根的情况，$y = (C_1 + C_2x)e^{r_1x}$</li><li>若特征方程有一对共轭复根 $r = \alpha \pm i \beta$ 的情况，$y = e^{\alpha x}(C_1cos\beta x + C_2 sin \beta x)$</li></ul></li><li><p>$n$ 阶常系数齐次线性方程</p><p>  大致同二阶情况，每一个根都对应一个特解，$k$ 重根算 $k$ 个根</p><ul><li><p>$k$ 重实根 $r$ 对应 $k$ 个特解：$x^0e^{rx},\cdots,x^{k - 1}e^{rx}$</p></li><li><p>$k$ 重复数根 $r = \alpha \pm i \beta$ 对应的 $2k$ 个特解：</p><p>  ​    $x^0e^{\alpha x}cos\beta x,\cdots,x^{k - 1}e^{\alpha x}cos\beta x$ </p><p>  ​    $x^0e^{\alpha x}sin\beta x,\cdots,x^{k - 1}e^{\alpha x}sin\beta x$ </p></li></ul></li></ul><h3 id="S-7-7-高阶非齐次线性方程"><a href="#S-7-7-高阶非齐次线性方程" class="headerlink" title="$\S 7.7$ 高阶非齐次线性方程"></a>$\S 7.7$ 高阶非齐次线性方程</h3><p> $y’’ + py’ + qy = f(x)$</p><ul><li><p>非线性齐次方程组解的结构</p></li><li><p>$f(x) = P_m(x)e^{\lambda x}$</p><p>  设特解 $y^*=Q(x)e^{\lambda x}$，$Q(x)$ 为多项式，化简得 $Q’’(x)+(2\lambda + p)Q’(x) + (\lambda ^ 2 + p \lambda + q)Q(x) = P_m(x)$，再分析出 $Q(x)$ 的阶数之后用待定系数法求解</p><p>  $y^*=x^lQ_m(x)e^{\lambda x}$，$\lambda$ 是特征方程的 $l$ 重根 </p></li><li><p>$f(x)=e^{\lambda x}[P_l(x)cos\omega x +P_n(x)sin\omega x])$</p><p>  特解 $y^*=x^ke^{\lambda x}[Q_m^{(1)}(x)cos\omega x + Q_m^{(2)}(x)sin\omega x],m = \max\{l, n\}$      </p><p>  其中 $k = 0,1$（$\lambda + i\omega$ 不是特征根时 $k$ 是 $0$，反之 $k$ 是 $1$)，这里 $Q_m^{(1)}$ 和 $Q_m^{(2)}$ 是待定的，只用知道他们是 $m$ 次多项式即可，剩下的用待定系数法求解</p></li><li><p>欧拉方程</p><ul><li>形如 $x^ny^{(n)} + p_1x^{n - 1}y^{(n - 1)} + \cdots + p_{n - 1}xy’ + p_ny = f(x)$ 的方程叫欧拉方程，特点是 $x^ky^{(k)}$ 配对出现</li><li>解法是设 $x = e^t,\frac{dy}{dt}=Dy, \cdots, \frac{d^ky}{dt^k} = D^ky$，则 $x^ky^{(k)} = D(D - 1)\cdots(D - k + 1)y$，最后方程化为只与 $t$ 有关的线性方程</li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 大学课程 </tag>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
