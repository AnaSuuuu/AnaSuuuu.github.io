<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CodeForces 补全计划（1826 ~ 1850）</title>
    <url>/2023/06/26/CF-Instrumentality-Project-I/</url>
    <content><![CDATA[<p>千里之行，始于足下。</p>
<span id="more"></span>
<h2 id="1826-Codeforces-Round-870-Div-2"><a href="#1826-Codeforces-Round-870-Div-2" class="headerlink" title="1826. Codeforces Round 870 (Div. 2)"></a>1826. <a href="https://codeforces.com/contest/1826">Codeforces Round 870 (Div. 2)</a></h2><h3 id="E-Walk-the-Runway"><a href="#E-Walk-the-Runway" class="headerlink" title="E. Walk the Runway"></a><a href="https://codeforces.com/contest/1826/problem/E">E. Walk the Runway</a></h3><h4 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h4><p>$n$ 个人每个人都有一个价值 $p_i$，然后这 $n$ 个人有 $m$ 维数值，要求你从中选取若干个人并且可以任意调整选的人的顺序，要求选的人满足 $m$ 维中每一维里选的人的数值都严格递增。</p>
<p>$n \le 5000,m \le 500$。</p>
<h4 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h4><p>如果我们已知两个人之间的偏序关系，我们可以在两个人之间连一条有向边（或不连），故这 $n$ 个人的关系可以用一个有向无环图来表示，在图上跑 dfs，时间复杂度是 $O(n^2)$，是完全够的，那么我们现在研究如何求任意两个人之间偏序关系。</p>
<p>直接暴力求偏序关系的时间复杂度是 $O(n^2m)$，显然是会 T 的，那么我们可以用 bitset 来优化。对每一维排完序后前面的肯定不会排在这个数的后面，故每次用 bitset 的 &amp; 运算即可，时间复杂度是 $O(\dfrac{m}{w})$，其中 $w$ 等于 $64$。</p>
<p><a href="https://codeforces.com/contest/1826/submission/212761847">Code</a></p>
<h3 id="F-Fading-into-Fog"><a href="#F-Fading-into-Fog" class="headerlink" title="F. Fading into Fog"></a><a href="https://codeforces.com/contest/1826/problem/F">F. Fading into Fog</a></h3><h4 id="Description-1"><a href="#Description-1" class="headerlink" title="Description"></a>Description</h4><p>交互题</p>
<p>有 $n$ 个隐藏点，每次你可以给出 $a$，$b$，$c$，询问一条形如 $ax+by+c=0$ 的直线，交互库会以<strong>任意顺序</strong>告诉你每个点在直线上的投影（保证每个返回的投影点与真实投影点的距离不超过 $10^{-4}$）。</p>
<p>请用最少的询问求出这些隐藏点的位置，精度相差 $10^{-3}$ 即可。</p>
<p>保证每个隐藏点的与其他隐藏点的 $x$ 坐标和 $y$ 坐标都至少相差 $1$，每次询问的 $∣a∣+∣b∣≥0.1$。</p>
<h4 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h4><p>通过画图观察不难发现，其实最多三次询问就可以确定这 $n$ 个点了，所以题目就变为不超过三次询问求出 $n$ 点，一条平行 $x$ 轴，一条平行 $y$ 轴，一条斜着的边（但是很贴近 $x$ 轴），前两个就可以确定这 $n$ 个点的横纵坐标，第三个完全确定这 $n$ 个点。</p>
<p>为什么第三条线要贴近 $x$ 轴呢？因为我们的处理方法是对第一，三条线得到的 $n$ 个投影点按横坐标排序，选一条贴近 $x$ 轴的线保证这 $n$ 个点和第一条线的 $n$ 个点顺序一致，这样的话我们就可以算出每个点纵坐标的值，但不准确可能会有误差，但是我们知道每个点的纵坐标，所以我们可以找纵坐标和我们计算的估计值中最贴近的值来替换。</p>
<p>值得注意的是，本题对精度要求较高，应用 <code>long double</code> 来存储</p>
<p><a href="https://codeforces.com/contest/1826/submission/212805712">Code</a></p>
<h2 id="1828-Codeforces-Round-873-Div-2"><a href="#1828-Codeforces-Round-873-Div-2" class="headerlink" title="1828. Codeforces Round 873 (Div. 2)"></a>1828. <a href="https://codeforces.com/contest/1828">Codeforces Round 873 (Div. 2)</a></h2><h3 id="D2-Range-Sorting-Hard-Version"><a href="#D2-Range-Sorting-Hard-Version" class="headerlink" title="D2. Range Sorting (Hard Version)"></a><a href="https://codeforces.com/contest/1828/problem/D2">D2. Range Sorting (Hard Version)</a></h3><h4 id="Description-2"><a href="#Description-2" class="headerlink" title="Description"></a>Description</h4><p>对一个数组 $\{p_i\}$ 的一段区间 $[l,r]$ 排序的代价为 $r−l$ ，对整个数组 $p_i$ 排序的代价为选定若干区间并排序，使得整个数组有序的代价之和。</p>
<p>求 $\{a_i\}$ 的所有子段排序的代价之和。</p>
<p>Easy Version $n \le 5 \times 10^3$</p>
<p>Hard Version $n \le 3 \times 10^5$</p>
<h4 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h4><p>有点难想。</p>
<p>仔细观察样例，不难发现一些性质：</p>
<ul>
<li>操作区间一定是不重叠的，不然直接对整个区间操作更优。</li>
<li>尽可能多区间操作会使答案更优。</li>
<li>更分成两个区间操作则一定满足前一个区间的最大值小于后一个区间的最小值。</li>
</ul>
<p>那么基于以上性质，我们很容易搞出 $O(n^3)$ 暴力：枚举区间左右端点，枚举中间间隔点，提前用 st表 预处理出区间最大最小值然后来求，但是这样发现连 Easy Version 都过不了，故我们可以来稍改进一下思路。</p>
<p>对于 Easy Version，我们可以固定左端点，每次枚举右端点，每次向后加入一个新的数时，我们要重新计算对答案的贡献，我们算 $[l, r]$ 区间的答案就是区间长度减去最多可拆分区间数，假设我们已经知道了 $[l, r - 1]$ 区间的答案以及划分区间，加入 $a_r$ 数后，我们其实就是要把这个数和某个区间合并，满足合并后的区间的最小值依然大于前面区间的最大值。所以我们可以记录之前几个划分区间的最大值，然后不断向前跳，看 $a_r$ 可以和哪几个区间合并，找到第一个可以合并的区间就直接合并，这样一定是最优的。合并完之后更新新的拆分区间，答案也比较好统计，时间复杂度 $O(n^2)$。</p>
<p>对于 Hard Vesion，我们发现很难从 Easy Version 上再继续优化，我们换另一个思路。能过 $3 \times 10^5$ 的做法应该是 $O(nlogn)$ 或 $O(n)$ 的，所以我们要找到这个复杂度的算法应该是算每个位置所能做出的贡献。我们先算最坏情况下一共的代价为 $\sum_{i = 2}^{n}(i - 1)(n - i + 1)$，然后我们再算每个位置对代价能减少的贡献。若能对答案产生减少的贡献，对于一个大区间，我们一定可以拆分成两个小区间。对于每个位置，我们不妨假设这个位置 $i$ 上的数是后一个区间的最小值。然后我们往后找到第一个小于 $a_i$ 的数的位置 $r_i$（这里求“第一个小于“这样的位置，我们可以用单调栈来求），然后再往前找第一个小于 $a_i$ 的数的位置 $l_i$，那么我们可以确定后一个区间的左端点是 $(l_i + 1)$，右端点是在 $i \sim (r_i - 1)$ 里选。然后前一个区间的右端点是 $l_i$，最后只用确定前一个区间的左端点，这里我们可以用 st表 先求出区间最大值，然后不断跳表来求出左端点 $kdl$。然后这个位置的数对答案减少的贡献为 $(r_i - i)\times(l_i - kdl + 1)$，时间复杂度为 $O(nlogn)$。</p>
<p><a href="https://codeforces.com/contest/1828/submission/212909151">Code (Easy Version)</a></p>
<p><a href="https://codeforces.com/contest/1828/submission/213004607">Code (Hard Version)</a></p>
<h3 id="E-Palindrome-Partition"><a href="#E-Palindrome-Partition" class="headerlink" title="E. Palindrome Partition"></a><a href="https://codeforces.com/contest/1828/problem/E">E. Palindrome Partition</a></h3><h4 id="Description-3"><a href="#Description-3" class="headerlink" title="Description"></a>Description</h4><p>称一个字符串是好的，当且仅当它是一个长度为偶数的回文串或由若干长度为偶数的回文串拼接而成。</p>
<p>给定一个长度为 $n$ 的字符串 $s$，求有多少 $s$ 的子串是好的。</p>
<p>$1≤n≤5×10^5$，$s$ 仅包含小写字母。</p>
<h4 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution"></a>Solution</h4><p>根据数据范围可以得出正解的时间复杂度应该是 $O(n)$ 或 $O(nlogn)$ 的。</p>
<p>本题采用动态规划，可以令 $g[i]$ 表示以 $i$ 结尾的好串个数，那么显然答案就是 $\sum_{i = 1}^n g[i]$ 。那么怎么求 $g[i]$ 呢，我们考虑到对于一个回文串，我们把它尽可能多分为由若干回文字串组成，分到不能分为止。这样分解出来的每一个回文串里一定不会包含回文前缀 / 后缀（因为要是包含的话就又可以分解了）。这样分解之后，对于一个好的字符串，一定是由若干小的不可分解的回文串组成。而且显然这种分解方法是唯一的。说明这样的话，对于每个好的字符串而言我们只算了一次，正是我们想要的。基于这个思路，我们再引入一个新的数组 $f[i]$，$f[i]$ 表示以 $i$ 结尾的回文串的最小长度，因为以 $i$ 结尾的字串一定是包含以 $i$ 结尾的最小回文串的，而且基于之前的分解方法，我们可以得到 $g[i] = g[i - f[i]] + 1(f[i] \ne 0)$，当 $f[i] = 0$ 时，$g[i] = 0$。那么现在我们将问题转化为了如何求 $f[i]$，我们先进行一遍 Manacher 算法，求出以每一位为对称轴的最大回文半径，由于要求是偶回文，所以我们只考虑以两个位置中间为轴。我们发现，若以第 $i$ 位为轴，那么 $[i + 1, i + len[i]]$ 这个范围内是都可以作为回文结尾的，可以被 $i$ 覆盖。而想要让回文最小，就是从后向前扫一遍，如果先被以 $i$ 覆盖的，一定满足以 $i$ 为轴回文最小，我们知道了右端点和回文轴就可以计算出回文长度了，也就可以计算出 $f[i]$ 了，要注意的是，如果区间中一部分点被之前的对称轴覆盖了，那么我们被之后对称轴覆盖时要跳过这几个点，可以用双向链表来维护。</p>
<p><a href="https://codeforces.com/contest/1828/submission/213452328">Code</a></p>
<h3 id="F-Two-Centroids"><a href="#F-Two-Centroids" class="headerlink" title="F. Two Centroids"></a><a href="https://codeforces.com/contest/1828/problem/F">F. Two Centroids</a></h3><h4 id="Description-4"><a href="#Description-4" class="headerlink" title="Description"></a>Description</h4><h4 id="Solution-4"><a href="#Solution-4" class="headerlink" title="Solution"></a>Solution</h4><h2 id="1829-Codeforces-Round-871-Div-4"><a href="#1829-Codeforces-Round-871-Div-4" class="headerlink" title="1829. Codeforces Round 871 (Div. 4)"></a>1829. <a href="https://codeforces.com/contest/1829">Codeforces Round 871 (Div. 4)</a></h2><h3 id="G-Hits-Different"><a href="#G-Hits-Different" class="headerlink" title="G. Hits Different"></a><a href="https://codeforces.com/contest/1829/problem/G">G. Hits Different</a></h3><h4 id="Description-5"><a href="#Description-5" class="headerlink" title="Description"></a>Description</h4><p><img src="1829G.png" alt="1829G"></p>
<p>若干块以金字塔状摆放，用球击倒下方的，上方也会倒下，第 $n$ 块分数 $n^2$，问用球打第 $n$ 块能得多少分</p>
<h4 id="Solution-5"><a href="#Solution-5" class="headerlink" title="Solution"></a>Solution</h4><p>方法一：</p>
<p>​    动态规划， $f[i]$ 表示击打第 $i$ 块能得的分数，$f[i] = f[左上] + f[右上] - f[公共]$，因为左上和右上是有公共部分会多算，所以简单容斥一下</p>
<p>方法二：</p>
<p>​    还是动态规划，先把图倾斜 $45°$</p>
<p>​    <img src="1829G-sol1.png" alt="1829G-sol1"></p>
<p>​    感觉变好看了一点（？）</p>
<p>​    再转45°</p>
<p><img src="1829G-sol2.png" alt="1829G-sol2"></p>
<p>​    嗯，变成一个简单二维DP就能解决的问题了</p>
<p><a href="https://codeforces.com/contest/1829/submission/211201013">Code (Method I)</a></p>
<p><a href="https://codeforces.com/contest/1829/submission/211200275">Code (Method II)</a></p>
<h2 id="1837-Educational-Codeforces-Round-149-Rated-for-Div-2"><a href="#1837-Educational-Codeforces-Round-149-Rated-for-Div-2" class="headerlink" title="1837. Educational Codeforces Round 149 (Rated for Div. 2)"></a>1837. <a href="https://codeforces.com/contest/1837">Educational Codeforces Round 149 (Rated for Div. 2)</a></h2><h3 id="E-Playoff-Fixing"><a href="#E-Playoff-Fixing" class="headerlink" title="E. Playoff Fixing"></a><a href="https://codeforces.com/contest/1837/problem/E">E. Playoff Fixing</a></h3><h4 id="Description-6"><a href="#Description-6" class="headerlink" title="Description"></a>Description</h4><p>给定数 $k$，一共有 $2^k$ 个人参加比赛，序号越小的实力越强。每轮第 $2i$ 和 $2i-1$ 进行比赛，一共进行 $k$ 轮，最后要求序号为 $1$ 的一直留到最后一轮，序号为 $2$ 的留到倒数第二轮，序号为 $3 \sim 4$ 的留到倒数第三轮，以此类推，序号 $2^{k - 1} + 1$ 到 $2^k$ 的人要求第一轮淘汰，给定部分人当前位置，如果这个位置上还没确定选手就用 $-1$ 表示，问一共又有多少种表示合法方案</p>
<h4 id="Solution-6"><a href="#Solution-6" class="headerlink" title="Solution"></a>Solution</h4><p>第一轮中，我们可以知道序号 $2^{k - 1} + 1$ 到 $2^k$ 的人可以安排在哪里，一定是在 $\{1,2\}$，$\{3,4\},\cdots, \{2^k - 1,2^k\}$ 中各选一个，如果两个都没选则两个位置都可以放，记一下这种情况的个数是 $cnt1$，如果一个位置放了小于 $2^{k-1}$ 的序号，那么只能选另一个位置放，如果两个位置都被选了且不合法，那么就返回 $0$，设一共有 $cnt2$ 个可以放的位置，那么这轮方案数是 $2^{cnt1} \times cnt1 !$ 而且这一轮放置的人下一轮都被淘汰了，所以无后效性，然后下一轮其实就变为规模折半的子问题，不断迭代计算即可</p>
<p><a href="https://codeforces.com/contest/1837/submission/211143124">Code</a></p>
<h3 id="F-Editorial-for-Two"><a href="#F-Editorial-for-Two" class="headerlink" title="F. Editorial for Two"></a><a href="https://codeforces.com/contest/1837/problem/F">F. Editorial for Two</a></h3><h4 id="Description-7"><a href="#Description-7" class="headerlink" title="Description"></a>Description</h4><p>$n$ 个数中选 $k$ 个数（不改变在原序列中顺序），要求这 $k$ 个数分为前后两半后，这前后两部分和的最大值尽可能小。</p>
<h4 id="Solution-7"><a href="#Solution-7" class="headerlink" title="Solution"></a>Solution</h4><p>这道题可以用二分来做，对于二分值 $lim$，先正着扫一遍，再倒着扫一遍，扫到第 $i$ 位置时，我们只要算一下前 $i - 1$ 位置中 和不超过 $lim$ 的最多可以选的数的个数 + 后 $i$ 到 $n$ 位置中 和不超过 $k$ 的最多可以选的数的个数  之和是不是大于 $k$ 即可。</p>
<p><a href="https://codeforces.com/contest/1837/submission/211151946">Code</a></p>
<h2 id="1840-Codeforces-Round-878-Div-3"><a href="#1840-Codeforces-Round-878-Div-3" class="headerlink" title="1840. Codeforces Round 878 (Div. 3)"></a>1840. <a href="https://codeforces.com/contest/1840">Codeforces Round 878 (Div. 3)</a></h2><h3 id="F-Railguns"><a href="#F-Railguns" class="headerlink" title="F. Railguns"></a><a href="https://codeforces.com/contest/1840/problem/F">F. Railguns</a></h3><h4 id="Description-8"><a href="#Description-8" class="headerlink" title="Description"></a>Description</h4><p>Tema 在 $n⋅m$ 的网格内要从 $(0,0)$ 走到 $n⋅m$。第 $0$ 秒末 Tema 位于 $(0,0)$。</p>
<p>每次行动 Tema 可以选择向下走，向右走或不动。</p>
<p>机器人会发射 $r$ 次激光炮以阻挠他前进，具体为在第 $t$ 秒，向第 $x$ 行或第 $x$ 列发射激光炮，一整列或一整行都会受到炮击。若 Tema 在第 $t$ 秒末还停留在被炮击的单元格内则会被击毁。求 Tema 从 $(0,0)$ 到达 $(n,m)$ 的最短时间，若无法抵达，则输出 $−1$。</p>
<p>$r$ 次炮击格式为 $t$，$d$，$coord$ ，$t$ 表示炮击发生的时间，$d$ 表示炮击方式 ( $d=1$ 时攻击一整行，$d=2$ 时攻击一整列)，$coord$ 表示攻击的是具体哪一行/列）</p>
<h4 id="Solution-8"><a href="#Solution-8" class="headerlink" title="Solution"></a>Solution</h4><p>设 $f[i][j][k]$ 表示在 $k$ 时刻到第 $i$ 行第 $j$ 列是否合法，由于我们发现时间 $t$ 的范围是到 $10^9$ 且到达某位置的时间 $t$ 只和 $i$，$j$，和停下躲避了几次有关，而且躲避的次数最多不超过 $100$ 次，所以 $k$ 可以用停下躲避的次数来表示，这样转移方程就很简单了  $f[i][j][k] = f[i - 1][j][k] | f[i][j - 1][k] | f[i][j][k - 1]$ 。</p>
<p><a href="https://codeforces.com/contest/1840/submission/211968399">Code</a></p>
<h3 id="G2-In-Search-of-Truth-Hard-Version"><a href="#G2-In-Search-of-Truth-Hard-Version" class="headerlink" title="G2. In Search of Truth (Hard Version)"></a><a href="https://codeforces.com/contest/1840/problem/G2">G2. In Search of Truth (Hard Version)</a></h3><h4 id="Description-9"><a href="#Description-9" class="headerlink" title="Description"></a>Description</h4><p>交互题</p>
<p>一个转盘共 $n$（ $n$ 未知 ）个格子，格子 $1$ 到 $n$ 乱序编号，你每次可以顺/逆时针旋转 $k$ 个格子，输出顺/逆时针（分别用“+”、“-”表示）和 $k$。需要读取起始格子的编号和每次旋转后格子的编号，求 $n$。</p>
<p>Easy Version 中旋转次数不大于 $2023$ 。</p>
<p>Hard Version 中旋转次数不大于 $1000$ 。</p>
<p>$n≤1×10^6,−10^9≤k≤10^9$ 。</p>
<h4 id="Solution-9"><a href="#Solution-9" class="headerlink" title="Solution"></a>Solution</h4><p>很不错的一道题</p>
<p>对于 Easy Version，参考 BSGS 算法，先连续 999 次 +1，然后每次 +1000，这样最多 1000 次就可以循环完一圈，然后走完一圈后必定会落在最初连续的前 1000 个格子上，我们可以通过转了多少正好可以走一圈来推算 n 的大小，最多询问 999 + 1000 次。</p>
<p>对于 Hard Version，我们在 Easy Version 基础上稍加改进，我们对于一个 $n$，可以先转 $n_0$，然后再按 G1 的方法去转，先连续转 $d$ 个 $+1$，再一直 $+d$ 直到转完一圈为止，但是这个 $n_0$ 和 $d$ 如何确定呢。我们可以先随机 $k$ 次，然后去这 $k$ 次中得到的最大的数选为 $n_0$，因为如果直接选的话，选的数可能过大或过小，若是不随机选 $k$ 个数而是连续选 $k$ 个或间隔选 $k$ 个则容易被卡掉。不过这个算法由于是一定程度上取决于随机数的，所以不一定完全正确，当 $n$ 大于 $n_0 + d^2$ 时，就无法转到一圈，此时不对。所以 $k$ 次算出的数必须有一个要大于 $n - d^2$，出错的概率为 $P(A) = (\frac{n - d^2 - 1}{n})^k,(k + 2d = 1000)$，不难发现通过改变 $n$ 和 $k$ 大小是可以改变出错概率的，当选择 $k = 400, d = 300$ 时，即使是在 $n = 10^6$ 情况下 $P(A)$ 的数量级才是 $10^{-17}$，远远小于 $1$，故可以通过此题。</p>
<p><a href="https://codeforces.com/contest/1840/submission/212058294">Code (Easy Version)</a></p>
<p><a href="https://codeforces.com/contest/1840/submission/212063730">Code (Hard Version)</a></p>
<h2 id="1848-Codeforces-Round-885-Div-2"><a href="#1848-Codeforces-Round-885-Div-2" class="headerlink" title="1848. Codeforces Round 885 (Div. 2)"></a>1848. <a href="https://codeforces.com/contest/1848">Codeforces Round 885 (Div. 2)</a></h2><h3 id="C-Vika-and-Price-Tags"><a href="#C-Vika-and-Price-Tags" class="headerlink" title="C. Vika and Price Tags"></a><a href="https://codeforces.com/contest/1848/problem/C">C. Vika and Price Tags</a></h3><h4 id="Description-10"><a href="#Description-10" class="headerlink" title="Description"></a>Description</h4><p>有 $a$, $b$ 两个长度均为 $n$ 序列， 一次变换记为 $a_i \to b_i, b_i \to \left | a_i - b_i \right | $，问是否可以经过若干次变换使得 $a$ 中所有元素全部变成 $0$。</p>
<h4 id="Solution-10"><a href="#Solution-10" class="headerlink" title="Solution"></a>Solution</h4><p>不难发现，若 $(a_i, b_i)$ 中有一个元素变为 $0$（不是 $(0, 0)$ 情况），则 $(a_i, b_i)$ 则会经历 $(0, x) \to (x, 0) \to, (x, x) \to(0, x)$ 以 $3$ 为周期的变换。</p>
<p>所以我们要求的是每个元素变为 $(x, 0)$ 的次数模 $3$ 的余数。</p>
<p>不妨设 $a &gt;&gt; b$，则变换经历 $(a, b) \to (b, a - b) \to (a - b, a - 2b) \to (a - 2b, b)$ 。不难发现每三次会经历一次周期，每次 $a \to a - 2b$。这样的话我们就可以用辗转相除法来求了。</p>
<p><a href="https://codeforces.com/contest/1848/submission/220325561">Code</a></p>
<h3 id="D-Vika-and-Bonuses"><a href="#D-Vika-and-Bonuses" class="headerlink" title="D. Vika and Bonuses"></a><a href="https://codeforces.com/contest/1848/problem/D">D. Vika and Bonuses</a></h3><h4 id="Description-11"><a href="#Description-11" class="headerlink" title="Description"></a>Description</h4><p>初始有一个数 $s$，每次可以进行两种操作，获得价值为 $s$ 的利润或让 $s \to s + (s \mod 10)$，你可以进行 $k$ 次，问 $k$ 次之后的最大价值。</p>
<h4 id="Solution-11"><a href="#Solution-11" class="headerlink" title="Solution"></a>Solution</h4><p>不难发现，个位是 $5$ / $0$ 的话，最多只能操作一次。</p>
<p>个位是 $1$ / $3$ / $7$ / $9$ 的话，操作一次后变为 $2$ / $6$ / $4$ / $8$。</p>
<p>而个位如果是 $2$ / $4$ / $6$ / $8$ 的话，则会有 $2 \to 4 \to 8 \to 6$ 的循环，我们记 $4$ 次操作为一个周期，一个周期可以让 $s \to s + 20$。</p>
<p>则题目变为求周期数 $x$，使 $(s + 20 \times x) \times (k - 4 \times x)$ 最大，但是注意，这个周期的开头我们还要枚举，因为末尾可能是 $2$ / $4$ / $6$ / $8$ 中任一数。</p>
<p><a href="https://codeforces.com/contest/1848/submission/220463956">Code</a> </p>
<h3 id="F-Vika-and-Wiki"><a href="#F-Vika-and-Wiki" class="headerlink" title="F. Vika and Wiki"></a><a href="https://codeforces.com/contest/1848/problem/F">F. Vika and Wiki</a></h3><h4 id="Description-12"><a href="#Description-12" class="headerlink" title="Description"></a>Description</h4><p>给定一个长度为 $n$ 的数组 $a$（其中 $n$ 为 $2$ 的幂次），记一次变换为将整个数组 $a_i \to a_i \oplus a_{(i + 1) \mod n}$。 </p>
<h4 id="Solution-12"><a href="#Solution-12" class="headerlink" title="Solution"></a>Solution</h4><p>手动模拟若干次后，我们发现当进行 $2^n - 1$ 次后，数组每个元素 $a_i \to \oplus_{j = 0}^{2^n}a_{i + j(\mod n)}$，利用这个性质我们可以先进行 $2 ^n - 1$ 次然后再进行 $1$ 次。这样就进行了 $2^k$ 次，时间复杂度为 $O(nlogn)$。</p>
<p><a href="https://codeforces.com/contest/1848/submission/220480211">Code</a></p>
<h2 id="1850-Codeforces-Round-886-Div-4"><a href="#1850-Codeforces-Round-886-Div-4" class="headerlink" title="1850. Codeforces Round 886 (Div. 4)"></a>1850. <a href="https://codeforces.com/contest/1850">Codeforces Round 886 (Div. 4)</a></h2><h3 id="F-We-Were-Both-Children"><a href="#F-We-Were-Both-Children" class="headerlink" title="F. We Were Both Children"></a><a href="https://codeforces.com/contest/1850/problem/F">F. We Were Both Children</a></h3><h4 id="Description-13"><a href="#Description-13" class="headerlink" title="Description"></a>Description</h4><p>$n$ 只青蛙，每次只挑 $a_i$ 的倍数的格子，要你再前 $n$ 格内放置一个陷阱，使尽可能多的青蛙跳进去。</p>
<p>$n \le 10^5$ 。</p>
<h4 id="Solution-13"><a href="#Solution-13" class="headerlink" title="Solution"></a>Solution</h4><p>如果知道第 $i$ 个格子能跳 $f_i$ 只青蛙，则可以将所有 $i$ 倍数格子全部加上 $f_i$ 。</p>
<p>故两层循环枚举即可。时间复杂度 $O(\sum_{i = 1}^n \dfrac{n}{i}) \approx O(nlnn)$ 。</p>
<p><a href="https://codeforces.com/contest/1850/submission/218473979">Code</a></p>
<h3 id="H-The-Third-Letter"><a href="#H-The-Third-Letter" class="headerlink" title="H. The Third Letter"></a><a href="https://codeforces.com/contest/1850/problem/H">H. The Third Letter</a></h3><h4 id="Description-14"><a href="#Description-14" class="headerlink" title="Description"></a>Description</h4><p>若干点分布在一系列 $x$ 轴上，告诉你若干点之间的约束条件（在 左 / 右 xx 的位置处）。然后问你这一系列条件是否合理。</p>
<h4 id="Solution-14"><a href="#Solution-14" class="headerlink" title="Solution"></a>Solution</h4><p>本题的模型可以抽象成一个有向图。但是这 $n$ 个点可能是若干连通块，不一定全是连通的。</p>
<p>每次从一个点出发，设这个点的位置是 $0$，然后标记出所有和这个点相关的点的坐标。</p>
<p>最后再把这些约束关系一一查询，看最后是否满足条件。</p>
<p><a href="https://codeforces.com/contest/1850/submission/219780470">Code</a></p>
]]></content>
      <tags>
        <tag>算法竞赛</tag>
      </tags>
  </entry>
  <entry>
    <title>CodeForces 补全计划（1851 ~ 1875）</title>
    <url>/2023/08/27/CF-Instrumentality-Project-II/</url>
    <content><![CDATA[<p>千里之行，始于足下。</p>
<span id="more"></span>
<h2 id="1860-Educational-Codeforces-Round-153-Rated-for-Div-2"><a href="#1860-Educational-Codeforces-Round-153-Rated-for-Div-2" class="headerlink" title="1860. Educational Codeforces Round 153 (Rated for Div. 2)"></a>1860. <a href="https://codeforces.com/contest/1860">Educational Codeforces Round 153 (Rated for Div. 2)</a></h2><h3 id="A-Not-a-Substring"><a href="#A-Not-a-Substring" class="headerlink" title="A. Not a Substring"></a><a href="https://codeforces.com/contest/1860/problem/A">A. Not a Substring</a></h3><h4 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h4><p>给定一个长度为 $n$ 的由 <code>(</code> 和 <code>)</code> 组成的序列，问是否存在一个长度为 $2n$ 的序列，使得新序列不包含原序列。</p>
<h4 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h4><p>水题，主要熟悉一下 stl 里 string 用法。看 <code>((()))</code> 和 <code>()()()</code> 这样的谁符合，都不符合就是 <code>NO</code>。</p>
<p>string 可以直接通过 <code>+</code> 来在尾部插入字符，<code>"()"</code> 也可以表示一个常量数组，也可以用 <code>a.find(s) == string::npos</code> 来判断 s 是否在 a 中出现。</p>
<p><a href="https://codeforces.com/contest/1860/submission/222003094">Code</a></p>
<h2 id="1861-Educational-Codeforces-Round-154-Rated-for-Div-2"><a href="#1861-Educational-Codeforces-Round-154-Rated-for-Div-2" class="headerlink" title="1861. Educational Codeforces Round 154 (Rated for Div. 2)"></a>1861. <a href="https://codeforces.com/contest/1861">Educational Codeforces Round 154 (Rated for Div. 2)</a></h2><h3 id="E-Non-Intersecting-Subpermutations"><a href="#E-Non-Intersecting-Subpermutations" class="headerlink" title="E. Non-Intersecting Subpermutations"></a><a href="https://codeforces.com/contest/1861/problem/E">E. Non-Intersecting Subpermutations</a></h3><h4 id="Description-1"><a href="#Description-1" class="headerlink" title="Description"></a>Description</h4><p>对于一个序列，取若干个长度为 $k$ 的子序列，满足这些子序列互不相交且包含 $1 \sim k$ 全部元素，定义这个序列的价值就是子序列个数的最大值。</p>
<p>给定序列长度 $n$，每个元素都是由 $1 \sim k$ 组成，问所组成序列的价值总和是多少。</p>
<h4 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h4><p>我们对于一个既定的序列，要求出他的子序列个数的方法是用贪心，使序列的右端点尽可能靠左。</p>
<p>我们设 $f_i$ 表示最后一个序列右端点在 $i$ 处的方案数<strong>（注意这里是方案数，并不是对答案的贡献数）</strong>，那么当前最后一个序列对答案的贡献是 $f_i \times k^{n - i}$。（这里的想法相当于我们每次只算一个位置 $[i - k + 1, i]$ 上的序列对总答案的影响）</p>
<p>对于方案转移，我们枚举上一个序列的右端点 $j$，那么这里有 $j \in [0, i - k]$（$j = 0$ 表示没有上一个序列）。</p>
<p>我们再引入 $g_i$ 表示对于长度是 $i$ 的一段序列，第一个合法子序列出现的位置是 $[i - k + 1, i]$ 的方案数。</p>
<p>故不难理解 $f_i = \sum f_j \times g_{i - j}$。然后问题转化为如何求 $g_i$ 数组。</p>
<p>对于 $g_i$ 而言，最后 $k$ 个位置一定是 $1 \sim k$，前 $i - k$ 位置任意选，故有 $k^{i - k} \times k!$ 的方案数。</p>
<p>但是会有不合法的方案算在内，可能会出现子序列先于 $[i - k + 1, i]$ 位置出现。</p>
<p>分类讨论，枚举可能先于出现的位置 $[j - k + 1, j]$，若 $i - j &lt;= k$ ，那么不合法的方案数相当于是 $g_j \times (i - j)!$，因为在最后 $i - j$ 个位置上，相当于每个数都只出现了一次。若 $i - j &gt; k$，那么不合法的方案数相当于是 $g_j \times k! \times k^{i - j - k}$。最后 $k$ 个位置上 $k$ 个数各出现一次，$[j + 1, i - k]$ 位置上的数字随便选。最后把不合法的情况都减掉即可。</p>
<p><a href="https://codeforces.com/contest/1861/submission/221631049">Code</a></p>
<h2 id="1862-Codeforces-Round-894-Div-3"><a href="#1862-Codeforces-Round-894-Div-3" class="headerlink" title="1862. Codeforces Round 894 (Div. 3)"></a>1862. <a href="https://codeforces.com/contest/1862">Codeforces Round 894 (Div. 3)</a></h2><h3 id="E-Kolya-and-Movie-Theatre"><a href="#E-Kolya-and-Movie-Theatre" class="headerlink" title="E. Kolya and Movie Theatre"></a><a href="https://codeforces.com/contest/1862/problem/E">E. Kolya and Movie Theatre</a></h3><h4 id="Description-2"><a href="#Description-2" class="headerlink" title="Description"></a>Description</h4><p>一段长为 $n$ 的序列 $a$，你从中至多选 $m$ 个数。设你选的数中下标最大的为 $x$，那么你选的答案要减去 $x \times d$。问该怎么选是答案最大。</p>
<h4 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h4><p>从前往后扫一遍，设下标最大的为 $i$，维护前 $k$ 大的序列以及和，算答案的时候直接减去 $i \times d$ 即可。</p>
<p>注：万一插入的第 $i$ 号元素排不到前 $k$ 大，算答案时不应该减 $i \times d$ 。但其实不用考虑，因为这种情况一定不是最优，当最大下标值小于 $i$ 的时候一定会有一个答案，前 $k$ 大值和当前一样，但减去的数要小一些，所以不会更新答案。</p>
<p><a href="https://codeforces.com/contest/1862/submission/220495907">Code</a></p>
<h3 id="F-Magic-Will-Save-the-World"><a href="#F-Magic-Will-Save-the-World" class="headerlink" title="F. Magic Will Save the World"></a><a href="https://codeforces.com/contest/1862/problem/F">F. Magic Will Save the World</a></h3><h4 id="Description-3"><a href="#Description-3" class="headerlink" title="Description"></a>Description</h4><p>若干小怪，每个小怪血量 $s_i$，你可以用 水 或 火 元素攻击，消耗等量的 水 或 火 元素。你每秒可以增加 $w$ 水元素 和 $f$ 火元素，问最快要几秒消灭全部小怪。</p>
<h4 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution"></a>Solution</h4><p>对于每个小怪，要么被火消灭，要么被水消灭，不难发现小怪总血量比较低，所以可以利用 $01$ 背包思想解决。</p>
<p><a href="https://codeforces.com/contest/1862/submission/220568374">Code</a></p>
<h3 id="G-The-Great-Equalizer"><a href="#G-The-Great-Equalizer" class="headerlink" title="G. The Great Equalizer"></a><a href="https://codeforces.com/contest/1862/problem/G">G. The Great Equalizer</a></h3><h4 id="Description-4"><a href="#Description-4" class="headerlink" title="Description"></a>Description</h4><p>初始有一段长度为 $n$ 的序列，记一次操作为将序列按升序排列然后除去相等的元素。然后设新序列元素长度 $n’$，将第一个元素加上 $n’$，第二个加上 $n’ - 1$，第三个加上 $n’ - 2$ 以此类推。</p>
<p>问最后只剩下一个元素的值。</p>
<h4 id="Solution-4"><a href="#Solution-4" class="headerlink" title="Solution"></a>Solution</h4><p>我们发现两个性质，第一，每个元素之间的相对大小不会发生变化，第二，设两两相邻元素之间的最大元素为 $max_gap$，则每次操作后 $max_gap$ 都会减一。那么最后剩下的那个元素的值为 原序列中最大的元素加上操作次数（即 $max_gap$）。</p>
<p><a href="https://codeforces.com/contest/1862/submission/220600516">Code</a></p>
]]></content>
      <tags>
        <tag>算法竞赛</tag>
      </tags>
  </entry>
  <entry>
    <title>CodeForces 补全计划（1876 ~ 1900）</title>
    <url>/2023/10/13/CF-Instrumentality-Project-III/</url>
    <content><![CDATA[<p>千里之行，始于足下。</p>
<span id="more"></span>
]]></content>
  </entry>
  <entry>
    <title>大学笔记 | 微积分</title>
    <url>/2023/06/05/Calculus/</url>
    <content><![CDATA[<p>从入门到挂科 🤦‍♀️🤦‍♂️</p>
<span id="more"></span>
<h2 id="第一章-多元函数的极限和连续性"><a href="#第一章-多元函数的极限和连续性" class="headerlink" title="第一章 多元函数的极限和连续性"></a>第一章 多元函数的极限和连续性</h2><h4 id="第一章总结"><a href="#第一章总结" class="headerlink" title="第一章总结"></a>第一章总结</h4><ol>
<li>算多元函数极限时往往不能用洛必达，可以用一元函数求极限方法对原函数进行变换然后再求，或者也可以变换为一元函数后再用洛必达</li>
<li>算极限不存在时，选择不同路径求出不同极限然后可以证出来</li>
</ol>
<h2 id="第二章-多元函数的微分学及其应用"><a href="#第二章-多元函数的微分学及其应用" class="headerlink" title="第二章 多元函数的微分学及其应用"></a>第二章 多元函数的微分学及其应用</h2><h4 id="第二章总结"><a href="#第二章总结" class="headerlink" title="第二章总结"></a>第二章总结</h4><ol>
<li><p>可偏导不一定连续，连续不一定可偏导</p>
<p> 可微可推出函数连续且可偏导，但推不出偏导数连续（即可偏导不能确定偏导连续）</p>
<p> 可偏导且偏导连续才可以推出可微</p>
<p> 任何方向的方向倒数均存在也未必可偏导</p>
<p> 可微不是方向导数存在的必要条件，但是是其存在的充分条件</p>
</li>
<li><p>证明可微即证 $\frac{\Delta Z - F_X\Delta X - F_Y\Delta Y}{\sqrt{(\Delta X)^2 + (\Delta Y)^2}}$ 是否趋向于 $0$</p>
<p> 证明连续就是证左右极限相等且存在，证明偏导数存在就是证明函数关于每个变量的偏导数均存在</p>
</li>
<li><p>复合函数求导法则</p>
</li>
<li><p>隐函数求导 $\frac{\partial z}{\partial x} = - \frac{F’_x(x, y, z)}{F’_z(x, y)}$</p>
</li>
<li><p>方向导数 $\frac{\partial f}{\partial l} = \frac{\partial f}{\partial x}cos \alpha + \frac{\partial f}{\partial y}cos \beta$，梯度 $grad f(x, y) = \frac{\partial f}{\partial x}i + \frac{\partial f}{\partial y}j$，且二者关系 $\frac{\partial f}{\partial l} | _{max} = |grad f(x, y)| = \sqrt{(\frac{\partial f}{\partial x})^2 + (\frac{\partial f}{\partial y})^2}$</p>
</li>
<li><p>空间曲线的切线和法平面，曲面的切平面和法线</p>
</li>
<li><p>二元函数取得极值的充分，必要条件 和 条件极值</p>
</li>
<li><p>拉格朗日乘数法</p>
</li>
</ol>
<h2 id="第三章-重积分"><a href="#第三章-重积分" class="headerlink" title="第三章 重积分"></a>第三章 重积分</h2><h4 id="第三章总结"><a href="#第三章总结" class="headerlink" title="第三章总结"></a>第三章总结</h4><ol>
<li><p>二重积分：直角坐标系下分别积分即可，若利用极坐标，$dxdy = rdrd\theta$</p>
</li>
<li><p>三重积分：先一后二 / 先二后一     </p>
<p> ​                    利用柱面坐标：$dxdydz = r d\theta drdz$</p>
<p> ​                    利用球面坐标：$dxdydz = r^2sin\phi d\theta d\phi dr$</p>
</li>
</ol>
<h2 id="第四章-第一型曲线积分与曲面积分"><a href="#第四章-第一型曲线积分与曲面积分" class="headerlink" title="第四章 第一型曲线积分与曲面积分"></a>第四章 第一型曲线积分与曲面积分</h2><h4 id="第四章总结"><a href="#第四章总结" class="headerlink" title="第四章总结"></a>第四章总结</h4><ol>
<li>$\int_Lf(x, y)ds = \int_\alpha^\beta f(x(t), y(t))\sqrt{[x’(t)]^2 + [y’(t)]^2}dt$</li>
<li><p>$\int_Lf(x, y)ds = \int_a^b f(x, y(x))\sqrt{1 + [y’(x)]^2}dx$</p>
</li>
<li><p>$\int_Lf(x, y)ds = \int_\alpha^\beta f(r(\theta)cos\theta, r(\theta)sin\theta)\sqrt{r^2(\theta) + [r’(\theta)]^2}d\theta$</p>
</li>
<li><p>$\iint_\Sigma f(x, y, z)ds = \iint_{D_{xy}} f(x, y, z(x, y))\sqrt{1 + {z’_x}^2 + {z’_y}^2}dxdy$</p>
</li>
</ol>
<h2 id="第五章-第二型曲线积分和曲面积分"><a href="#第五章-第二型曲线积分和曲面积分" class="headerlink" title="第五章 第二型曲线积分和曲面积分"></a>第五章 第二型曲线积分和曲面积分</h2><h3 id="S-5-1-第二型曲线积分"><a href="#S-5-1-第二型曲线积分" class="headerlink" title="$\S 5.1$ 第二型曲线积分"></a>$\S 5.1$ 第二型曲线积分</h3><ul>
<li><p>概念 </p>
<p>  形如 $\int_LP(x, y)dx + Q(x, y)dy$ 的积分（注意第二型曲线是有方向的）</p>
</li>
<li><p>计算</p>
<p>  $\int_LP(x, y)dx + Q(x, y)dy = \int_L[P(x(t), y(y))x’(t)+Q(x(t), y(t))y’(t)]dt$</p>
<p>  第一二型曲线的关系 $\int_LP(x, y)dx + Q(x, y)dy = \int_L(Pcos\alpha + Qcos\beta)ds $</p>
</li>
</ul>
<h3 id="S-5-2-格林公式"><a href="#S-5-2-格林公式" class="headerlink" title="$\S 5.2$ 格林公式"></a>$\S 5.2$ 格林公式</h3><ul>
<li><p>单连通域与复连通域（没洞和有洞的区别）</p>
</li>
<li><p>区域的正向边界</p>
<p>  外边界顺时针为正向，内边界逆时针为正向（若沿着边界正向方向走，则该边界始终在此人左侧）</p>
</li>
<li><p>格林公式</p>
<p>  $\oint_LPdx + Qdy = \iint_D(\frac{\partial Q}{\partial x} - \frac{\partial P}{\partial y})dxdy$ （仅针对 $D$ 既是 $X$ 型域又是 $Y$ 型域）</p>
<p>  特殊的，利用格林公式算面积 $\iint_Ddxdy = \frac{1}{2}\oint_Lxdy - ydx$</p>
</li>
<li><p>路径无关</p>
<p>  若 $G$ 是一个单连通域且 $\frac{\partial Q}{\partial x} = \frac{\partial P}{\partial y}$ 在 $G$ 内恒成立（充要条件），则路径无关</p>
</li>
<li><p>全微分求原函数</p>
<p>  若 $\frac{\partial Q}{\partial x} = \frac{\partial P}{\partial y}$ 在单连通域 $G$ 内恒成立， 则存在 $du = Pdx + Qdy$</p>
<p>  $u(x, y) = \int_{(x_0, y_0)}^{(x, y)}P(x, y)dx + Q(x, y)dy$</p>
</li>
</ul>
<h3 id="S-5-3-第二型曲面积分"><a href="#S-5-3-第二型曲面积分" class="headerlink" title="$\S 5.3$ 第二型曲面积分"></a>$\S 5.3$ 第二型曲面积分</h3><ul>
<li><p>本节讨论均是光滑有向双侧曲面</p>
</li>
<li><p>概念</p>
<p>  形如 $\iint_{\sum}P(x, y, z)dydz + Q(x, y, z)dzdx + R(x, y, z)dxdy$</p>
</li>
<li><p>计算</p>
<ol>
<li><p>$\iint_{\sum}R(x, y, z)dxdy = \pm\iint_{D_{xy}}R(x, y, z(x, y))dxdy$</p>
</li>
<li><p>$\iint_{\sum}Pdydz + Qdzdx + Rdxdy = \iint_{\sum}[P(-z_x) + Q(-z_y) + R]dxdy$</p>
</li>
<li><p>$\unicode{8751}_\sum Pdydz + Qdzdx + Rdxdy = \iiint_\Omega(\frac{\partial P}{\partial x} + \frac{\partial Q}{\partial y} + \frac{\partial R}{\partial z})dV$</p>
</li>
</ol>
</li>
</ul>
<h3 id="S-5-4-高斯公式"><a href="#S-5-4-高斯公式" class="headerlink" title="$\S 5.4$ 高斯公式"></a>$\S 5.4$ 高斯公式</h3><ul>
<li><p>高斯公式</p>
<p>  设 $\sum$ 是空间闭区域 $\Omega$ 的边界曲面，取外侧且 $P,Q,R$ 在 $\Omega$ 内有连续偏导数</p>
<p>  则 $ \iiint_{\Omega}(\frac{\partial P}{\partial x} + \frac{\partial Q}{\partial y} + \frac{\partial R}{\partial z})dV = \unicode{8751}_{\sum}Pdydz + Qdzdx + Rdxdy $</p>
</li>
<li><p>通量与散度</p>
<p>  $\vec A(x, y, z) = P(x, y, z)\vec i + Q(x, y, z)\vec j + R(x, y, z)\vec k$</p>
<p>  $d\vec S = \vec e_ndS = (cos \alpha, cos\beta, cos\gamma)dS$</p>
<ul>
<li><p>通量</p>
<p>  $\phi = \iint_{\sum}\vec A d\vec S = \iint_{\sum} Pdydz + Qdzdx + Rdxdy$</p>
</li>
<li><p>散度</p>
<p>  $div \vec A = \frac{\partial P}{\partial x} + \frac{\partial Q}{\partial y} + \frac{\partial R}{\partial z}$</p>
</li>
</ul>
</li>
</ul>
<h3 id="S-5-5-斯托克斯公式"><a href="#S-5-5-斯托克斯公式" class="headerlink" title="$\S 5.5$ 斯托克斯公式"></a>$\S 5.5$ 斯托克斯公式</h3><ul>
<li><p>斯托克斯公式</p>
<p>  设有向闭曲线 $\tau$ 是有向曲面 $\sum$ 的边界，且满足</p>
<ol>
<li>$\tau$ 和 $\sum$ 的方向符合右手规则</li>
<li><p>$P(x, y, z), Q(x, y, z), R(x, y, z)$ 在包含 $\sum$ 的区域内有连续偏导数</p>
<p>那么    </p>
<script type="math/tex; mode=display">
\begin{aligned} \oint_{\tau}Pdx + Qdy + Rdz = \iint_{\sum}( \frac{\partial R}{\partial y} - \frac{\partial Q}{\partial z})dydz + ( \frac{\partial P}{\partial z} - \frac{\partial R}{\partial x})dxdz + ( \frac{\partial Q}{\partial x} - \frac{\partial P}{\partial y})dydx \\ = \iint_{\sum}\begin{vmatrix}dydz & dzdx & dxdy \newline \frac{\partial}{\partial x} & \frac{\partial}{\partial y} & \frac{\partial}{\partial z} \\ P & Q & R \end{vmatrix} \end{aligned}</script></li>
</ol>
</li>
<li><p>环流量与旋度</p>
<p>  $\vec A(x, y, z) = P(x, y, z)\vec i + Q(x, y, z)\vec j + R(x, y, z)\vec k$</p>
<ul>
<li><p>环流量</p>
<p>  $\oint_{\tau}\vec A d\vec S = \oint_{\tau} Pdx + Qdy + Rdz$</p>
</li>
<li><p>旋度</p>
<p>  $rot \vec A = (\frac{\partial R}{\partial y} - \frac{\partial Q}{\partial z})\vec i + ( \frac{\partial P}{\partial z} - \frac{\partial R}{\partial x})\vec j + ( \frac{\partial Q}{\partial x} - \frac{\partial P}{\partial y})\vec k$</p>
</li>
</ul>
</li>
</ul>
<h2 id="第六章-无穷级数"><a href="#第六章-无穷级数" class="headerlink" title="第六章 无穷级数"></a>第六章 无穷级数</h2><h3 id="S-6-1-数项级数的概念和性质"><a href="#S-6-1-数项级数的概念和性质" class="headerlink" title="$\S 6.1$ 数项级数的概念和性质"></a>$\S 6.1$ 数项级数的概念和性质</h3><ul>
<li><p>数项级数， 一般项， 部分和， 部分和数列， 敛散性</p>
</li>
<li><p>原级数加括号后所得新级数发散， 则原级数也发散， 但若所得新级数收敛， 原级数未必收敛</p>
</li>
<li><p>级数收敛的必要条件是 $\lim_{n \to \infty} u_n = 0$</p>
</li>
<li><p>级数乘以非零数敛散性不变， 级数前面去掉有限非零项数敛散性也不变</p>
</li>
<li><p>几何级数 $\sum_{n = 0}^{\infty} aq^n = a + aq + aq^2 +\cdots + aq^n + \cdots$ </p>
<p>  调和级数 $\sum_{n = 1}^{\infty} \frac{1}{n} = 1 + \frac{1}{2} + \cdots + \frac{1}{n} + \cdots$</p>
<p>  $p$ 级数 $\sum_{n = 1}^{\infty} \frac{1}{n^p} = 1 + \frac{1}{2^p} + \cdots + \frac{1}{n^p} + \cdots$ (并且 $p \le 1$ 时收敛， $p &gt; 1$ 时发散)</p>
<p>  交错级数 $\sum_{n = 1}^{\infty} (-1)^nu_n$</p>
</li>
</ul>
<h3 id="S-6-2-正项级数的敛散性"><a href="#S-6-2-正项级数的敛散性" class="headerlink" title="$\S 6.2 $ 正项级数的敛散性"></a>$\S 6.2 $ 正项级数的敛散性</h3><ul>
<li><p>比较判别法</p>
<p>  正项级数 $\sum_{n = 1}^{\infty}u_n$ ,$\sum_{n = 1}^{\infty} v_n$ ,且当 $n &gt; N$ 时， $u_n \le kv_n$</p>
<ul>
<li>若 $u_n$ 发散，则 $v_n$ 发散</li>
<li><p>若 $v_n$ 收敛，则 $u_n$ 收敛</p>
<p>使用该方法时常用适当放缩或借助几何级数，调和级数，p级数作为参考</p>
<p>比较判别法的极限形式</p>
<p>正项级数 $\sum_{n = 1}^{\infty}u_n$ ,$\sum_{n = 1}^{\infty} v_n$ ,且 $\lim_{n \to \infty} \frac{u_n}{v_n} = l$</p>
</li>
<li><p>若 $l = \infty$ , 且 $v_n$ 发散， $u_n$ 发散，</p>
</li>
<li>若 $l = 0$ , 且 $v_n$ 收敛，则 $u_n$ 收敛</li>
<li>若 $0 &lt; l &lt; \infty$ , 则 $u_n$，$v_n$ 敛散性相同</li>
</ul>
</li>
<li><p>比值判别法（d’Alembert 判别法）</p>
<p>  正项级数 $\sum_{n = 1}^{\infty}u_n$  ,且 $\lim_{n \to \infty} \frac{u_{n + 1}}{u_n} = \rho$</p>
<ul>
<li>若 $\rho &lt; 1$ ,则 $u_n$ 收敛，</li>
<li>若 $\rho &gt; 1$ 或 $\rho = \infty$ , 则 $u_n$ 发散</li>
<li>若$\rho = 1$ , 则$u_n$ 敛散性不确定</li>
</ul>
</li>
<li><p>根植判别法（Cauchy 判别法）</p>
<p>  正项级数 $\sum_{n = 1}^{\infty}u_n$  ,且 $\lim_{n \to \infty} \sqrt[n]{u_n} = \rho$</p>
<ul>
<li>若 $\rho &lt; 1$ ,则 $u_n$ 收敛，</li>
<li>若 $\rho &gt; 1$ 或 $\rho = \infty$ , 则 $u_n$ 发散</li>
<li>若$\rho = 1$ , 则$u_n$ 敛散性不确定</li>
</ul>
</li>
</ul>
<h3 id="S-6-3-任意项级数"><a href="#S-6-3-任意项级数" class="headerlink" title="$\S 6.3$ 任意项级数"></a>$\S 6.3$ 任意项级数</h3><ul>
<li><p>Cauchy 收敛准则</p>
<p>  数项级数 $\sum_{n = 1}^{\infty} u_n$ 收敛的充要条件时$\forall \varepsilon &gt; 0, \exists$ 正整数 $N$， 当 $n &gt; N$ 时， 对一切正整数 $p$ 有 $|u_{n + 1} + \cdots + u_{n + p}| &lt; \varepsilon$  </p>
</li>
<li><p>Leibniz 判别法 </p>
<p>  若交错级数满足 $\sum_{n = 1}^{\infty} (-1)^{n + 1}u_n(u_n &gt; 0)$ 满足：</p>
<ul>
<li>$u_n \ge u_{n + 1}(n = 1, 2, 3, \cdots)$</li>
<li><p>$lim_{n \to \infty} u_n = 0$</p>
<p>则交错级数 $\sum_{n = 1}^{\infty} (-1)^{n + 1}u_n$ 收敛（注：这是充分条件，即使不满足也不能证明级数发散）</p>
<p>常用结论：$\sum_{n = 1}^{\infty} (-1)^{n + 1}\frac{1}{n}$ 收敛         </p>
</li>
</ul>
</li>
<li><p>绝对收敛与条件收敛</p>
<p>  各项符号无规律级数（如 $\sum_{n = 1} ^{\infty} \frac{sinn\alpha}{n^2}$）称为任意项级数</p>
<p>  若$\sum_{n = 1}^{\infty} |u_n|$ 收敛，则称级数 $\sum_{n = 1}^{\infty} u_n$ 绝对收敛</p>
<p>  若 $\sum_{n = 1}^{\infty} u_n$ 收敛， $\sum_{n = 1}^{\infty} |u_n|$ 发散，则称级数 $\sum_{n = 1}^{\infty} u_n$ 条件收敛</p>
<p>  绝对收敛则必收敛</p>
</li>
</ul>
<h3 id="S-6-4-函数项级数"><a href="#S-6-4-函数项级数" class="headerlink" title="$\S 6.4$ 函数项级数"></a>$\S 6.4$ 函数项级数</h3><ul>
<li>函数项级数 $\sum_{n = 1}^{\infty} u_n(x)$， 定义区间 $I$<ul>
<li>对 $x_0 \in I$， 若 $\sum_{n = 1}^{\infty} u_n(x)$ 收敛，则称 $x_0$ 为收敛点，反之称为发散点</li>
<li>发散点组成的全体称为发散域，收敛点组成的全体称为收敛域</li>
<li>求收敛域可以用比值或根式判别法来求</li>
<li>和函数 $s(x) = \sum_{n = 1}^{\infty}u_n(x), x \in$ 收敛域</li>
<li>余项 $R_n(x) = s(x) - s_n(x), x \in$ 收敛域</li>
</ul>
</li>
</ul>
<h3 id="S-6-5-幂级数"><a href="#S-6-5-幂级数" class="headerlink" title="$\S 6.5$ 幂级数"></a>$\S 6.5$ 幂级数</h3><ul>
<li><p>$\sum_{n = 0}^{\infty} a_n(x-x_0)^n$ 称为在点 $x_0$ 的幂级数 （一下研究均是 $x_0 = 0$ 的情况）</p>
</li>
<li><p>$Abel$ 定理</p>
<ul>
<li><p>若 $\sum_{n = 0}^{\infty} a_nx^n$ 在 $x = x_0$ 点收敛，则满足 $|x| &lt; |x_0|$ 的一切 $x$，$\sum_{n = 1}^{\infty}a_nx^n$ 绝对收敛</p>
</li>
<li><p>若 $\sum_{n = 0}^{\infty} a_nx^n$ 在 $x = x_0$ 点发散，则满足 $|x| &gt; |x_0|$ 的一切 $x$，$\sum_{n = 1}^{\infty}a_nx^n$ 发散</p>
<p>  由 $Abel$ 定理可知，幂级数 $\sum_{n = 1}^{\infty}a_nx^n$ 的收敛域是以原点为中心的区间，收敛半径 $R$ 记为收敛域长度的一半，$(-R, R)$ 记为收敛区间，不是收敛域，该收敛区间加上收敛的端点才是收敛域</p>
</li>
</ul>
</li>
<li><p>计算收敛半径 $R$ （仅在不缺项的时候可以用，缺项情况要用比值判别法或根式判别法来求）</p>
<p>  若 $lim_{n \to \infty}|\frac{a_{n+1}}{a_n}| = \rho$ 或 $\lim_{n \to \infty} \sqrt[n]{|a_n|} = \rho$ 则收敛半径 $R = \frac{1}{\rho}$ 特别的，$\rho = 0$ 时 $ R = \infty$ $\rho = \infty$ 时 $R = 0$</p>
</li>
<li><p>幂级数代数运算</p>
<ul>
<li>幂级数相加可逐项分别相加，且新级数的收敛半径 $R \ge min\{R_1, R_2\}$ （但 $R_1 \ne R_2$ 时，必有 $R = min\{R_1, R_2\}$）</li>
<li>幂级数相乘，新级数的收敛半径 $R \ge min\{R_1, R_2\}$ </li>
</ul>
</li>
<li><p>幂级数的和函数 $s( x )$</p>
<ul>
<li>$s(x)$ 在收敛域内连续</li>
<li>收敛域内 $s(x)$ 可微， 且对 $s(x)$ 求导可以先对各项求导再相加</li>
<li>收敛域内 $s(x)$ 可积， 且对 $s(x)$ 积分可以先对各项积分再相加</li>
</ul>
</li>
<li><p>泰勒级数</p>
<ul>
<li><p>$f(x)$ 在 $x_0$ 处的泰勒级数为 $\sum_{n = 0}^{\infty} \frac{f^{(n)}(x_0)}{n!}(x-x_0)^n$</p>
</li>
<li><p>函数能展开成幂级数的必要条件是在区间 $I$ 内有任意阶导数， 但此时写出的泰勒级数未必收敛于 $f(x)$</p>
</li>
<li><p>只有满足 $f(x)$ 在 $x_0$ 某一邻域内有任意阶导数，并且存在 $R &gt; 0$，使 $|x - x_0| &lt; R$ 时，$\lim_{n \to \infty} R_n(x) = \lim_{n \to \infty} \frac{f^{(n + 1)}(\xi)}{(n + 1)!}(x-x_0)^{n + 1} = 0$ ，这时 $f(x)$ 才能在邻域 $U(x_0, R)$ 内展开成泰勒级数</p>
</li>
<li><p>特殊的，当 $x_0 = 0$ 时，$f(x)$ 的泰勒级数为 $\sum_{n = 0}^{\infty} \frac{f^{(n)}(0)}{n!}x^n$ 称为 $f(x)$ 的麦克劳林级数或 $x$ 的幂级数</p>
</li>
<li><p>常用幂级数展开式</p>
<script type="math/tex; mode=display">
  \begin{gather*}
  \frac{1}{1-x} = \sum_{n = 0}^{\infty}x^{n},\ \frac{1}{1+x} = \sum_{n = 0}^{\infty}(-1)^nx^{n}\ (-1 < x < 1)
  \newline e^x = \sum_{n = 0}^{\infty}\frac{x^n}{n!}\ (-\infty < x < \infty)
  \newline \sin x = \sum_{n = 0}^{\infty}(-1)^n\frac{x^{2n+1}}{(2n+1)!}\ (-\infty < x < \infty)
  \newline \cos x = \sum_{n = 0}^{\infty}(-1)^n\frac{x^{2n}}{(2n)!}\ (-\infty < x < \infty)
  \newline \ln(1 + x) = \sum_{n = 0}^{\infty} (-1)^n\frac{x^{n + 1}}{n + 1}\ (-1 < x \le 1)
  \newline \arctan x = \sum_{n = 0}^{\infty} (-1)^n\frac{x^{2n + 1}}{2n + 1}\ (-1 \le x \le 1)
  \end{gather*}</script><p>  值得注意的是，若 $f(x)$ 能展开成幂级数，那么展开方式必定是唯一的，而且一定是泰勒级数</p>
</li>
</ul>
</li>
<li><p>欧拉公式</p>
<ul>
<li>$e^{ix} = cosx + isinx$ </li>
<li>$cos x = \frac{e^{ix} + e^{-ix}}{2}$，$sin x = \frac{e^{ix} - e^{-ix}}{2i}$</li>
<li>$e^{i\pi} + 1 = 0$  <strong>上帝创造的公式！！！</strong></li>
</ul>
</li>
</ul>
<h3 id="S-6-6-傅里叶级数"><a href="#S-6-6-傅里叶级数" class="headerlink" title="$\S 6.6$ 傅里叶级数"></a>$\S 6.6$ 傅里叶级数</h3><ul>
<li><p>三角函数系 </p>
<p>  $1, sinx, cosx, cos2x, sin2x, \cdots, cosnx, sinnx, \cdots$ 其中任意两个相异函数在区间$[-\pi, pi]$ 上的积分等于 $0$，称为三角函数系的正交性</p>
</li>
<li><p>函数展开成傅里叶级数</p>
<p>  设 $f(x)$ 为周期为 $2\pi$ 的可积函数，若 $f(x)$ 能展开成三角级数，即$f(x) = \frac{1}{2}a_0+\sum_{n = 1}^{\infty}(a_ncosnx + b_nsinnx)$</p>
<p>  则 $a_k = \frac{1}{\pi}\int_{-\pi}^{\pi}f(x)coskxdx$，$b_k = \frac{1}{\pi}\int_{-\pi}^{\pi}f(x)sinkxdx$</p>
<p>  $f(x)$ 的傅里叶级数记为 $f(x) \sim \frac{a_0}{2} + \sum_{n = 1}^{\infty}(a_ncosnx+b_nsinnx)$，其中 $a_n$，$b_n$ 称为傅里叶系数，注意这里的 $\sim$ 表示 $f(x)$ 和它的傅里叶系数有某种联系关系，这个级数本身可能收敛，可能不收敛，收敛也未必收敛于 $f(x)$</p>
</li>
<li><p>狄利克雷收敛定理</p>
<p>  设 $f(x)$ 为周期为 $2\pi$ 的可积函数，若 $f(x)$ 在 $[-\pi,\pi]$ 上满足狄利克雷条件</p>
<ul>
<li>连续或只有有限个第一类间断点</li>
<li><p>只有有限个极值点</p>
<p><strong>直观来说就是函数图像在周期内，连续或分段连续且不作无限次振动</strong>，则 $f(x)$ 的傅里叶级数收敛，在 $f(x)$ 的<strong>连续点</strong>，级数收敛于 $f(x)$，而对于 $f(x)$ 的间断点 $x$，级数收敛于间断点处左右极限的中点（注意在满足狄利克雷收敛定理条件下是一定会收敛的，只是收敛会不会收敛于 $f(x)$ 不确定）</p>
</li>
</ul>
</li>
<li><p>周期延拓</p>
</li>
<li><p>奇函数的傅里叶级数只有正弦项，又称为正弦级数</p>
<p>  偶函数的傅里叶级数只有余弦项，又称为余弦级数</p>
</li>
<li><p>周期为 $2l$ 的函数展成傅里叶级数</p>
<p>  $f(x) \sim \frac{a_0}{2} + \sum_{n = 1}^{\infty}(a_ncosn\frac{\pi}{l}x + b_nsinn\frac{\pi}{l}x)$</p>
<ul>
<li>$a_n = \frac{1}{l}\int^{l}_{-l}f(x)cosn\frac{\pi}{l}xdx    $</li>
<li><p>$b_n = \frac{1}{l}\int^{l}_{-l}f(x)sinn\frac{\pi}{l}xdx    $</p>
<p>只在 $[0, l]$ 上有定义的函数，展开成正弦级数或余弦级数，需做奇延拓或偶延拓</p>
<p>和差化积公式参考如下</p>
<script type="math/tex; mode=display">
\begin{gather}
{\displaystyle \sin \alpha +\sin \beta =2\sin { \alpha +\beta \over 2}\cos { \alpha -\beta \over 2}} \\ {\displaystyle \sin \alpha -\sin \beta =2\cos {\alpha +\beta \over 2}\sin {\alpha -\beta \over 2}} \\ {\displaystyle \cos \alpha +\cos \beta =2\cos {\alpha +\beta \over 2}\cos {\alpha -\beta \over 2}} \\ {\displaystyle \cos \alpha -\cos \beta =-2\sin {\alpha +\beta \over 2}\sin {\alpha -\beta \over 2}}
\\ \newline \newline {\displaystyle \sin \alpha \cos \beta ={\sin(\alpha +\beta )+\sin(\alpha -\beta ) \over 2}} \\ {\displaystyle \cos \alpha \sin \beta ={\sin(\alpha +\beta )-\sin(\alpha -\beta ) \over 2}} \\ {\displaystyle \cos \alpha \cos \beta ={\cos(\alpha +\beta )+\cos(\alpha -\beta ) \over 2}} \\ {\displaystyle \sin \alpha \sin \beta =-{\cos(\alpha +\beta )-\cos(\alpha -\beta ) \over 2}}
\end{gather}</script></li>
</ul>
</li>
</ul>
<h2 id="第七章-常微分方程"><a href="#第七章-常微分方程" class="headerlink" title="第七章 常微分方程"></a>第七章 常微分方程</h2><h4 id="第七章总结"><a href="#第七章总结" class="headerlink" title="第七章总结"></a>第七章总结</h4><ol>
<li>本章研究的方程主要有两种：一阶线性微分方程 和 高阶微分方程</li>
<li><p>对于一阶线性微分方程</p>
<ul>
<li>首先考虑是不是全微分方程，若满足 $\frac{\partial P}{\partial y} = \frac{\partial Q}{\partial y}$，则化为 $u(x, y) = 0$ 的形式</li>
<li>不是全微分方程就化为 $\frac{dy}{dx} = \cdots$ 的形式，然后几种情况无非是$\frac{dy}{dx} = f(x)g(x),\frac{dy}{dx} = \varphi(\frac{dy}{dx}),\frac{dy}{dx} = p(x)y,\frac{dy}{dx} = p(x)y + q(x),\frac{dy}{dx} = p(x)y + q(x)y^n$ 这五种形式，其中只有第四，五种要稍微记一下，伯努利方程（第五种）稍微转化一下就是第四种</li>
<li>化成 $\frac{dy}{dx} = \cdots$ 比较复杂的话就化为 $\frac{dx}{dy} = \cdots$形式</li>
</ul>
</li>
<li><p>对于高阶方程</p>
<ul>
<li>可降阶方程本质就是不断积分</li>
<li>高阶齐次方程记一下特征根的形式，掌握二阶齐次即可，高阶只需了解</li>
<li>高阶非齐次方程也是主要记一下两种特征根形式，欧拉方程单独记一下</li>
</ul>
</li>
</ol>
<h3 id="S-7-1-常微分方程的概念"><a href="#S-7-1-常微分方程的概念" class="headerlink" title="$\S 7.1$ 常微分方程的概念"></a>$\S 7.1$ 常微分方程的概念</h3><ul>
<li><p>微分方程，常微分方程，偏微分方程，方程的阶，线性微分方程，非线性微分方程，显式通解，隐式通解，特解，初始条件，初值问题（Cauchy问题）</p>
</li>
<li><p>方程通解的特征是含有任意常数，任意常数个数与方程阶数相同</p>
<p>  值得注意的是，<strong>通解未必是方程的全部解</strong></p>
</li>
</ul>
<h3 id="S-7-2-可分离变量的方程"><a href="#S-7-2-可分离变量的方程" class="headerlink" title="$\S 7.2$ 可分离变量的方程"></a>$\S 7.2$ 可分离变量的方程</h3><ul>
<li><p>可分离变量的方程</p>
<p>  形如 $\frac{dy}{dx} = f(x)g(x)$ ，方法是 $y$ ，$x$ 分别放在等式两边分别积分运算</p>
<p>  方程特征是化为一般式后，方程右端可分解为只含 $x$ 和只含 $y$ 的两个函数乘积</p>
</li>
<li><p>齐次方程</p>
<p>  形如 $\frac{dy}{dx} = \varphi(\frac{dy}{dx})$ ，方法是令 $u = \frac{y}{x}$，再化为可分离变量方程求解</p>
<p>  方程特征是各项次数均相同</p>
</li>
</ul>
<h3 id="S-7-3-一阶线性微分方程"><a href="#S-7-3-一阶线性微分方程" class="headerlink" title="$\S 7.3$ 一阶线性微分方程"></a>$\S 7.3$ 一阶线性微分方程</h3><p>一阶线性微分方程的标准形式为 $\frac{dy}{dx} = p(x)y + q(x)$，若 $q(x) \equiv 0$，称为齐次线性方程，若 $q(x) \not\equiv 0$，则称为非齐次方程</p>
<ul>
<li><p>一阶齐次线性方程</p>
<p>  形如 $\frac{dy}{dx} = p(x)y$ ，通解为 $y = Ce^{\int p(x)dx}$</p>
</li>
<li><p>一阶非齐次线性方程</p>
<p>  形如 $\frac{dy}{dx} = p(x)y + q(x)$ ，通解为 $y = e^{\int p(x)dx}(\int q(x)e^{-\int p(x)dx}dx + C)$</p>
</li>
<li><p>伯努利（Bernoulli）方程</p>
<p>  形如 $\frac{dy}{dx} = p(x)y + q(x)y^n$ ，解法是方程两边除以 $y^n$，再凑微分化为一阶非齐次线性方程</p>
</li>
</ul>
<h3 id="S-7-4-全微分方程"><a href="#S-7-4-全微分方程" class="headerlink" title="$\S 7.4$ 全微分方程"></a>$\S 7.4$ 全微分方程</h3><ul>
<li><p>全微分方程</p>
<ul>
<li><p>若 $P(x, y),Q(x, y)$ 在单连通区域 $D$ 内有连续的一阶偏导数，且 $\frac{\partial P}{\partial y} = \frac{\partial Q}{\partial x}$ 则方程， $P(x, y)dx + Q(x, y)dy = 0$ 称为全微分方程</p>
</li>
<li><p>对于全微分方程必有 $u(x, y)$ 使 $du(x, y) = P(x, y)dx + Q(x, y)dy = 0$ 从而 $u(x, y) = C$</p>
</li>
<li>求法 $u(x, y) = \int^x_{x_0}P(x, y_0)dx + \int^y_{y_0}Q(x, y)dy = \int^y_{y_0}Q(x_0, y)dy + \int^x_{x_0}P(x, y)dx$ ，通解 $u(x, y) = C$</li>
</ul>
</li>
</ul>
<h3 id="S-7-5-可降阶的高阶方程"><a href="#S-7-5-可降阶的高阶方程" class="headerlink" title="$\S 7.5$ 可降阶的高阶方程"></a>$\S 7.5$ 可降阶的高阶方程</h3><ul>
<li><p>$y^{(n)} = f(x)$ 型方程</p>
<p>  不断积分，方程求特解时，任意常数出现一个确定一个</p>
</li>
<li><p>$y’’ = f(x, y’)$ 型方程</p>
<p>  设 $y’ = p(x)$ 原方程可化为 $\frac{dp}{dx} = f(x, p)$ 再用一阶方程的解法求出通解，最后积分得出 $y$ 的值</p>
</li>
<li><p>$y’’ = f(y,y’)$</p>
<p>  设 $y’ = p(y)$，则原方程可化为 $p\frac{dp}{dy} = f(y, p)$，再用一阶方程解法求通解</p>
</li>
</ul>
<h3 id="S-7-6-高阶齐次线性方程"><a href="#S-7-6-高阶齐次线性方程" class="headerlink" title="$\S 7.6 $ 高阶齐次线性方程"></a>$\S 7.6 $ 高阶齐次线性方程</h3><ul>
<li><p>方程的线性无（相）关以及判定</p>
</li>
<li><p>线性齐次方程组解的结构</p>
</li>
<li><p>二阶常系数齐次线性方程 $y’’+py’+qy=0$</p>
<ul>
<li>特征方程，特征根</li>
<li>特征方程有两个不同实根的情况，$y = C_1e^{r_1x} + C_2e^{r_2x}$</li>
<li>特征方程有两个相同实根的情况，$y = (C_1 + C_2x)e^{r_1x}$</li>
<li>若特征方程有一对共轭复根 $r = \alpha \pm i \beta$ 的情况，$y = e^{\alpha x}(C_1cos\beta x + C_2 sin \beta x)$</li>
</ul>
</li>
<li><p>$n$ 阶常系数齐次线性方程</p>
<p>  大致同二阶情况，每一个根都对应一个特解，$k$ 重根算 $k$ 个根</p>
<ul>
<li><p>$k$ 重实根 $r$ 对应 $k$ 个特解：$x^0e^{rx},\cdots,x^{k - 1}e^{rx}$</p>
</li>
<li><p>$k$ 重复数根 $r = \alpha \pm i \beta$ 对应的 $2k$ 个特解：</p>
<p>  ​    $x^0e^{\alpha x}cos\beta x,\cdots,x^{k - 1}e^{\alpha x}cos\beta x$ </p>
<p>  ​    $x^0e^{\alpha x}sin\beta x,\cdots,x^{k - 1}e^{\alpha x}sin\beta x$ </p>
</li>
</ul>
</li>
</ul>
<h3 id="S-7-7-高阶非齐次线性方程"><a href="#S-7-7-高阶非齐次线性方程" class="headerlink" title="$\S 7.7$ 高阶非齐次线性方程"></a>$\S 7.7$ 高阶非齐次线性方程</h3><p> $y’’ + py’ + qy = f(x)$</p>
<ul>
<li><p>非线性齐次方程组解的结构</p>
</li>
<li><p>$f(x) = P_m(x)e^{\lambda x}$</p>
<p>  设特解 $y^*=Q(x)e^{\lambda x}$，$Q(x)$ 为多项式，化简得 $Q’’(x)+(2\lambda + p)Q’(x) + (\lambda ^ 2 + p \lambda + q)Q(x) = P_m(x)$，再分析出 $Q(x)$ 的阶数之后用待定系数法求解</p>
<p>  $y^*=x^lQ_m(x)e^{\lambda x}$，$\lambda$ 是特征方程的 $l$ 重根 </p>
</li>
<li><p>$f(x)=e^{\lambda x}[P_l(x)cos\omega x +P_n(x)sin\omega x])$</p>
<p>  特解 $y^*=x^ke^{\lambda x}[Q_m^{(1)}(x)cos\omega x + Q_m^{(2)}(x)sin\omega x],m = \max\{l, n\}$      </p>
<p>  其中 $k = 0,1$（$\lambda + i\omega$ 不是特征根时 $k$ 是 $0$，反之 $k$ 是 $1$)，这里 $Q_m^{(1)}$ 和 $Q_m^{(2)}$ 是待定的，只用知道他们是 $m$ 次多项式即可，剩下的用待定系数法求解</p>
</li>
<li><p>欧拉方程</p>
<ul>
<li>形如 $x^ny^{(n)} + p_1x^{n - 1}y^{(n - 1)} + \cdots + p_{n - 1}xy’ + p_ny = f(x)$ 的方程叫欧拉方程，特点是 $x^ky^{(k)}$ 配对出现</li>
<li>解法是设 $x = e^t,\frac{dy}{dt}=Dy, \cdots, \frac{d^ky}{dt^k} = D^ky$，则 $x^ky^{(k)} = D(D - 1)\cdots(D - k + 1)y$，最后方程化为只与 $t$ 有关的线性方程</li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>数学</tag>
        <tag>大学笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>大学笔记 | 电路原理</title>
    <url>/2023/06/05/Circuit-Analysis/</url>
    <content><![CDATA[<p>从入门到进门</p>
<span id="more"></span>
<h2 id="第一章-电路模型和电路定律"><a href="#第一章-电路模型和电路定律" class="headerlink" title="第一章 电路模型和电路定律"></a>第一章 电路模型和电路定律</h2><h4 id="第一章总结"><a href="#第一章总结" class="headerlink" title="第一章总结"></a>第一章总结</h4><ol>
<li>研究的电路都满足集总假设条件，默认电路都是集总电路</li>
<li>激励称为输入，响应称为输出</li>
<li>关联参考方向：电流与压降方向一致，非关联参考方向：电流与压降方向相反</li>
<li>支路，节点，回路，网孔，网络</li>
<li>KCL，KVL</li>
<li>电阻有负电阻</li>
<li>受控电压源（?CVS），受控电流源（?CCS）</li>
</ol>
<h2 id="第二章-直流电阻电路的等效变换分析"><a href="#第二章-直流电阻电路的等效变换分析" class="headerlink" title="第二章 直流电阻电路的等效变换分析"></a>第二章 直流电阻电路的等效变换分析</h2><h4 id="第二章总结"><a href="#第二章总结" class="headerlink" title="第二章总结"></a>第二章总结</h4><ol>
<li><p>电流源并联时叠加，串联时要求两个电流源相等且就是这两个电流源大小，电压源串联时叠加，并联要求电压源相等</p>
</li>
<li><p>单口网络等效变换</p>
<p> <img src="单口网络等效变换.png" alt="单口网络等效变换"></p>
</li>
<li><p>Y-Δ变换</p>
<p> <img src="Y-Δ变换1.png" alt="Y-Δ变换1"></p>
<p> <img src="Y-Δ变换2.png" alt="Y-Δ变换2"></p>
<p> <img src="Y-Δ变换3.png" alt="Y-Δ变换3"></p>
</li>
</ol>
<h2 id="第三章-直流电阻电路的一般分析"><a href="#第三章-直流电阻电路的一般分析" class="headerlink" title="第三章 直流电阻电路的一般分析"></a>第三章 直流电阻电路的一般分析</h2><h4 id="第三章总结"><a href="#第三章总结" class="headerlink" title="第三章总结"></a>第三章总结</h4><ol>
<li><p>网孔分析法 ：每个网孔各设一个电流，利用回路中总电压代数和为 $0$ 列方程，方程左右两边满足 <code>压升 = 压降</code> ，<strong>注意设的电流方向</strong> （本质是 KVL）</p>
</li>
<li><p>节点分析法（本质是 KCL）</p>
<p> <img src="节点分析法.png" alt="节点分析法"></p>
<p> 注意右式是以流<strong>进</strong>的电流为正，并且如果某一个支路上要是有电流源了，那么和这个电流源串联的电阻在算自感，互感时都可以忽略不计</p>
<p> 还要注意的是，如果网络含独立电压源，最好一段接地，另一端直接求出电压</p>
</li>
<li><p>回路分析法和网孔分析法本质一样，只是网孔是特殊的回路</p>
</li>
</ol>
<p>例题：</p>
<p><img src="例2.1.png" alt="例2.1"></p>
<blockquote>
<p>解：左图可以化简为右图，易得 $I = \frac{2}{3}$</p>
</blockquote>
<h2 id="第四章-电路定理"><a href="#第四章-电路定理" class="headerlink" title="第四章 电路定理"></a>第四章 电路定理</h2><h4 id="第四章总结"><a href="#第四章总结" class="headerlink" title="第四章总结"></a>第四章总结</h4><ol>
<li>叠加定理和齐次定理只对线性电路适用</li>
<li>注意的是叠加定理每次都是只考虑一个<strong>独立源</strong>，受控源每次都是放在电路中的</li>
<li><p>置换定理：利用电压源 / 电流源替换（例题1， 2）</p>
</li>
<li><p>戴维南定理：单口网络可以等效为电压源串电阻，电压源大小为开路电压，电阻为独立源置0后的阻值（注意受控源有阻值） </p>
</li>
<li><p>诺顿定理：单口网络等效为电流源（大小为短路电流）并电阻，与戴维南类似（是戴维南定理的对偶形式）</p>
</li>
<li><p>求输出电阻常用的方法有：等效电阻法（这里是从端口方向看的），外加电压法（独立源要置0），开短路法（注意后面两个方法适合含受控源的情况）</p>
</li>
<li>$R_L = R_0$ 时满足最大功率条件，$\eta = \frac{负载产生功率}{总产生功率}$ 注意多个电源存在时有的电源会吸收功率，这个功率不能算在分母里，分母中只能算产生功率，而且算 $\eta$ 时要带回原电路来算，不能盲目认为 $R_L$ 和端口等效电阻相等就认为 $\eta$ 是 $50\%$</li>
</ol>
<p>例题：</p>
<p><img src="例3.1.png" alt="例3.1"></p>
<p><img src="例3.2.png" alt="例3.2"></p>
<blockquote>
<p>当我们知道某支路上的电流 / 电压时，我们可以用<strong>电压源 / 电流源来替换该支路上的其他元件</strong>，这样的话并不改变整个电路结构，研究某一复杂电路时，我们要清楚自己到底想求什么，然后对于<strong>和电流源串联的元件，思考能否舍弃，和电压源并联的元件，思考能否舍弃</strong></p>
</blockquote>
<h2 id="第五章-一阶直流动态电路时域分析"><a href="#第五章-一阶直流动态电路时域分析" class="headerlink" title="第五章 一阶直流动态电路时域分析"></a>第五章 一阶直流动态电路时域分析</h2><h4 id="第五章总结"><a href="#第五章总结" class="headerlink" title="第五章总结"></a>第五章总结</h4><ol>
<li><p>动态元件：元件的伏安关系包含对电流电压的微分 / 积分</p>
<p> 动态电路：至少含有一个动态元件，含有几个动态元件就称为几阶动态电路</p>
</li>
<li><p>电容，电感</p>
<p> <img src="电容，电感关系.png" alt="电容，电感关系"></p>
</li>
<li><p>完全响应 = 零输入响应 + 零状态响应</p>
<p> = 固有响应 + 强迫响应</p>
<p> = 暂态响应 + 稳态响应</p>
<p> 其实暂态可以粗浅理解为 $e^{-kt}$ 的量</p>
<p> <img src="几个概念.png" alt="几个概念"></p>
</li>
<li><p>$f(t) = f(\infty) + [f(0_+) - f(\infty)]e^{\frac{t}{\tau}}$</p>
</li>
</ol>
<h3 id="S-5-1-一阶电路的零输入响应-amp-零状态响应"><a href="#S-5-1-一阶电路的零输入响应-amp-零状态响应" class="headerlink" title="$\S 5.1$ 一阶电路的零输入响应 &amp; 零状态响应"></a>$\S 5.1$ 一阶电路的零输入响应 &amp; 零状态响应</h3><ul>
<li>换路定则</li>
</ul>
<p>​        换路前后电容电流和电感电压为有限制的情况下， 换路前后瞬间电容电压和电感电流不能跃变。 </p>
<p>​        该定则常用来判断 $i_L(0_+)与i_L(0_-),u_C(0_+)与u_C(0_-)$ 是否相等</p>
<ul>
<li><p>零输入响应公式形式</p>
<p>  对于电容：$u_c = U_0e^{-\frac{t}{\tau}}, \tau = RC$</p>
<p>  对于电感：$i_l = I_0e^{-\frac{t}{\tau}}, \tau = \frac{L}{R}$</p>
</li>
</ul>
<p>​        这里电感可以看作是一个电压源，而电容可以看作是一个电流源，<strong>然后这里的 $R$ 是指换路后电路的总电阻值</strong></p>
<ul>
<li><p>零状态响应公式</p>
<p>  对于电容：$u_c = U_{\infty}(1 - e^{-\frac{t}{\tau}}), \tau = RC$</p>
<p>  对于电感：$i_l = I_{\infty}(1 - e^{-\frac{t}{\tau}}), \tau = \frac{L}{R}$</p>
</li>
</ul>
<h3 id="S-5-2-一阶电路的全响应"><a href="#S-5-2-一阶电路的全响应" class="headerlink" title="$\S 5.2$ 一阶电路的全响应"></a>$\S 5.2$ 一阶电路的全响应</h3><ul>
<li><p>全响应公式形式</p>
<p>  对于电容：$u_c = U_0e^{-\frac{t}{\tau}} + U_{\infty}(1 - e^{-\frac{t}{\tau}}), \tau = RC$</p>
<p>  对于电感：$i_l = I_0e^{-\frac{t}{\tau}} + I_{\infty}(1 - e^{-\frac{t}{\tau}}), \tau = \frac{L}{R}$</p>
<p>  全响应时的电容电压即零状态时的电容电压加上零响应时的电容电压， 电感电源同理</p>
<p>  值得注意的是，这里的电阻 $R$ 是<strong>除去储能元件</strong>以及将激励源置零所得到的</p>
<p>  <strong>可以写作 $f(t) = f(\infty) + [f(0_+) - f(\infty)]e^{\frac{t}{\tau}}$， 这便是三要素法</strong></p>
<p>  <strong>一阶线性直流电路</strong>中的电感电容<strong>电阻</strong>， 均适用三要素法</p>
</li>
</ul>
<p><img src="换路定则.png" alt="换路定则"></p>
<p><strong>注意一下换路定理不能盲目用</strong></p>
<p><img src="特例.png" alt="特例"></p>
<h3 id="S-5-3-一阶电路的跃阶响应"><a href="#S-5-3-一阶电路的跃阶响应" class="headerlink" title="$\S 5.3$ 一阶电路的跃阶响应"></a>$\S 5.3$ 一阶电路的跃阶响应</h3><ul>
<li>单位跃阶函数时一种奇异函数， 定义 $\varepsilon(t) = \begin{cases} 0 &amp;&amp; t &lt; 0\ 1 &amp;&amp; t &gt; 0\end{cases}$</li>
<li><p>电路的单位跃阶响应为 $s(t) = (1 - e^{-\frac{t}{\tau}})\varepsilon(t)$ </p>
</li>
<li><p>其实可以先求出电压为 $1V$ 时的响应函数，然后用阶跃函数表示电压函数，最后真正响应函数的零状态响应就是阶跃函数 $\times (1 - e^{-\frac{t}{\tau}})$ 然后再加上零输入响应就是完全响应</p>
</li>
</ul>
<p><img src="例5.1.jpg" alt="例5.1"></p>
<p>（有坑）</p>
<p><img src="例5.2.png" alt="例5.2"></p>
<blockquote>
<p>首先从状态量入手，算 $0_-$ 时候的<strong>状态量</strong>，研究 $0_+$ 状态时可以把电容变为电压源，电感变为电流源，然后用三要素法分析。但是这题有个坑。无论是状态量还是非状态量，分解成暂态响应和固态响应时都可以直接按 <code>常数</code> + <code>按e指数衰减部分</code> ，但是分解成零输入和零状态时，状态量比较好分解就按照一般方法来，非状态量不可以按照状态量的方法，要列关于 i / u 的方程，然后把 i / u 转化为零输入 / 零状态时的量来求 </p>
</blockquote>
<p><img src="例5.3.png" alt="例5.3"></p>
<blockquote>
<p>分成 $0 &lt; t &lt; 1$ 和 $1 &lt; t$ 区间来处理</p>
<script type="math/tex; mode=display">t = \begin{cases} 2(1 - e^{-t}) \ , 0 \le t \le 1& \\\ 1 + (1 - 2e^{-1})e^{-2(t - 1)} \ ,t \ge 1 & \end{cases}</script></blockquote>
<p><img src="例5.4.png" alt="例5.4"></p>
<blockquote>
<script type="math/tex; mode=display">
u_s(t) = \varepsilon(t) + 2\varepsilon(t - 1) - 3\varepsilon(t - 3)\\
t = \begin{cases} 20e^{-\frac{t}{\tau}} + (1 - e^{-\frac{t}{\tau}}) \ , 0 \le t \le 1& \\ 20e^{-\frac{t}{\tau}} + (1 - e^{-\frac{t}{\tau}}) + 2(1 - e^{-\frac{t - 1}{\tau}}) \ ,1 \le t \le 3 & \\ 20e^{-\frac{t}{\tau}} + (1 - e^{-\frac{t}{\tau}}) + 2(1 - e^{-\frac{t - 1}{\tau}}) - 3(1 - e^{-\frac{t - 3}{\tau}}) \ ,t \ge 3\end{cases}</script></blockquote>
<h2 id="第六章-相量法"><a href="#第六章-相量法" class="headerlink" title="第六章 相量法"></a>第六章 相量法</h2><h4 id="第六章总结"><a href="#第六章总结" class="headerlink" title="第六章总结"></a>第六章总结</h4><ol>
<li>我们要建立概念就是复数，三角函数，$e$ 指数之间是可以相互转化的，所以往往可以把他们看作等价的，<strong>都可以表示二维平面上的向量</strong></li>
<li>算相量加减法时转化为复数形式，算相量乘除法时转化为 $e$ 指数形式</li>
<li>三角函数转化为相量时，除非特殊说明，不然默认相量前面的都是有效值，即峰值的 $\frac{1}{\sqrt 2}$</li>
<li>对于相量而言，我们在计算上时可以把它看作和相量相同计算，<strong>但是相量不是向量，向量是真实存在物理量，相量不真实存在，是表示正弦信号的工具</strong></li>
<li><p>当电源电流是三角函数形式，即不断变化时要用相量来表示，$U$ 和 $I$ 上要记得打点，相量是可以用来表征正弦波的，<strong>但不等同</strong></p>
</li>
<li><p>对于接下来的正弦稳态电路和之前学的电路<strong>没什么不同</strong>，区别就是电流电压用相量表示，并且电感电容都可以用阻抗来表示，$Z_C= -j\frac{1}{\omega C},Z_L = jL\omega $</p>
</li>
</ol>
<ul>
<li><p>复数</p>
<script type="math/tex; mode=display">
  F = a + jb\\
  F = |F|(cos\theta + jsin\theta)\\
  F = |F|e^{j\theta}\\
  \theta = arg \ F = arctan(\frac{b}{a})\\
  Re[F] = a\\
  lm[F] = b\\
  F^* = a - jb = |F|\angle-\theta</script><p>  复数加减用代数形式，乘除用指数形式</p>
</li>
<li><p>正弦量</p>
<p>  按正弦规律变化的电流，电压称为正弦量。由振幅（正数），角速度，初相位三要素决定</p>
<p>  按国家统一标准用cos表示正弦量</p>
<p>  相量和正弦量不相等，写的时候注意区分</p>
<p>  峰峰值是振幅的两倍，有效值也称为均方根值</p>
<p>  化成相量形式时前面的系数是有效值大小，化成正弦量时前面的系数是峰值大小</p>
</li>
<li><p>电路定理的相量形式</p>
<p>  $\omega L$ 感抗  $-\frac{1}{\omega L}$ 感纳   $-\frac{1}{c\omega}$ 容抗  $\omega C$ 容纳   </p>
<p>  将一般的电路定理全部改成相量形式</p>
</li>
</ul>
<h2 id="第七章-正弦稳态电路的分析"><a href="#第七章-正弦稳态电路的分析" class="headerlink" title="第七章 正弦稳态电路的分析"></a>第七章 正弦稳态电路的分析</h2><h4 id="第七章总结"><a href="#第七章总结" class="headerlink" title="第七章总结"></a>第七章总结</h4><ol>
<li><p>$|Z| = \frac{U}{I},Z = R + jX,\theta_z = \varphi_u - \varphi_i$ </p>
<p> $|Z|$ 称为阻抗模，$R$称为等效电阻分量，$X$称为等效电抗分量（$X &gt; 0,\theta_z &gt; 0$ 时称 $Z$ 为感性阻抗，$X&lt;0,\theta_z &lt; 0$ 时称为 $Z$ 容性阻抗）</p>
</li>
<li><p>$Y = \frac{I}{U} = G + jB$</p>
</li>
<li><p>有功功率 $P$，无功功率 $Q$，视在功率 $S$</p>
</li>
<li><p>功率因素 $\lambda = \frac{P}{S}$ 要记得标上电流 超前 / 滞后 电压，往往都是电流 滞后 电压，所以要通过串 / 并联电容来实现</p>
</li>
<li><p>最大传递功率：一种是 $R_L$ 任意可调，只需让虚部是 $R_0$ 虚部相反数，实部和 $R_0$ 实部相等。另一种是 $R_L$ 有限制，不能直接满足第一种条件，应该是 $R_L$ 和 $R_0$ 模长相等</p>
</li>
</ol>
<h2 id="第八章-含有耦合电感的电路"><a href="#第八章-含有耦合电感的电路" class="headerlink" title="第八章 含有耦合电感的电路"></a>第八章 含有耦合电感的电路</h2><h4 id="第八章总结"><a href="#第八章总结" class="headerlink" title="第八章总结"></a>第八章总结</h4><ol>
<li>$u = L\frac{di_1}{dt} + M\frac{di_2}{dt}$ ，并且知道如何判断同名端，如何判断电压电流正负</li>
<li>$k = \frac{M}{\sqrt {L_1 L_2}}$</li>
<li>判断等效受控源正负方向：假设电流从一个线圈打点端方向流入，则假设对于另一个线圈支路上的的受控电压源而言，该受控电压源和这条支路上的线圈打点端同向</li>
<li>遇到复杂，难以处理的电路，优先考虑化为理想线圈加受控源的形式（$\S 8.2$ 方法一）</li>
<li>记住串联线圈化简的公式和 $T$ 型等效公式</li>
<li>知道耦合系数是什么并且知道临界状况</li>
<li>知道反映阻抗法并能灵活运用于戴维南等效电路中</li>
<li><strong>什么都不知道时一定要会通过理想线圈加受控源的方法转化电路分析</strong></li>
</ol>
<h3 id="S-8-1-耦合电感的伏安关系"><a href="#S-8-1-耦合电感的伏安关系" class="headerlink" title="$\S 8.1$ 耦合电感的伏安关系"></a>$\S 8.1$ 耦合电感的伏安关系</h3><ul>
<li>耦合元件：由一跳以上支路组成，一支路的电压，电流与其他支路的电压，电流直接相关</li>
<li>在本章学习中，我们大多研究的耦合元件是线圈，线圈在通了电流之后会产生磁，而磁又会生电，从而产生电压，所以对于一个线圈上的电压，往往是由两部分组成，一个是它自身产生的电压，另一个是和它耦合的线圈的电压，自身电流和电磁之间比例系数是自感 $L$，和耦合元件之间是互感 $M$，但是我们有时也能见到 $L_{12}$，这种表示 $2$ 线圈在 $1$ 上的互感系数</li>
</ul>
<p><img src="耦合电感伏安关系.png" alt="耦合电感伏安关系"></p>
<ul>
<li>同名端：当电流沿着不同线圈的两个端点流入，若产生的磁通方向相同，则这两个端点称为同名端，往往题目会直接告诉，若两个耦合线圈电流沿着同名端通入，互感 $ML &gt; 0$，反之 $ML &lt; 0$，或者可以理解为 $I_1$ 在线圈 $1$ 打点端通入，那么互感 $M$ 产生的电压 $+$ 极也在线圈 $2$ 打点端</li>
</ul>
<h3 id="S-8-2-耦合电感的去耦等效模型"><a href="#S-8-2-耦合电感的去耦等效模型" class="headerlink" title="$\S 8.2$ 耦合电感的去耦等效模型"></a>$\S 8.2$ 耦合电感的去耦等效模型</h3><ul>
<li>利用受控源来等效：我们可以将线圈 $L$ 转化为纯线圈（不考虑互感）和受控电压源（最本源的方法，当你分析不出来或不太好处理时，都可以这样转化）<ul>
<li>下图是电流沿着同名端流入时，受控源正负<strong>均</strong>与电流方向一致</li>
<li>当沿着异名端流入时，受控源正负<strong>均</strong>与电流方向相反</li>
</ul>
</li>
</ul>
<p><img src="去耦等效线圈.png" alt="去耦等效线圈"></p>
<ul>
<li><p>耦合电路的串联</p>
<p>  当两个电感串联且电流沿着同名端流过（此时异名端相连），则可以等效为一个新电感 $L’ = L_1 + L_2 + 2M$</p>
<p>  <img src="线圈串联.png" alt="线圈串联"></p>
<p>  同理若电感串联但电流沿着异名端流过（同名端相连)，那么可以等效为一个新电感 $L’ = L_1 + L_2 - 2M$</p>
</li>
<li><p>耦合电路的并联</p>
<p>  当线圈并联且异名端相连时，可以等效为一个新线圈 $L’ = \frac{L_1L_2 - M^2}{L_1 + L_2 + 2M}$（能记住最好，也可以不记住，用T型等效去推，比较推荐（之后会介绍））</p>
<p>  当线圈并联且同名端相连时，可以等效为 $L’ = \frac{L_1L_2 - M^2}{L_1 + L_2 - 2M}$</p>
<p>  <img src="线圈并联.png" alt="线圈并联"></p>
</li>
<li><p>耦合系数</p>
<p>  我们都知道 $L$ 是大于 $0$ 的，所以在上述串联并联公式中，我们不难发现 $M$ 是要满足一定条件的，这里我们引入耦合系数 $k$ 来表示 $M$ 和 $L$ 之间的关系</p>
<p>  <img src="耦合系数.png" alt="耦合系数"></p>
</li>
<li><p>常见的等效方法</p>
<ul>
<li><p>$T$ 型等效</p>
<p>  <img src="T型等效1.png" alt="T型等效1"></p>
<p>  <img src="T型等效2.png" alt="T型等效2"></p>
<p>  $T$ 型等效在处理并联等问题上十分有效</p>
<p>  $e.g 8.1$</p>
<p>  <img src="例8.1.png" alt="例8.1"></p>
<blockquote>
<p> 值得一提的是，这里之所以可以把两个线圈下端相连是因为只连一端不影响回路</p>
</blockquote>
<h3 id="S-8-3-空心变压器电路的分析"><a href="#S-8-3-空心变压器电路的分析" class="headerlink" title="$\S 8.3$ 空心变压器电路的分析"></a>$\S 8.3$ 空心变压器电路的分析</h3></li>
</ul>
</li>
<li><p>互感化除法</p>
<p>  是不是很眼熟，嗯互感化除法其实就是 $T$ 型等效法的一个应用，这两个没什么区别qwq</p>
<p>  <img src="互感化除法.png" alt="互感化除法"></p>
</li>
<li><p>回路分析法</p>
<p>  其实没有用到任何化简，就是我们遇到一个新电路时的常见思路，把线圈变为理想线圈和受控源再分析，这个回路分析法是为接下来的简化方法服务的</p>
<p>  <img src="回路分析法.png" alt="回路分析法"></p>
</li>
<li><p>反映阻抗法</p>
<p>  仔细观察上一个化简的结果，我们发现初级电路和次级电路可以等效为一个新电路</p>
<p>  我们设 $Z_{11},Z_{22}$ 为初级电路和次级电路的视在阻值，视在阻值就是不考虑线圈的互感作用，直接计算出的电路的阻值</p>
<p>  那么初级线圈对新电路的贡献阻值为 $Z_1’ = Z_{11}$ 嗯就是它本身非常好记</p>
<p>  次级线圈对新电路的贡献阻值为 $Z_2’ = \frac{(\omega M)^2}{Z_{22}}$ 这个结果看起来很真，说明 $M$ 和 $Z_{22}$ 都会对新电路有影响，这个结果也被称为反映阻抗，不难看出其实反映阻抗和同名端位置无关</p>
<p>  <img src="反映阻抗法.png" alt="反映阻抗法"></p>
<p>  <img src="反映电阻2.png" alt="反映电阻2"></p>
<p>  所以化简的新电路如上，笔者推荐记住这个结果，比较方便</p>
<p>  但是记住这种方法要求次级回路中无独立源</p>
</li>
<li><p>戴维南等效法</p>
<p>  有了上述反映阻抗法的铺垫，我们可以利用戴维南等效法，从次级回路的两个端口看去，将其转化为一个新电路，这个新电路的阻值就按反映阻抗法的方法去求，只不过从次级回路来看的话，其实原先的次级回路相当于现在的初级回路，原先的初级回路相当于现在的次级回路</p>
<p>  但还有一个问题，开路电压 $U_{OC}$ 怎么求，其实也很简单，我们原先不是假设次级线圈是一个理想线圈和受控源吗，这个$U_{OC}$ 就是受控源的电压值，也非常好理解，故 $U_{OC} = j\omega M I_1 = j\omega M \frac{U_s}{Z_{11}}$， $U_{OC}$正负要看具体端口正负以及同名异名情况</p>
<p>  <img src="戴维南等效法.png" alt="戴维南等效法"></p>
</li>
</ul>
<h3 id="S-8-4-理想变压器电路的分析"><a href="#S-8-4-理想变压器电路的分析" class="headerlink" title="$\S 8.4$ 理想变压器电路的分析"></a>$\S 8.4$ 理想变压器电路的分析</h3><p>与先前的耦合线圈不同，理想变压器虽然长得和耦合线圈一样，但是不考虑 $L$ 和 $M$</p>
<p><img src="理想变压器电压电流关系.png" alt="理想变压器电压电流关系"></p>
<p><img src="理想变压器变换关系.png" alt="理想变压器变换关系"></p>
<p><img src="例8.2.png" alt="例8.2"></p>
<p><img src="例8.3.png" alt="例8.3"></p>
<p><img src="例8.4.png" alt="例8.4"></p>
<p><img src="例8.5.png" alt="例8.5"></p>
<h2 id="第九章-三相电路"><a href="#第九章-三相电路" class="headerlink" title="第九章 三相电路"></a>第九章 三相电路</h2><h4 id="第九章总结"><a href="#第九章总结" class="headerlink" title="第九章总结"></a>第九章总结</h4><ol>
<li><p>$I_a, I_b, I_c$ 是相电流，$I_{ab}, I_{ac}, I_{bc}$ 是线电流</p>
</li>
<li><p>$Y$ 型联接中，$U_{ab} = \sqrt 3 U_{a}\angle 30°,I_a = I_{ab}$ </p>
</li>
<li><p>$\Delta$ 型联接中，$U_a = U_{ab},I_a = \sqrt 3I_{ab}\angle -30°$ </p>
</li>
<li><p>做题时，应将负载和电源都变为 $Y$ 型联接，求出线电流，相电流之后再利用 $2$，$3$ 中的关系来替换</p>
</li>
<li>$Y$型 和 $\Delta$ 型变换往往利用的是 线电压 / 线电流 不变</li>
<li>$Y$ 型电路 $U$ 超前 $I$ 一个$\phi$ 角，这个角是其中一个电阻的辐角</li>
<li>$P_总 = 3P_相 = \sqrt 3 P_线$</li>
</ol>
<h3 id="S-9-1-三相电路"><a href="#S-9-1-三相电路" class="headerlink" title="$\S 9.1$ 三相电路"></a>$\S 9.1$ 三相电路</h3><ul>
<li><p>三个电压电流分别相差 $120°$ 的相位</p>
<p>  根据转子转向，三相电路有正负相序之分，一般没说明时默认正序（$B$ 滞后 $A$ $120°$）</p>
<p>  相比于单相发电机，三相发电机输出功率高，经济好，性能好，易于制造</p>
</li>
</ul>
<p><img src="三相交流电压.png" alt="三相交流电压"></p>
<ul>
<li><p>三相电源的联结</p>
<ul>
<li><p>$Y$ 型链接</p>
<p>  $U_a, U_b, U_c$ 是线电压， $U_{ab}, U_{ac}, U_{bc}$ 是项电压</p>
<p>  利用相量图来理解</p>
<p>  <img src="Y型链接.png" alt="Y型链接"></p>
</li>
<li><p>$\Delta$ 形联接</p>
<p>  电路接反时会很危险，会先接上电压表来判断</p>
<p>  <img src="三角链接.png" alt="三角链接"></p>
</li>
</ul>
</li>
<li><p>对称三相电路分析</p>
<ul>
<li><p>$Y-Y$ 联接</p>
<p>  通过节点电压法可得 $U_{nn’} = 0$</p>
<p><img src="YY联接.png" alt="YY联接"></p>
</li>
<li><p>$\Delta - ?$ 联接</p>
<p><img src="三角-？联接.png" alt="三角-？联接"></p>
</li>
</ul>
</li>
</ul>
<h3 id="S-9-2-对称三相电路的计算"><a href="#S-9-2-对称三相电路的计算" class="headerlink" title="$\S 9.2$ 对称三相电路的计算"></a>$\S 9.2$ 对称三相电路的计算</h3><h3 id="S-9-3-三相电路的功率"><a href="#S-9-3-三相电路的功率" class="headerlink" title="$\S 9.3$ 三相电路的功率"></a>$\S 9.3$ 三相电路的功率</h3><p>二表法适合测对称三相负载的功率，表的示数单独拿出来没有意义，要结合在一起看，而且一定要对称时才可以计算</p>
<p><img src="二表法.png" alt="二表法"></p>
<p><img src="对称三相负载功率.png" alt="对称三相负载功率"></p>
<p><img src="注意.png" alt="注意"></p>
<p>$e.g 9.1$</p>
<p><img src="例9.1.png" alt="例9.1"></p>
<blockquote>
<script type="math/tex; mode=display">
</script></blockquote>
]]></content>
      <tags>
        <tag>大学笔记</tag>
        <tag>专业课</tag>
      </tags>
  </entry>
  <entry>
    <title>博客搭建踩坑指北</title>
    <url>/2023/06/27/Cross-The-Hole/</url>
    <content><![CDATA[<p>从踩坑到掉坑里</p>
<span id="more"></span>
<p>本博客采用 Hexo + GitHub 搭建，具体教程网上很多不再赘述</p>
<p>不过这里还是推荐两个我主要参考的教程 <a href="https://ouuan.github.io/post/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%8C%87%E5%8C%97/">hexo博客搭建指北</a> 和 <a href="https://venusnero.github.io/2019/01/23/build_hexo_github_blog/">从零搭建 Hexo + Github 博客</a></p>
<p>下面分享一些自己踩过的坑</p>
<h3 id="公式块中公式无法正常换行"><a href="#公式块中公式无法正常换行" class="headerlink" title="公式块中公式无法正常换行"></a>公式块中公式无法正常换行</h3><h4 id="问题简述"><a href="#问题简述" class="headerlink" title="问题简述"></a>问题简述</h4><p>用 $$ 插入公式块时，本地上用 typora 显示公式换行，但网页上未显示出来</p>
<p><code>\\</code> 无法正常换行</p>
<h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>在公式块前面加上 <code>\begin{gather}</code> 末尾加上 <code>\end{gather}</code> 即可</p>
<h3 id="Majax-渲染"><a href="#Majax-渲染" class="headerlink" title="Majax 渲染"></a>Majax 渲染</h3><h4 id="问题简述-1"><a href="#问题简述-1" class="headerlink" title="问题简述"></a>问题简述</h4><ol>
<li><p>无法正常渲染二重闭曲面积分</p>
</li>
<li><p>```latex<br> $\iiint_{\Omega}(\frac{\partial P}{\partial x} + \frac{\partial Q}{\partial y} + \frac{\partial R}{\partial z})dV = \unicode{8751}_{\sum}Pdydz + Qdzdx + Rdxdy $</p>
 <figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line"> 可以正常渲染出来</span><br><span class="line"></span><br><span class="line">$\iiint_{\Omega}(\frac{\partial P}{\partial x} + \frac{\partial Q}{\partial y} + \frac{\partial R}{\partial z})dV = \unicode{8751}_{\sum}Pdydz + Qdzdx + Rdxdy $</span><br><span class="line"></span><br><span class="line">```latex</span><br><span class="line">$\unicode{8751}_{\sum}Pdydz + Qdzdx + Rdxdy = \iiint_{\Omega}(\frac{\partial P}{\partial x} + \frac{\partial Q}{\partial y} + \frac{\partial R}{\partial z})dV$</span><br></pre></td></tr></tbody></table></figure>
<p> 渲染异常</p>
<p> $\unicode{8751}_{\sum}Pdydz + Qdzdx + Rdxdy = \iiint_{\Omega}(\frac{\partial P}{\partial x} + \frac{\partial Q}{\partial y} + \frac{\partial R}{\partial z})dV$</p>
</li>
</ol>
<h4 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h4><ol>
<li><p>用 <code>\unicode{8751}</code> 表示即可</p>
</li>
<li><p>很神奇的问题，解决方法也很玄学，将</p>
 <figure class="highlight latex"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">\unicode</span>{8751}<span class="built_in">_</span>{<span class="keyword">\sum</span>}Pdydz + Qdzdx + Rdxdy = <span class="keyword">\iiint</span><span class="built_in">_</span>{<span class="keyword">\Omega</span>}(<span class="keyword">\frac</span>{<span class="keyword">\partial</span> P}{<span class="keyword">\partial</span> x} + <span class="keyword">\frac</span>{<span class="keyword">\partial</span> Q}{<span class="keyword">\partial</span> y} + <span class="keyword">\frac</span>{<span class="keyword">\partial</span> R}{<span class="keyword">\partial</span> z})dV</span><br></pre></td></tr></tbody></table></figure>
<p> 改为</p>
 <figure class="highlight latex"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">\unicode</span>{8751}<span class="built_in">_</span>{<span class="keyword">\sum</span>} Pdydz + Qdzdx + Rdxdy = <span class="keyword">\iiint</span><span class="built_in">_</span><span class="keyword">\Omega</span>(<span class="keyword">\frac</span>{<span class="keyword">\partial</span> P}{<span class="keyword">\partial</span> x} + <span class="keyword">\frac</span>{<span class="keyword">\partial</span> Q}{<span class="keyword">\partial</span> y} + <span class="keyword">\frac</span>{<span class="keyword">\partial</span> R}{<span class="keyword">\partial</span> z})dV</span><br></pre></td></tr></tbody></table></figure>
<p> 即可</p>
<p> $\unicode{8751}_\sum Pdydz + Qdzdx + Rdxdy = \iiint_\Omega(\frac{\partial P}{\partial x} + \frac{\partial Q}{\partial y} + \frac{\partial R}{\partial z})dV$</p>
<p> 感觉可能是 <code>{}</code> 和 mathjax 渲染有一些冲突，具体原因还不完全清楚（？）</p>
</li>
</ol>
<h3 id="表格中的"><a href="#表格中的" class="headerlink" title="表格中的 |"></a>表格中的 |</h3><h4 id="问题简述-2"><a href="#问题简述-2" class="headerlink" title="问题简述"></a>问题简述</h4><p>由于 markdown 本身的语法，我们无法直接在表格中打出竖线 |</p>
<h4 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案"></a>解决方案</h4><ul>
<li>当表格内容不用 $\LaTeX$ 时，可通过转义符 <code>\|</code> 或 <code>&amp;#124;</code> 来实现竖杠或绝对值； </li>
<li>但是用 $\LaTeX$ 时第一个会显示为 “∥”，第二个会报错，故要用 <code>\vert</code> </li>
</ul>
<h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="https://blog.csdn.net/skytruine/article/details/105710349">Markdown表格数学公式中使用绝对值“| |”或竖杠”|”</a></p>
<h3 id="背景-和-透明度"><a href="#背景-和-透明度" class="headerlink" title="背景 和 透明度"></a>背景 和 透明度</h3><h4 id="问题简述-3"><a href="#问题简述-3" class="headerlink" title="问题简述"></a>问题简述</h4><p>在 Hexo 7.x 版本下设置 背景 和 透明度</p>
<h4 id="解决方案-3"><a href="#解决方案-3" class="headerlink" title="解决方案"></a>解决方案</h4><ul>
<li><p>新建 _custom.styl 文件，并在 main.styl 中引用该文件</p>
  <figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">//个人添加</span><br><span class="line">@import "_custom.styl"</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>```stylus<br>  //背景图片<br>  body {</p>
<pre><code>  background:url(https://pic.heson10.com/img/image-20200712231958010.png);
  background-repeat: no-repeat;
  background-attachment:fixed;
  background-size: cover;
  background-position:50% 50%;
</code></pre><p>  }</p>
<p>  //博客内容透明化<br>  //文章内容的透明度设置<br>  .content-wrap {</p>
<pre><code>opacity: 0.9;
</code></pre><p>  }</p>
<p>  //侧边框的透明度设置<br>  .sidebar {</p>
<pre><code>opacity: 0.9;
</code></pre><p>  }</p>
<p>  //菜单栏的透明度设置<br>  .header-inner {</p>
<pre><code>background: rgba(255,255,255,0.9);
</code></pre><p>  }</p>
<p>  //搜索框（local-search）的透明度设置<br>  .popup {</p>
<pre><code>opacity: 0.9;
</code></pre><p>  }</p>
  <figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line">#### 参考</span><br><span class="line"></span><br><span class="line">[Hexo+Next7.X 博客美化教程合集](https://www.heson10.com/volantis/posts/52911.html)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 自定义文章排序</span><br><span class="line"></span><br><span class="line">#### 问题简述</span><br><span class="line"></span><br><span class="line">希望将个别博客置顶而设置自定义排序</span><br><span class="line"></span><br><span class="line">#### 解决方案</span><br><span class="line"></span><br><span class="line">在`node_modules\hexo-generator-index-pin-top\lib\generator.js`文件中找到了似乎是用于排序的代码，该文件是为了添加文章置顶功能的，但当置顶等级设置相同时，按照发布日期进行排序。</span><br><span class="line"></span><br><span class="line">修改后如下：</span><br><span class="line"></span><br><span class="line">```js</span><br><span class="line">'use strict';</span><br><span class="line">var pagination = require('hexo-pagination');</span><br><span class="line">module.exports = function(locals){</span><br><span class="line">  var config = this.config;</span><br><span class="line">  var posts = locals.posts;</span><br><span class="line">    posts.data = posts.data.sort(function(a, b) {</span><br><span class="line">        if(a.top &amp;&amp; b.top) { // 当两篇文章top都有定义时</span><br><span class="line">            if(a.top == b.top) return b.updated - a.updated; // 若top值一样，则按照文章更新日期降序排列</span><br><span class="line">            else return b.top - a.top; // 否则按照top值降序排列</span><br><span class="line">        }</span><br><span class="line">        else if(a.top &amp;&amp; !b.top) { // 以下两种情况是若只有一篇文章top有定义，则将有top的排在前面(这里用异或操作居然不行233)</span><br><span class="line">            return -1;</span><br><span class="line">        }</span><br><span class="line">        else if(!a.top &amp;&amp; b.top) { //上一条已解释</span><br><span class="line">            return 1;</span><br><span class="line">        }</span><br><span class="line">        else return b.updated - a.updated; // 若都没定义，则按照文章更新日期降序排列</span><br><span class="line">    });</span><br><span class="line">  var paginationDir = config.pagination_dir || 'page';</span><br><span class="line">  return pagination('', posts, {</span><br><span class="line">    perPage: config.index_generator.per_page,</span><br><span class="line">    layout: ['index', 'archive'],</span><br><span class="line">    format: paginationDir + '/%d/',</span><br><span class="line">    data: {</span><br><span class="line">      __index: true</span><br><span class="line">    }</span><br><span class="line">  });</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
<h4 id="参考-1"><a href="#参考-1" class="headerlink" title="参考"></a>参考</h4><p><a href="https://blog.csdn.net/qq_40790680/article/details/128971322">hexo 自定义文章排序</a></p>
]]></content>
      <tags>
        <tag>博客搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>大学笔记 | 离散数学</title>
    <url>/2023/08/29/Discrete-Math/</url>
    <content><![CDATA[<p>从入门到出门。</p>
<span id="more"></span>
<h2 id="第一章-命题逻辑"><a href="#第一章-命题逻辑" class="headerlink" title="第一章 命题逻辑"></a>第一章 命题逻辑</h2><h3 id="S-1-1-命题符号化及联结词"><a href="#S-1-1-命题符号化及联结词" class="headerlink" title="$\S 1.1$ 命题符号化及联结词"></a>$\S 1.1$ 命题符号化及联结词</h3><ul>
<li><p>命题：能判断真假的陈述句。表示其正确性的值称为真值。</p>
</li>
<li><p>不能分解的更简单的命题称为<strong>简单命题</strong>或<strong>原子命题</strong>。</p>
</li>
<li><p>简单命题真值确定，又称为<strong>命题常项</strong>或命题常元。</p>
</li>
<li><p>真值可变的简单陈述句称为<strong>命题变项</strong>或命题变元。</p>
</li>
<li><p>复合命题由简单命题与联接词联接而成。联结词也称为<strong>真值联结词</strong>或<strong>逻辑联结词</strong>。</p>
</li>
<li><p>复合命题 “非 $p$” 称为 $p$ 的否定式，记作 $\neg p$。$\neg$ 称为否定联结词。</p>
</li>
<li><p>复合命题 “$p$ 并且 $q$” 称为 $p$ 与 $q$ 的<strong>合取式</strong>，记作 $p \wedge q$。$\wedge$ 称为<strong>合取联结词</strong>。</p>
</li>
<li><p>复合命题 “$p$ 或 $q$” 称为 $p$ 与 $q$ 的<strong>析取式</strong>，记作 $p \vee q$。$\vee$ 称为<strong>析取联结词</strong>。</p>
</li>
<li><p>复合命题 “如果 $p$，则 $q$” 称为 $p$ 与 $q$ 的<strong>蕴涵式</strong>，记作 $p \to q$。称 $p$ 为蕴涵式的前件，$q$ 为蕴涵式的后件。$\to$ 称为蕴涵联结词。<strong>该命题为假当且仅当 $p$ 为真且 $q$为假</strong>。</p>
<blockquote>
<p>$q$ 是 $p$ 的必要条件，$p$ 是 $q$ 的充分条件。等同于”只要 $p$ 就 $q$”，“$p$ 仅当 $q$”，“只有 $q$ 才 $p$”等。</p>
<p>若两个命题均是否定行为，可以考虑先化作逆否命题形式。</p>
<p>还有一种较为直观判断 $p \to q$ 还是 $q \to p$ 的方法是画维恩图。后件的区域是会包含前件的区域的。</p>
</blockquote>
<p>  <img src="1.1-1.png" alt="1.1-1"></p>
</li>
<li><p>复合命题 “$p$ 当且仅当 $q$” 称为 $p$ 与 $q$ 的等价式，记作 $p \leftrightarrow q$。$\leftrightarrow$ 称为等价联结词。<strong>该命题为真当且仅当 $p$ 和 $q$ 均为真或均为假</strong>。</p>
</li>
</ul>
<h3 id="S-1-2-命题公式及分类"><a href="#S-1-2-命题公式及分类" class="headerlink" title="$\S 1.2$ 命题公式及分类"></a>$\S 1.2$ 命题公式及分类</h3><ul>
<li><p>命题公式定义：</p>
<ul>
<li>单个命题常项 / 变项 / 0 / 1 是命题公式。</li>
<li>有限次的联结词与命题公式结合使用也是命题公式。</li>
<li>命题公式又称为合式公式，简称公式。</li>
</ul>
</li>
<li><p>命题公式层次的定义：</p>
<ul>
<li>单个命题是 $0$ 层公式。</li>
<li>$A$ 是 $n + 1$ 层当且仅当：<ul>
<li>$A = \neg B$， $B$ 是第 $n$ 层。</li>
<li>$A = B \oplus C$，其中 $B$，$C$ 是第 $i$ ，$j$ 层，且 $n = max(i, j),\oplus =\vee / \wedge / \to / \leftrightarrow$。 </li>
</ul>
</li>
</ul>
</li>
<li><p>对于某一命题公式 $A$，对于其中的命题变项，指定它们的一组真值，称为 $A$ 的一个<strong>赋值 / 解释</strong>。使 $A$ 真值为真的这组值称为<strong>成真赋值</strong>，反之称为<strong>成假赋值</strong>。</p>
</li>
<li><p>特殊的，若 $A$ 在所有赋值下均为真，则称为<strong>重言式</strong>或<strong>永真式</strong>；若 $A$ 在所有赋值下均为假，则称为<strong>矛盾式</strong>或<strong>永假式</strong>；若 $A$ 在某一赋值下为真，则称为<strong>可满足式</strong>。</p>
</li>
<li><p>$n$ 元真值函数 $F:\{0, 1\}^n \to \{0, 1\}$，对于 $n$ 个命题变项有 $2^{2^n}$ 个真值函数 。</p>
<blockquote>
<p>因为 $n$ 个变量可以形成 $2^n$ 个结果，对于每个结果，又有 $0 / 1$ 的选择，故一共 $2^{2^n}$。</p>
<p><img src="1.1-2.jpg" alt="1.1-2"></p>
<p>参考 <a href="https://blog.csdn.net/qq_45472866/article/details/108023600">离散数学n元变量的真值函数（或者真值表的种类数）有 2^(2^n)个 详解</a></p>
</blockquote>
</li>
</ul>
<p>对于 $A$，$B$ 命题，若 $A \leftrightarrow B$ 是重言式，则称 $A$，$B$ 等价，记作$A \Leftrightarrow B$。</p>
<blockquote>
<p>注意 $\Leftrightarrow$ 不是联接词。</p>
</blockquote>
<h3 id="S-1-3-命题逻辑等值演算"><a href="#S-1-3-命题逻辑等值演算" class="headerlink" title="$\S 1.3$ 命题逻辑等值演算"></a>$\S 1.3$ 命题逻辑等值演算</h3><ul>
<li><p><strong>等值演算</strong>：由已知的等值式推演出新的等值式；<strong>置换规则</strong>：若 $A \Leftrightarrow B$，则 $\Phi(A) \Leftrightarrow \Phi(B)$。</p>
<blockquote>
<p>证明两个公式等值时，可以直接用等值演算来验证，而证明公式不等值时，往往要通过赋值来使两边真值不等来验证。</p>
</blockquote>
</li>
</ul>
<p><img src="1.3-1.jpg" alt="1.3-1"></p>
<h3 id="S-1-4-范式"><a href="#S-1-4-范式" class="headerlink" title="$\S 1.4$ 范式"></a>$\S 1.4$ 范式</h3><ul>
<li><p>仅由有限个命题变项或其否定构成的析取式称为<strong>简单析取式</strong>，仅由有限个命题变项或其否定构成的合取式称为<strong>简单合取式</strong>。</p>
</li>
<li><p>由有限个简单析取式<strong>合取</strong>而成的式子称为<strong>合取范式</strong>，由有限个简单合取式<strong>析取</strong>而成的式子称为<strong>析取范式</strong>。析取范式和合取范式总称为<strong>范式</strong>。</p>
<blockquote>
<p>单个命题变项或其否定既是简单析取式又是简单合取式。</p>
</blockquote>
</li>
<li><p>任一命题公式都有与之等值的析取范式和合取范式，且不唯一存在。</p>
</li>
<li><p><strong>极小项</strong>：在含有若干命题变项的简单合取式中，每个命题变项及其否定有且仅有一个出现一次，这样的简单合取式称为极小项。 <strong>极大项</strong>：在含有若干命题变项的简单析取式中，每个命题变项及其否定有且仅有一个出现一次，这样的简单析取式称为极小项。</p>
<blockquote>
<p>$n$ 个命题变项产生 $2^n$ 个极小（大）项。</p>
<p>用 $m_i(M_i)$ 表示第 $i$ 个极小（大）项，$i$ 是该极小（大）项成真（假）赋值的十进制表示。</p>
<p>$\neg m_I \Leftrightarrow M_i$，$\neg M_i \Leftrightarrow m_i$。</p>
</blockquote>
</li>
<li><p><strong>主析取范式</strong>：由极小项组成的析取范式，<strong>主合取范式</strong>：由极大项合取组成的合取范式。</p>
</li>
<li><p>任何命题公式都有与之等值的主析取范式和主合取范式，并且是唯一的。</p>
</li>
<li><p>利用公式的主析（合）取范式可以快速成真（假）赋值。</p>
</li>
<li><p>判断公式类型（重要推论）：<br>  设 $A$ 有 $n$ 个命题变项，则</p>
<ul>
<li><p>$A$ 为重言式 $\Leftrightarrow$ $A$ 的主析取范式含 $2^n$ 个极小项。</p>
<p>  ​                    $\Leftrightarrow$ $A$ 的主合取范式为 $1$。</p>
</li>
<li><p>$A$ 为矛盾式 $\Leftrightarrow$ $A$ 的主析取范式为 $0$。</p>
<p>  ​                    $\Leftrightarrow$ $A$ 的主合取范式含 $2^n$ 个极大项。</p>
</li>
<li><p>$A$ 为非重言式的可满足式 $\Leftrightarrow$ $A$ 的主析取范式中至少含一个且不含全部极小项。</p>
<p>  ​                    $\Leftrightarrow$ $A$ 的主合取范式中至少含一个且不含全部极大项。</p>
<blockquote>
<p>当 $A$ 的主析取范式含 $2^n$ 个极小项时，说明有 $2^n$ 个成真赋值，也就是说无论怎么赋值结果都是 $1$。</p>
<p>当 $A$ 的主合取范式含 $2^n$ 个极大项时，说明有 $2^n$ 个成假赋值，也就是说无论怎么赋值结果都是 $0$。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h3 id="S-1-5-联结词全功能集"><a href="#S-1-5-联结词全功能集" class="headerlink" title="$\S 1.5$ 联结词全功能集"></a>$\S 1.5$ 联结词全功能集</h3><ul>
<li>$S$ 是一个联结词集合，若<strong>任何</strong> $n$ 元函数均可以由仅含 $S$ 中联结词构成的公式表示，则称 $S$ 是联结词全功能集（注意：若 $S$ 是全功能集，那么任何命题公式都可以用 $S$ 中联结词表示）。</li>
</ul>
<p><img src="1.5-1.png" alt="1.5-1"></p>
<blockquote>
<p>实质上是先证明任一命题都是可以化作主析取 / 合取范式，故可用 $\{\neg,\vee,\wedge\}$ 表示，然后证 $\vee,\wedge,\neg$ 三者之间是可以相互推的，故后面三个也都是全功能集。</p>
</blockquote>
<ul>
<li><p>与非式：$p \uparrow q \Leftrightarrow \neg(p\wedge q)$</p>
<p>  或非式：$p \downarrow q \Leftrightarrow \neg(p \vee q)$</p>
<p>  <img src="1.5-2.png" alt="1.5-2"></p>
</li>
</ul>
<p><img src="1.5-3.png" alt="1.5-3"></p>
<blockquote>
<p>不难发现，$\uparrow$ 和 $\downarrow$ 可以把 $\vee,\wedge,\neg$ 都表示出来，故 $\{\uparrow\},\{\downarrow\}$ 是联结词全功能集。 </p>
</blockquote>
<h3 id="S-1-6-组合电路"><a href="#S-1-6-组合电路" class="headerlink" title="$\S 1.6$ 组合电路"></a>$\S 1.6$ 组合电路</h3><p><img src="1.6-1.png" alt="1.6-1"></p>
<ul>
<li><p>步骤：</p>
<ul>
<li>构造输入输出表（问题的真值函数）。</li>
<li>写出主析取式。</li>
<li><p>化简。</p>
<p>最简展开式：包含最少运算的公式。</p>
</li>
</ul>
</li>
<li><p>Quine-McCluskey 算法</p>
<ul>
<li>合并简单合取式生成所有可能出现在最简展开式中的项。</li>
<li>确定最简展开式中的项。</li>
</ul>
</li>
</ul>
<h3 id="S-1-7-推理理论"><a href="#S-1-7-推理理论" class="headerlink" title="$\S 1.7$ 推理理论"></a>$\S 1.7$ 推理理论</h3><p><img src="1.7-1.png" alt="1.7-1"></p>
<p><img src="1.7-2.png" alt="1.7-2"></p>
<p><img src="1.7-3.png" alt="1.7-3"></p>
<p><img src="1.7-4.png" alt="1.7-4"></p>
<ul>
<li><p><strong>直接证明法</strong>：列出前提和结论，把然后再通过演算从前提推出结论。</p>
</li>
<li><p><strong>附加前提证明法</strong>：将问题转化后在证明。</p>
</li>
<li><p><strong>归谬法（反证法）</strong>：把推理的结论 $B$ 的否定 $\neg B$ 作为前提，推出矛盾，即证明原为有效结论。</p>
</li>
</ul>
<h2 id="第二章-一阶逻辑"><a href="#第二章-一阶逻辑" class="headerlink" title="第二章 一阶逻辑"></a>第二章 一阶逻辑</h2><h3 id="S-2-1-一阶逻辑基本概念"><a href="#S-2-1-一阶逻辑基本概念" class="headerlink" title="$\S 2.1$ 一阶逻辑基本概念"></a>$\S 2.1$ 一阶逻辑基本概念</h3><ul>
<li><p>个体词</p>
<p>  <strong>个体</strong>就是所有研究的单独的抽象或具体的客体。</p>
<p>  <strong>个体常项</strong>是具体的客体，<strong>个体变项</strong>是抽象的客体，往往可变。</p>
<p>  <strong>个体域</strong>是个体变项的取值范围。</p>
</li>
<li><p>谓词</p>
<blockquote>
<p>类比谓语动词。</p>
</blockquote>
<p>  <strong>谓词常项</strong>指的是某一固定性质或关系，<strong>谓词变项</strong>指的是某一抽象的性质或范围，往往可变。</p>
<p>  <strong>一元谓词</strong>，对象只有一个，表示单一对象性质。<strong>多元谓词</strong>，对象有多个，表示对象之间的关系。</p>
<p>  <strong>0 元谓词</strong>，不含个体变项的谓词，即命题常项或命题变项。</p>
</li>
<li><p>量词</p>
<p>  <strong>存在量词 $\forall$</strong> 表示任意，全部。</p>
<p>  <strong>全称量词 $\exists$</strong> 表示存在，至少一个。</p>
</li>
<li><p>一阶逻辑中命题符号化</p>
<p>  如果当前命题的个体域就是全体个体域，表示形式为 $\exists / \forall x G(x)$。</p>
<p>  如果当前命题的个体域是全体个体域中满足 $M(x)$ 的个体域（$G(x)$  称为特性谓词），表示为 $\exists / \forall x (M(x) \to G(x))$ 或 $\exists / \forall x (M(x) \wedge G(x))$。</p>
</li>
</ul>
<h3 id="S-2-2-一阶逻辑公式及解释"><a href="#S-2-2-一阶逻辑公式及解释" class="headerlink" title="$\S 2.2$ 一阶逻辑公式及解释"></a>$\S 2.2$ 一阶逻辑公式及解释</h3><ul>
<li><p>字母表，项，原子公式，合式公式</p>
</li>
<li><p><img src="2.2-1.png" alt="2.2-1"></p>
</li>
<li><p>换名规则</p>
<p>  <strong>换名规则</strong>：将一个指导变项及其在辖域中所有约束出现替换为公式中没有出现的个体变项符号。 </p>
<p>  以 $\exists x F(x) \wedge G(x, y)$ 为例，前面 $x$ 为指导变项和约束出现，后面的 $x$ 为自由出现，为了避免冲突，所以应该将前面的两个 $x$ 替换为没出现的字母（比如 $a$）。</p>
</li>
<li><p>解释和赋值</p>
<p>  <img src="2.2-2.png" alt="2.2-2"></p>
<blockquote>
<p>这里 $a,f,F,x$ 都是抽象的，不定的。而 $\bar a, \bar f, \bar F, \sigma(x)$ 是具体的。代入具体的符号之后，我们就可以把一个抽象的命题变为一个具体的命题。并判断其真假。</p>
</blockquote>
</li>
<li><p>公式分类</p>
<p>  分为<strong>永真式（逻辑有效式）</strong>，矛盾式（永假式），可满足式。</p>
</li>
<li><p>代换</p>
<p>  <img src="2.2-3.png" alt="2.2-3"></p>
<blockquote>
<p>特别的，永真式的代换实例都是永真式，矛盾式的代换实例都是矛盾式。</p>
</blockquote>
</li>
</ul>
<h3 id="S-2-3-一阶逻辑等值式与前束范式"><a href="#S-2-3-一阶逻辑等值式与前束范式" class="headerlink" title="$\S 2.3$ 一阶逻辑等值式与前束范式"></a>$\S 2.3$ 一阶逻辑等值式与前束范式</h3><ul>
<li><p>等值式与基本等值式</p>
<p>  若 $A \leftrightarrow B$ 为逻辑有效式，则称 $A$ 与 $B$ 是等值的，记作 $A \Leftrightarrow B$，并称 $A \Leftrightarrow B$ 为等值式。</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>数学</tag>
        <tag>大学课程</tag>
      </tags>
  </entry>
  <entry>
    <title>大学笔记 | 模拟电子技术基础</title>
    <url>/2023/08/29/Electronic-Devices-and-Circuit-Theory/</url>
    <content><![CDATA[<p>本课最大的收获是习得了上课隐身术，只有聪明的人才能看到我。</p>
<p>———  updated on 2023/10/10 —————</p>
<p>老师上课点名，隐身术失效了呜呜呜 🥲</p>
<span id="more"></span>
<blockquote>
<p><strong>写在前面</strong></p>
<p>本笔记内容排布主要参考于华成英主编的《模拟电子技术基础》。</p>
<p>同时内容一定程度上参考于华成英的《模拟电子技术基础》和 <a href="https://www.bilibili.com/video/BV1Gt411b7Zq/?spm_id_from=333.1007.top_right_bar_window_custom_collection.content.click&amp;vd_source=0f0f84fd4f7853dba4619576003d75fb">b 站上交郑益慧老师的视频</a>。</p>
<p><strong>Attention !!!</strong></p>
<p><strong>$I_B$，表示直流量（静态值）。</strong></p>
<p><strong>$\overset{.}{I_b}$，表示正弦交流的向量形式。</strong></p>
<p><strong>$I_b$，表示正弦交流量的有效值。</strong></p>
<p><strong>$i_B$，表示交、直流混合量。</strong></p>
<p><strong>$i_b$，表示纯交流量。</strong></p>
</blockquote>
<h2 id="第一章-常用半导体器件"><a href="#第一章-常用半导体器件" class="headerlink" title="第一章 常用半导体器件"></a>第一章 常用半导体器件</h2><h3 id="S-1-1-半导体基础知识"><a href="#S-1-1-半导体基础知识" class="headerlink" title="$\S 1.1$ 半导体基础知识"></a>$\S 1.1$ 半导体基础知识</h3><blockquote>
<p>这部分了解即可。</p>
</blockquote>
<p>物质按导电能力可分为导体，半导体和绝缘体，其中半导体主要材料是硅（Si），锗（Ge）和砷化镓（GaAs）。</p>
<p>研究半导体原子结构时，为简化起见，把内层电子和原子核视为一个整体，称为惯性核，其周围是价电子。</p>
<ul>
<li><strong>本征半导体</strong></li>
</ul>
<p><strong>完全纯净的，晶体结构完整的半导体晶体称为本征半导体。</strong>在 $0K$ 温度下，没有自由移动的载流子，不能导电相当于绝缘体。而当温度升高时共价键中的价电子从外界获得能量而激发成自由电子，这种现象称为本征激发。</p>
<p><strong>可以把激发出的空位视为带正电荷的载流子，并把它称为空穴。</strong>半导体时依靠自由电子和空穴导电的。</p>
<p>本征激发使两种载流子数量相等。空穴和自由电子相遇抵消的过程称为复合。温度一定时，两种载流子数目保持不变处于热平衡状态。</p>
<p>设 $n_i$ 为热平衡载流子浓度，$p_0, h_0$ 分别为空穴和载流子浓度，则有 $p_0 = n_0 = n_i$。但是这种半导体导电能力很弱。</p>
<blockquote>
<p>本征激发和温度有关，复合和粒子浓度有关。</p>
</blockquote>
<p>杂质半导体分为 $N$ 型（电子型）和 $P$ 型（空穴型）</p>
<ul>
<li><strong>$N$ 型半导体</strong></li>
</ul>
<blockquote>
<p>N 是 negative，指的是负的电子。</p>
</blockquote>
<p>向半导体中加入少量五价元素，称五价元素为<strong>施主元素</strong>，自由电子为多数载流子，简称多子。空穴称为少子。</p>
<ul>
<li><strong>$P$ 型半导体</strong></li>
</ul>
<blockquote>
<p>P 是 positive，指的是正的空穴。</p>
</blockquote>
<p>向半导体中加入少量三价元素，称三价元素为<strong>受主元素</strong>，空穴为多子。自由电子为少子。</p>
<p>杂质越多，多子浓度越高，导电性越强。<strong>少子浓度与温度有关。</strong></p>
<ul>
<li><strong>漂移电流和扩散电流</strong></li>
</ul>
<p>在外加电场作用下，载流子的定向移动称为漂移运动，会产生漂移电流。</p>
<p>载流子由于浓度不一致会产生扩散运动，并产生扩散电流。</p>
<ul>
<li><p><strong>$PN$ 结的形成及特性</strong></p>
<ol>
<li><p>形成</p>
<p>利用掺杂的方法，使半导体一半是 $P$ 一半是 $N$，由于扩散运动使两边载流子不断中和之后，$P$ 区的负离子和 $N$ 区的正离子形成内建电场组织多子扩散。直到两边达到稳态，就形成了 $PN$ 结。</p>
<p>两边掺杂浓度一样可以形成对称结，反之形成不对称结。</p>
<p>中间的正负离子界面称为空间电荷区，又称为耗尽区 / 势垒区 / 阻挡区。</p>
<p>内建电场的电位差 $V_B$ 称为内建电位差，满足</p>
<script type="math/tex; mode=display">
V_B \approx V_Tln\dfrac{N_aN_d}{n_i^2} \\
V_T = \dfrac{kT}{q}</script><p><img src="1.1-1.png" alt="1-1"></p>
</li>
<li><p>特性</p>
<ul>
<li><p>正向特性：当电源正极接 P，负极接 N，称 PN 结外加正向电压，也称正向偏置。会使 PN 结减小（刚开始很小的时候，电子难过去，后来不断削弱阻挡区，电流指数级上涨）。</p>
</li>
<li><p>反向特性：当电源正极接 N，负极接 P，称 PN 结外加反向电压，也称反向偏置。会使 PN 结增大（阻挡区越来越厚，电子更难过去，不导通）。</p>
</li>
<li><p>伏安特性：PN 结的电流与端电压存在关系：</p>
<script type="math/tex; mode=display">
i = I_s(e^{v/V_T} - 1)</script><blockquote>
<p>$I_s$ 是反向饱和电流，$V_T$ 是和温度相关的，室温下 $V_T$ 是 26 mv。 </p>
<p>Ge 作材料的晶体管导通电压是 0.2 ~ 0.3 V，Si 是 0.6 ~ 0.7 V。</p>
</blockquote>
<p>​        当 PN 结正偏且 $\left |  v \right |  \gg V_T$ 时，式子可简化为</p>
<script type="math/tex; mode=display">
i \approx I_se^{v/V_T}</script><p>​        当 PN 结反偏且 $\left |  v \right |  \gg V_T$ 时，式子可简化为</p>
<script type="math/tex; mode=display">
i \approx -I_s</script><p><img src="1.1-2.png" alt="1-2"></p>
<blockquote>
<p> 其实反向的时候有一个非常非常小的电流。</p>
</blockquote>
</li>
<li><p>击穿特性：当 PN 结的反向电压增大到某一值时，反向电流会突然增大，PN 结被击穿，击穿分为：雪崩击穿（掺杂浓度低的时候，PN 结宽）和齐纳击穿（掺杂浓度高的时候，PN 结窄）。</p>
<blockquote>
<p>雪崩击穿：温度越高，所需击穿电压越高。齐纳击穿：温度越高，所需击穿电压越低。</p>
</blockquote>
</li>
</ul>
</li>
<li><p>PN 结的电容效应</p>
<p>PN 结具有电荷随着电压变化而变化的特性，与电容类似。</p>
<p>PN 结的结电容是由以下两种电容组成的。</p>
<ul>
<li><p>势垒电容</p>
<blockquote>
<p>由空间电荷区的电荷所导致。反向电压越大，PN 结越宽，空间电荷区越宽，电容越大。</p>
</blockquote>
<p>  <img src="1.1-3.png" alt="1-3"></p>
</li>
<li><p>扩散电容</p>
<blockquote>
<p>由 P 区和 N 区粒子浓度差所导致。正向电压越大，N 区扩散来的电子越多，浓度越大，曲线也不断上升。这条曲线反映了从结到边缘处，粒子浓度越来越少。<strong>这种电容发生在扩散区内，是由靠近耗尽区和远离耗尽区的非平衡少子浓度差所造成的，且这种电荷的积累与释放过程与电容器充放电类似，故有电容效应，称为扩散电容。</strong></p>
</blockquote>
<p>  <img src="1.1-4.png" alt="1-4"></p>
</li>
</ul>
</li>
</ol>
</li>
</ul>
<h3 id="S-1-2-半导体二极管"><a href="#S-1-2-半导体二极管" class="headerlink" title="$\S 1.2$ 半导体二极管"></a>$\S 1.2$ 半导体二极管</h3><p>将 PN 结封装起来引出两根引线，形成二极管。</p>
<ul>
<li><p>常见结构</p>
<p><img src="1.2-1.png" alt="1.2-1"></p>
</li>
<li><p>二极管的伏安特性</p>
<ol>
<li><p>伏安特性</p>
<p>和 PN 结几乎一样，只是多了个外壳对电阻的影响。</p>
<p>由于体电阻的存在，二极管电流比 PN 结小。反向电流比 PN 结大一些。</p>
</li>
<li><p>温度对电阻的影响：</p>
<p><img src="1.2-2.png" alt="1.2-2"></p>
<blockquote>
<p>正向：相同电压下，温度越高，电流越大。</p>
<p>反向：相同电压下，温度越高，少子浓度越高，反向电流越大。 </p>
</blockquote>
</li>
</ol>
</li>
<li><p>二极管的主要参数</p>
<ol>
<li><p>最大整流电流 $I_F$</p>
<p>二极管长期运行时所允许的的最大正向平均电流。</p>
</li>
<li><p>最高反向工作电压 $U_R$</p>
<p>工作时允许外加的最大反向电压。一般是反向击穿电压 $U_{(BR)}$ 的一半。</p>
</li>
<li><p>反向电流 $I_R$</p>
<p>二极管未击穿时的反向电流，$I_R$ 越小，二极管单向导电性越好，$I_R$ 对温度很敏感。</p>
</li>
<li><p>最高工作频率 $f_M$</p>
<p>$f_M$ 是二极管的上限截止频率。由于结电容的存在，当二极管工作频率超过上限时，可以看作导通，就没有单向导电性了。</p>
<blockquote>
<p>交流电频率很高，不停地给电容进行充放电。而充放电的过程有电流流通，相当于通电。所以二极管变成双向导电，失去单向性。</p>
</blockquote>
</li>
</ol>
</li>
<li><p>二极管的等效电路</p>
<ol>
<li><p>伏安特性曲线折线化得到的电路</p>
<blockquote>
<p> 这是在直流情况下的。</p>
</blockquote>
<p>下图是二极管的常见等效模型。</p>
<p><img src="1.2-3.png" alt="1.2-3"></p>
</li>
<li><p>二极管的微变等效电路</p>
<blockquote>
<p>这是在交流情况下的。</p>
</blockquote>
<p>要求出二极管在交流电路中的等效电阻，我们先求出这个电路的直流电流（或者理解为交流电流的浮动中心），然后利用下图的变换，得出 $r_d \approx \dfrac{U_T}{I_D}$。</p>
<p><img src="1.2-4.png" alt="1.2-4"></p>
<p>现在二极管相当于是一个纯电阻 $r_d$，先前我们求出了直流电流 $I_D$，现在可以求出交流电流（此时电路相当于去掉直流电压） $i_d = \dfrac{u_i}{r_d + R}$，整个电路中的总电流为直流和交流电流之和 $i_D = I_D + i_d$。</p>
<blockquote>
<p>这里相当于为了让二极管变成电阻，必须要把上图的原点移到 Q 的位置处（因为电阻的伏安曲线是过原点的），而移到 Q 位置处需要的操作就是先把直流部分拿走，最后算总的时候再把直流部分加上。</p>
</blockquote>
<p><img src="1.2-5.png" alt="1.2-5"></p>
</li>
</ol>
</li>
<li><p>稳压二极管</p>
<p>稳压二极管是利用二极管反向导通时端电压几乎不变而制成。</p>
</li>
</ul>
<ol>
<li><p>伏安特性</p>
<p><img src="1.2-6.png" alt="1.2-6"></p>
<p>左图为稳压管的伏安特性曲线，与二极管几乎一样。主要利用反向的击穿区。右上是稳压二极管的符号。右下是稳压管的等效电路。</p>
</li>
<li><p>主要参数</p>
<p><strong>稳定电压 $U_Z$</strong></p>
<p>$U_Z$ 是在规定电流下稳压管的反向击穿电压。由于半导体器件参数的分散性，同一型号的稳压管的 $U_z$ 存在一定差别。</p>
<p><strong>稳定电流 $I_Z$</strong></p>
<p>$I_Z$ 是稳压管工作在稳压状态时的参考电流，电流低于此值时文雅效果变坏甚至不稳压，故也将 $I_Z$ 记作 $I_{Zmin}$。</p>
<p><strong>额定功耗 $P_{ZM}$</strong></p>
<p>$P_{ZM}$ 等于稳压管的稳定电压 $U_Z$ 与最大稳定电流 $I_{ZM}$（或记作 $I_{Zmax}$）的乘积。稳压管的功耗超过此值时，会因结温升过高而损坏。只要不超过稳压管的额定功率，电流愈大，稳压效果愈好。</p>
<p><strong>动态电阻 $r_z$</strong></p>
<p>$r_z$ 是稳压管工作在稳压区时，端电压变化量与其电流变化量之比，即 $r_z = \dfrac{\Delta U_Z}{\Delta I_Z}$。$r_z$ 越小，电流变化时 $U_Z$ 变化越小，即稳压管的稳压特性越好。</p>
<p><strong>温度系数 $\alpha$</strong></p>
<p>表示每变化 $1^{\circ}$ 稳压值的变化量，即 $\alpha = \dfrac{\Delta U_Z}{\Delta T}$。稳压值小于 $4$ V 的管子有负温度系数（属于齐纳击穿），即温度升高时稳定电压值下降，稳定电压大于 $7$ V 的管子具有正温度系数（属于雪崩击穿），即温度升高时稳定电压值上升；而稳定电压在 $4 \sim 7$ V 之间的管子温度系数非常小近似为 $0$（雪崩击穿和齐纳击穿都有）。</p>
<blockquote>
<p>温度低主要发生齐纳击穿，但齐纳击穿随着温度越高越容易发生。温度高主要发生雪崩击穿，但雪崩击穿随着温度越高越难发生。</p>
</blockquote>
</li>
</ol>
<h3 id="S-1-3-晶体三极管"><a href="#S-1-3-晶体三极管" class="headerlink" title="$\S 1.3$ 晶体三极管"></a>$\S 1.3$ 晶体三极管</h3><blockquote>
<p>三极管，我们可以控制的是基极电流 $I_B$，然后发射极的电子浓度高，会迁移产生放大的电流 $I_C$，$I_C$ 是我们想要的，$I_C$ 主要是由 $U_{CE}$ 和 $I_B$ 所决定。根据 $I_B$  以及 $U_{CE}$ 的不同，我们将输出特性曲线可以分为截止区，放大区，饱和区。而输入电流 $I_B$ 往往和 $U_{CE}$ 和 $U_{BE}$ 有关（通常研究 $U_{CE}$ 一定时 $U_{BE}$ 对 $I_B$ 的影响），并且当 $U_{CE}$ 大于 $1$ 时，$U_{CE}$ 的变化对 $I_B$ 几乎没有影响 。</p>
</blockquote>
<ul>
<li><p>晶体管的结构及类型</p>
<p>三个电极，三个区域，两个 PN 结。</p>
<p>右下两个图箭头方向代表的是发射结导通的方向。</p>
<p><img src="1.3-1.png" alt="1.3-1"></p>
</li>
<li><p>晶体管的电流放大作用</p>
<p>从电路角度来看，相当于集电区的电流是基区电流的放大。</p>
<p><img src="1.3-2.png" alt="1.3-2"></p>
<p>这是从内部结构变化来看，在理想工作状态下，发射极的电子向集电区和基区移动，主要还是向集电区。在这之中有微小的 基区到发射区的空穴 $I_{EP}$（忽略不计） 以及 集电区的电子和基区空穴的复合 $I_{CBO}$（忽略不计）。</p>
<blockquote>
<p>下图有两个量要注意一下，$I_{CEO}$ 是穿透电流，指的是基极开路时，集电极和发射极之间的电流。</p>
<p>$I_{CBO}$ 是发射极开路时，集电极的反向饱和电流。</p>
</blockquote>
<p><img src="1.3-3.png" alt="1.3-3"></p>
<p>从外部总体来看，$I_E = I_C + I_B$。</p>
<p><strong>共射直流电流放大系数</strong> $\bar \beta = \dfrac{I_{CN}}{I_B’} = \dfrac{I_C - I_{CBO}}{I_B + I_{CBO}}$。</p>
<p><strong>共射交流电流放大系数</strong> $\beta = \dfrac{\Delta i_{C}}{\Delta i_B}$。并且我们近似可以认为 $\beta \approx \bar \beta$。</p>
<p><strong>共基直流电流放大系数</strong> $\bar \alpha = \dfrac{I_{CN}}{I_E} = \dfrac{\bar \beta}{1 + \bar \beta}$，</p>
<p><strong>公基交流电流放大系数</strong> $\alpha = \dfrac{\Delta i_C}{\Delta i_E} = \dfrac{\beta}{1 + \beta}$。</p>
<p>通常情况下 $\beta \approx \bar \beta \gg 1$，$\alpha \approx \bar \alpha \approx 1$。</p>
</li>
<li><p>晶体管的共射特性曲线</p>
<ol>
<li><p>输入特性曲线</p>
<p><img src="1.3-4.png" alt="1.3-4"></p>
<p>$U_{CE}$ 越大，集电结场强越强，会让更多电子到集电区而不是去基区中和，所以相同 $U_{BE}$ 下 $U_{CE}$ 越大，$i_B$ 越小。而且 $U_{CE}$ 增大到一定程度时，集电结的电场已经足够强，可以让绝大部分电子都到集电极，所以这时候再增大 $U_{CE}$ 对 $i_B$ 影响不大。</p>
</li>
<li><p>输出特性曲线</p>
<p><img src="1.3-5.png" alt="1.3-5"></p>
<p>根据 $I_B$ 以及 $U_{CE}$ 大小关系可以将输出特性曲线分为三部分。</p>
<p>截止区相当于基区开路，这时候只有穿透电流 $I_{CEO}$。这时候发射结电压小于开启电压且集电结方向偏置。</p>
<p>饱和区是发射结正向偏置且集电结正向偏置，相当于一部分本应该到集电区的电流跑到了基区，集电极电流 $i_C$ 仍有上升的可能。这部分区域是由 $U_{CE}$ 过小导致的。</p>
<p>放大区是理想工作状态（绝大情况下），发射结正向偏置且集电结反向偏置。这时满足 $\bar \beta I_B = I_C$。</p>
<p>同时，我们把上面图和下面图比较</p>
<p><img src="1.3-8.png" alt="1.3-8"></p>
<p>同样是改变 $U_{CE}$，为什么一个是 $I_C$ 变大，一个是 $I_C$ 变小呢？</p>
<blockquote>
<p>因为第一张图里是 $I_B$ 固定，只改变 $U_{CE}$，这里想引起 $U_{CE}$ 的变化势必要改变 $U_{CC}$。而在第二张图里，$U_{CC}$ 是固定不动的，只变动 $I_B$，这里 $I_B$ 是通过改变输入电压源引起的。</p>
</blockquote>
</li>
</ol>
</li>
<li><p>主要参数</p>
<ol>
<li><p>直流参数</p>
<p><strong>共射直流电流放大系数</strong> $\bar \beta = \dfrac{I_{CN}}{I_B’} = \dfrac{I_C - I_{CBO}}{I_B + I_{CBO}}$。</p>
<p><strong>共基直流电流放大系数</strong> $\bar \alpha = \dfrac{I_{CN}}{I_E} = \dfrac{\bar \beta}{1 + \bar \beta}$。</p>
<p>$I_{CEO}$ 是穿透电流，指的是基极开路时，集电极和发射极之间的电流。</p>
<p>$I_{CBO}$ 是发射极开路时，集电极的反向饱和电流。且有 $I_{CEO} = (1 + \bar \beta)I_{CBO}$。</p>
</li>
<li><p>交流参数</p>
<p><strong>共射交流电流放大系数</strong> $\beta = \dfrac{\Delta i_{C}}{\Delta i_B}$。并且我们近似可以认为 $\beta \approx \bar \beta$。（此时 $U_{CE}$ 是常量）</p>
<p><strong>公基交流电流放大系数</strong> $\alpha = \dfrac{\Delta i_C}{\Delta i_E} = \dfrac{\beta}{1 + \beta}$。（此时 $U_{CB}$ 是常量）</p>
<p><strong>特征频率</strong> $f_T$ 由于晶体管的交流电流放大系数是所加信号频率的函数，所以放大系数会随着所加信号频率变化而变化。当信号频率高到一定程度时，集电极电流与基极电流之比不但下降且发生偏移。当频率达到特征频率 $f_T$ 时，放大系数会下降到 $1$ 以下。</p>
</li>
<li><p>极限参数</p>
<p><strong>最大集电极耗散功率 $P_{CM}$</strong></p>
<p>与温度相关，表示一定温度下晶体管集电极所能产生的最大耗散功率。</p>
<p><strong>最大集电极电流 $I_{CM}$</strong></p>
<p>$i_C$ 在相当大的范围内 $\beta$ 值基本不变，但当 $i_C$ 数值大到一定程度时 $\beta$ 将减小，使 $\beta$ 明显减小的 $i_C$ 即为 $I_{CM}$。</p>
<p><strong>极间反向击穿电压</strong></p>
<p>晶体管某一电极开路时，另外两个电极间所允许加的最高反向电压称为极间反向击穿电压，超过此值使管子会发生击穿现象。</p>
<p>$U_{(BR)CBO}$ 是发射极开路时集电极 - 基极间的反向击穿电压，这时集电结所允许加的最高反向电压。</p>
<p>$U_{(BR)CEO}$ 是基极开路时集电极 - 发射极间的反向击穿电压，这时集电结承受反向电压。</p>
<p>$U_{(BR)EBO}$ 是集电极开路时发射极 - 基极间的反向击穿电压，这时发射结所允许加的最高反向电压。</p>
</li>
</ol>
</li>
<li><p>光电三极管</p>
<p>光电三极管是依靠光照强度来控制集电极电流的大小，可等效为一只光电二极管加上一只晶体管，并仅引出集电极和发射极。光电三极管与普通三极管的输出特性曲线类似，<strong>只是将参变量基极电流 $I_B$ 用入射光强 $E$ 取代。</strong></p>
<p><img src="1.3-9.png" alt="1.3-9"></p>
</li>
<li><p>温度的影响</p>
<ol>
<li><p>$I_{CBO}$</p>
<p>$I_{CBO}$ 是平衡少子漂移运动形成的，温度升高时漂移加剧。故温度升高 $I_{CBO}$ 变大，又因为 $I_{CEO} = (1 + \bar \beta)I_{CBO}$，所以 $I_{CEO}$ 也会变大。</p>
</li>
<li><p>输入特性</p>
<p>与二极管类似，温度升高，图线左移，电流变大。</p>
<p><img src="1.3-6.png" alt="1.3-6"></p>
</li>
<li><p>输出特性</p>
<p>温度升高，所有电流都变大，且放大系数 $\beta$ 也会变大，导致集电极电流变大。</p>
<p><img src="1.3-7.png" alt="1.3-7"></p>
</li>
</ol>
</li>
</ul>
<h3 id="S-1-4-场效应管"><a href="#S-1-4-场效应管" class="headerlink" title="$\S 1.4$ 场效应管"></a>$\S 1.4$ 场效应管</h3><ul>
<li><p>结型场效应管</p>
<p><img src="E:\Blog\Ana_Su\source\_posts\Electronic-Devices-and-Circuit-Theory\1.4-6.png" alt="1.4-6"></p>
</li>
</ul>
<ul>
<li><p>绝缘栅型场效应管</p>
<blockquote>
<p>又叫做 MOS 管。</p>
</blockquote>
<ol>
<li><p>N 沟道增强型 MOS 管</p>
<p>源极 s，栅极 g，漏极 d。下图 b 中箭头方向代表的是 PN 结的方向。</p>
<blockquote>
<p><strong>注意下图包裹两个 $N^+$ 的阴影区不是二氧化硅！（因为剖面线和上面二氧化硅相反）事实上这是 N 和 P 接触所形成的 PN 结。</strong></p>
</blockquote>
<p><img src="E:\Blog\Ana_Su\source\_posts\Electronic-Devices-and-Circuit-Theory\1.4-1.png" alt="1.4-1"></p>
<p><strong>工作原理</strong></p>
<p>这里衬底 P 和栅极 g 相当于形成了极板的两极，中间是绝缘层形成电容。</p>
<p>当 $u_{DS} = 0$ 时， 刚一开始加电压的话，靠近栅极的空穴会向下移动，相当于栅极金属层会聚集正电荷，形成耗尽层，就会形成左下图所示的情况。当电压不断增大时，耗尽层不断加宽，并且将衬底 P 那边的自由电子吸引过来，自由电子吸引到耗尽层与绝缘层之间形成反型层，如右下图所示。这个反型层就形成了漏 - 源之间的导电沟道。使沟道刚刚形成的栅 - 源电压称为开启电压 $U_{GS(th)}$。$u_{GS}$ 决定了反型层厚度。$u_{GS}$ 越大，反型层越厚，导电沟道电阻越小。<strong>换言之，这是一个可由电压控制电阻的器件。</strong></p>
<p><img src="E:\Blog\Ana_Su\source\_posts\Electronic-Devices-and-Circuit-Theory\1.4-2.png" alt="1.4-2"></p>
<p>当 $u_{GS}$ 一定且大于形成沟道的临界值时，我们外加一个 $u_{DS}$，随着 $u_{DS}$ 的不断增大，我们发现右边通过的反型层不断缩减，这是因为反型层是由于电压差形成的，而最左边反型层电压差是 $u_{GS}$，但是到了最右边就是 $u_{GS} - u_{DS}$（可以这样理解：$u_{DS}$ 电压越大，d 端电势越高，沟道中的电子就会被吸收的更多，故靠近 d 端的沟道变窄，因为 g 端电势也会吸引电子，所以可以理解成两端电势相减是沟道靠近 d 端的宽度），换言之一部分 $u_{DS}$ 会抵消反型层中的电压。当 $u_{DS}$ 大到一定程度时会预夹断反型层（不是真的夹断，因为没有电流以后沟道的电压就和衬底一样了，在 $u_{gs}$ 作用下又会打开沟道，所以不会真的夹断）。在此之后随着 $u_{DS}$ 越来越大，夹断区的缝隙越来越大。</p>
<p><img src="E:\Blog\Ana_Su\source\_posts\Electronic-Devices-and-Circuit-Theory\1.4-3.png" alt="1.4-3"></p>
<p>当 $u_{DS}$ 较小时，还没达到夹断的电压，此时 $r_{ds}$ 看作定值电阻，这个电阻值与 $u_{GS}$ 相关，当 $u_{DS}$ 较大时，会发生预夹断，此时电流就会保持恒定不变，此时的恒定电流值与 $u_{GS}$ 有关。也就是说 $u_{GS}$ 在 $u_{DS}$ 较小时决定电阻值，在 $u_{DS}$ 较大时决定电流值。 </p>
<p><img src="E:\Blog\Ana_Su\source\_posts\Electronic-Devices-and-Circuit-Theory\1.4-4.png" alt="1.4-4"></p>
</li>
<li><p>N 沟道耗尽型 MOS 管</p>
<p>上面的情况是外加一个电压才能出现反型层，但对于N 沟道耗尽型 MOS 管，绝缘层二氧化硅中已经掺入大量正离子，所以初始就会形成反型层。当外加的电压 $u_{GS}$ 为负值时，反型层会变窄，沟道电阻变大。当 $u_{GS}$ 小到一定程度时，反型层消失，此时称为夹断电压。</p>
<p><img src="1.4-5.png" alt="1.4-5"></p>
</li>
<li><p>特性曲线与电流方程</p>
</li>
</ol>
</li>
</ul>
<ul>
<li><p>场效应管的主要参数</p>
<ol>
<li><p>直流参数</p>
<p>开启电压 $U_{GS(th)}$</p>
<p>夹断电压 $U_{GS(off)}$</p>
<p>饱和漏极电流 $I_{DSS}$</p>
<p>直流输入电阻 $R_{GS(DC)}$</p>
</li>
<li><p>交流参数</p>
<p>低频跨导 $g_m$</p>
<p>极间电容</p>
</li>
<li><p>极限参数</p>
<p>最大漏极电流 $I_{DM}$</p>
<p>击穿电压</p>
<p>最大耗散功率 $P_{DM}$</p>
</li>
</ol>
</li>
</ul>
<blockquote>
<p>第9讲后半没完全弄明白。</p>
</blockquote>
<h2 id="第二章-基本放大电路"><a href="#第二章-基本放大电路" class="headerlink" title="第二章 基本放大电路"></a>第二章 基本放大电路</h2><h3 id="S-2-1-放大的概念和放大电路的主要性能指标"><a href="#S-2-1-放大的概念和放大电路的主要性能指标" class="headerlink" title="$\S 2.1$ 放大的概念和放大电路的主要性能指标"></a>$\S 2.1$ 放大的概念和放大电路的主要性能指标</h3><ul>
<li><p>放大的概念</p>
<p>放大电路的特征是功率的放大。</p>
<p>放大电路的本质是能量的控制和转换。</p>
<p>放大电路的必要条件是有源元件，可以控制能量（比如晶体管和场效应管）。</p>
<p>放大的前提是不失真，只有在不知真的情况下放大才有意义（让晶体管工作在放大区，场效应管工作在恒流区）。</p>
<p>放大电路的测试信号是正弦波。</p>
</li>
<li><p>基本放大电路的构建</p>
</li>
</ul>
<h3 id="S-2-2-基本共射放大电路的工作原理"><a href="#S-2-2-基本共射放大电路的工作原理" class="headerlink" title="$\S 2.2$ 基本共射放大电路的工作原理"></a>$\S 2.2$ 基本共射放大电路的工作原理</h3><h3 id="S-2-3-放大电路的分析方法"><a href="#S-2-3-放大电路的分析方法" class="headerlink" title="$\S 2.3$ 放大电路的分析方法"></a>$\S 2.3$ 放大电路的分析方法</h3><blockquote>
<p>17 讲没听。</p>
</blockquote>
<h2 id="第三章-多极放大电路"><a href="#第三章-多极放大电路" class="headerlink" title="第三章 多极放大电路"></a>第三章 多极放大电路</h2><h3 id="S-3-1-多级放大电路的一般问题"><a href="#S-3-1-多级放大电路的一般问题" class="headerlink" title="$\S 3.1$ 多级放大电路的一般问题"></a>$\S 3.1$ 多级放大电路的一般问题</h3>]]></content>
      <tags>
        <tag>专业课</tag>
        <tag>大学课程</tag>
      </tags>
  </entry>
  <entry>
    <title>大学笔记 | 复变函数与积分变换</title>
    <url>/2023/08/31/Functions-of-a-Complex-Variable/</url>
    <content><![CDATA[<p>隐身术第二课堂。</p>
<span id="more"></span>
<blockquote>
<p><strong>Attention!</strong></p>
<p><strong>$u = \Re[z] $ 称为实部，$z = \Im[z]$ 称为虚部。</strong> </p>
</blockquote>
<h2 id="第一章-复数与复变函数"><a href="#第一章-复数与复变函数" class="headerlink" title="第一章 复数与复变函数"></a>第一章 复数与复变函数</h2><h3 id="第一章总结"><a href="#第一章总结" class="headerlink" title="第一章总结"></a>第一章总结</h3><h3 id="S-1-1-复数及其几何表示"><a href="#S-1-1-复数及其几何表示" class="headerlink" title="$\S 1.1$ 复数及其几何表示"></a>$\S 1.1$ 复数及其几何表示</h3><ul>
<li>复数可以用点 / 向量 / 矩阵表示。</li>
<li>$Argz$ 是复数的辐角，$argz$ 是辐角在 $(-\pi, \pi]$ 中的值，又称为辐角的主值（$\left | z\right | = 0$ 时辐角无意义）。$Argz = argz + 2k\pi$。</li>
<li>复数 $z = x + iy = r(\cos\theta + i\sin\theta) = re^{i\theta}$。</li>
<li>复数 $n$ 次幂 $z^n = r^ne^{in\theta} = r^n(\cos n\theta + i\sin n\theta)$</li>
<li><p><strong>复数 $n$ 次方根 $w = \sqrt[n]{z} = \sqrt[n]r(\cos \dfrac{\theta + 2k\pi}{n} + i\sin \dfrac{\theta + 2k\pi}{n})$，$k$ 从 $0$ 取到 $n - 1$ 时，对应会有 $n$ 个不同的方根。</strong></p>
</li>
<li><p>表示复数的平面称为复平面，表示复数的球面称为复球面。</p>
</li>
<li>某复数对应的球面上的点，复平面上的点和复球面的 $N$ 极三点共线。（除 $N$ 极外，球面和平面上的点一一对应）</li>
<li>我们在复平面上引入一个 $\infty$ 点与球面 $N$ 极相对应，并将复平面加上无穷远点称为<strong>扩充复平面</strong>，与扩充复平面一一对应的平面称为<strong>复球面</strong>，没有 $\infty$ 的复平面称为 <strong>（有限）复平面</strong>。</li>
<li>对于复数 $\infty$，其实部，虚部，幅角均没有意义，其模长为 $\infty$，并且四则运算与实数 $\infty$ 相同。</li>
</ul>
<h3 id="S-1-2-复变函数"><a href="#S-1-2-复变函数" class="headerlink" title="$\S 1.2$ 复变函数"></a>$\S 1.2$ 复变函数</h3><ul>
<li><p>复变函数就是变量为复变量的函数（可能一对一，可能一对多）。</p>
</li>
<li><p>区域的概念同二元函数中的概念。</p>
<blockquote>
<p>开集就是一块点集不算上边界。</p>
<p>连通的开集称为区域。</p>
<p>算上边界的开集是闭区域。</p>
<p>自身无交叉点的曲线称为简单曲线。</p>
<p>单连通域内部实心，多连通域内部不是实心。</p>
</blockquote>
</li>
<li><p>对于<strong>连续曲线</strong> $C$ 有 $x = x(t), y = y(t)$，则称$z(t) = x(t) + iy(t)$ 为平面曲线的复数表示式。若 $x’(t), y’(t)$ 均连续且不同时为 $0$，则称 $z(t)$ 为光滑曲线。由几段光滑曲线联接而成的曲线称为<strong>按段光滑曲线</strong>。</p>
</li>
<li><p>自身无重点的曲线称为<strong>简单曲线</strong>。起点和重点重合的简单曲线称为<strong>简单闭曲线</strong>。</p>
</li>
<li><p>若区域 $D$ 内任意简单简单闭曲线的内部都属于 $D$，则称 $D$ 为单连通域，否则称为多连通域。</p>
</li>
<li><p>复变函数可化为两个实变函数相加，求复变函数的极限 / 连续 / 有界问题也可以化为两个实变函数的极限 / 连续 / 有界问题。</p>
</li>
</ul>
<h3 id="习题课"><a href="#习题课" class="headerlink" title="习题课"></a>习题课</h3><p><img src="1.3-1.png" alt="1.3-1"></p>
<p><img src="1.3-2.png" alt="1.3-2"></p>
<h2 id="第二章-解析函数"><a href="#第二章-解析函数" class="headerlink" title="第二章 解析函数"></a>第二章 解析函数</h2><h3 id="第二章总结"><a href="#第二章总结" class="headerlink" title="第二章总结"></a>第二章总结</h3><ul>
<li><p>求导</p>
<p>形如 $w = f(z)$ 的导数，与一元函数求导方法一样。</p>
<p>形如 $f(z) = u(x, y) + iv(x, y)$ 的导数，求导公式为 $f’(z) = \dfrac{\part u}{\part x} + i\dfrac{\part v}{\part x} = \dfrac{\part v}{\part y} - i\dfrac{\part u}{\part y}$。</p>
</li>
<li><p>相关概念</p>
<p>在某点解析：指的是在该点及邻域可导。</p>
<p>奇点：函数不解析的点。</p>
<p>解析函数：函数在某区域内处处可导。</p>
<p>函数可导与解析的判定：先求出 $f(z) = u(x, y) + iv(x, y)$ 的偏导数，然后判定偏导数是否满足 $C-R$ 方程：$u_x = v_y, u_y = -v_x$。</p>
<blockquote>
<p>如果在某点出成立，则函数在该点可导。如果某区域内成立，则在该区域内解析。</p>
</blockquote>
</li>
<li><p>初等函数</p>
<p><strong>指数函数</strong></p>
<p>$w = e^z = e^x(\cos y + i\sin y)$</p>
<p>基本上和实数情况一样，只是多了周期性。</p>
<p><strong>对数函数</strong></p>
<p>$Ln z = \ln |z| + i\arg z + 2k \pi i$</p>
<p>对数函数是多值函数，其主值是 $\ln z = \ln|z| + 2i\arg z$。</p>
<p>对数函数在<strong>除去原点与负实轴的复平面</strong>上连续且解析。</p>
<p>对数函数的积商公式依然成立，但是对数函数的 $n$ 次方公式以及对数函数的开 $n$ 方根公式就不成立了（因为后面加上的 $2\pi i $ 的系数不同）。</p>
<p><strong>幂函数</strong></p>
<p>$w = z^{\alpha} = e^{\alpha Ln z} = e^{\alpha(\ln |z| + i\arg z + 2k\pi i)}$</p>
<p>当 $\alpha$ 是整数时，幂函数是单值函数。而当不是整数时，函数是多值函数。</p>
<p>当 $\alpha$ 不是整数时，幂函数在<strong>除去原点与负实轴的复平面</strong>上连续且解析。</p>
<p><strong>三角函数</strong></p>
<script type="math/tex; mode=display">
\sin z = \dfrac{e^{iz} - e^{-iz}}{2i}, \\
\cos z = \dfrac{e^{iz} + e^{-iz}}{2}</script><p>值得注意的是，复数域上三角函数<strong>是无界的！</strong></p>
<p>不过除了无界外，其他是一样的。</p>
</li>
</ul>
<h3 id="S-2-1-解析函数的概念"><a href="#S-2-1-解析函数的概念" class="headerlink" title="$\S 2.1$ 解析函数的概念"></a>$\S 2.1$ 解析函数的概念</h3><ul>
<li><p>可导必连续，连续未必可导（同二元函数）</p>
</li>
<li><p>复变函数求导与<strong>一元</strong>实变函数相同</p>
</li>
<li><p>若 $w = f(z)$ 在 $z_0$ <strong>及 $z_0$ 的领域内</strong>处处可导，则称 $f(z)$ 在 $z_0$ 解析，$z_0$ 称为解析点。</p>
<p>  若 $f(z)$ 在区域 $D$ 内每一点都解析，则 $f(z)$ 是 $D$ 内的解析函数。</p>
<p>  若 $f(z)$ 在 $z_0$不解析，称 $z_0$ 为 $f(z)$ 的奇点。</p>
<blockquote>
<p>注意以下解析和求导的区别，可导要求某个点，解析要求的是某点及邻域。</p>
<p>在某点处，解析必可导，可导未必解析。</p>
<p>在某区域内，解析与可导等价。</p>
<p><strong>在某区域内，判断解析性往往要靠求导去判断（若是看作一元函数，直接求导解决，若是看作二元函数，在证明不可解析时可以化作二元函数极限不存在来求）。</strong></p>
</blockquote>
</li>
</ul>
<p><img src="2.1-1.png" alt="2.1-1"></p>
<h3 id="S-2-2-函数解析的重要条件"><a href="#S-2-2-函数解析的重要条件" class="headerlink" title="$\S 2.2$ 函数解析的重要条件"></a>$\S 2.2$ 函数解析的重要条件</h3><ul>
<li><p>函数 $f(z) = u(x, y) + iv(x, y)$ 在点 $z = x + iy$ 处可导的充要条件是：</p>
<ul>
<li>$u(x, y)$ 和 $v(x, y)$ 在 $(x, y)$ 可微</li>
<li><p>在点 $(x, y)$ 满足<strong>柯西-黎曼方程</strong>：$\dfrac{\partial u}{\partial x} = \dfrac{\partial v}{\partial y},\dfrac{\partial u}{\partial y} = -\dfrac{\partial v}{\partial x}$</p>
<blockquote>
<p>关于可导和可微：在一元函数中，它们互为充要条件，在多元中可微是可导的必要条件，可导不一定可微。</p>
</blockquote>
</li>
</ul>
</li>
<li><p>由于在某一区域内，函数解析与可导等价，函数 $f(z) = u(x, y) + iv(x, y)$ 在区域 $D$ 内解析的充要条件是：</p>
<ul>
<li>$u(x, y)$ 和 $v(x, y)$ 在 $D$ 内可微</li>
<li><p>满足<strong>柯西-黎曼方程</strong>：$\dfrac{\partial u}{\partial x} = \dfrac{\partial v}{\partial y},\dfrac{\partial u}{\partial y} = -\dfrac{\partial v}{\partial x}$</p>
<blockquote>
<p>值得一提的是，当满足该条件时，$f’(z) = \dfrac{\partial u}{\partial x} + i\dfrac{\partial v}{\partial x} = \dfrac{1}{i}\dfrac{\partial u}{\partial y} + \dfrac{\partial v}{\partial y}$</p>
</blockquote>
</li>
</ul>
</li>
<li><p>讨论函数解析性，需证明函数可微，主要有以下两种方法：</p>
<ul>
<li>用可微的定义：$\Delta u = A_1\Delta x + B_1\Delta y + o(\rho)$（较难，不推荐）。</li>
<li>用可微的充分条件，判断 $u(x, y)$，$v(x, y)$ 的偏导数连续来证明可微。</li>
</ul>
</li>
</ul>
<p><img src="2.2-1.png" alt="2.2-1"></p>
<p><img src="2.2-2.png" alt="2.2-2"></p>
<h3 id="S-2-3-初等函数"><a href="#S-2-3-初等函数" class="headerlink" title="$\S 2.3$ 初等函数"></a>$\S 2.3$ 初等函数</h3><p>复变量的初等函数和实变量的基本相同，但<strong>个别区别较大</strong>。</p>
<ul>
<li><p>指数函数</p>
<p>  $w = e^z = e^{x + iy} = e^x(\cos y + i\sin y)$，且满足原有的求导公式。</p>
<p>  注意区别的是 $w = e^z$ 是以 $2k\pi i$ 为周期的函数。</p>
<p>  指数函数在复平面内处处解析。</p>
</li>
<li><p>对数函数（区别较大）</p>
<p>  指数函数 $e^w = z$ 的反函数 $w = f(z)$ 称为对数函数，记作 $w = Ln z$。</p>
<p>  由 $e^{u + iv} = e^ue^{iv} = e^u(\cos v + i\sin v)$，我们有 $u = \ln|z|,v = \theta + 2k\pi = Arg z$。故 $Lnz = \ln|z| + iArgz = \ln|z| + i\arg z + 2k\pi i$。</p>
<p>  记 $\ln z = \ln|z| + i\arg z$ 为 $Lnz$ 的主值。对于给定不同的 $k$ 所形成的不同 $Lnz$ 称为其中一个分支。$\ln z$ 满足原有的求导公式。</p>
<blockquote>
<p><strong>注意复数 $z$ 的模长只和实部 $u$ 有关。</strong></p>
</blockquote>
<p>  此时对数函数的积商公式仍然成立 $Lnz_1z_2 = Lnz_1 + Lnz_2,Ln\dfrac{z_1}{z_2} = Lnz_1 - Lnz_2$。</p>
<p>  但是 $n$ 次幂和 $n$ 次方根的对数公式不再成立。</p>
<blockquote>
<p>由于 $Lnz^n = n\ln|z| + in\arg z + 2k_1\pi i$ 而 $nLnz = n\ln|z| + in\arg z + n2k_2\pi i$ 后面的 $2\pi i$ 的系数不同，故不相等。</p>
</blockquote>
<p>  由于 $\ln|z|$ 除了原点外处处解析，而 $\arg z$ 在原点和负实轴上不连续，故对数函数的主值 $\ln z$ 在除去原点和负实轴的平面上连续，同理 $Ln z$ 的各个分支在除原点和负实轴的复平面上解析。</p>
</li>
<li><p>幂函数</p>
<p>  $w = z^n$ 是复平面内的单值解析函数，$w = z^{-n}$ 除原点外是单值解析函数（$n \in \N$）。</p>
<p>  $w = z^\alpha = e^{\alpha Lnz} = e^{\alpha(ln|z| + iargz)}e^{2k\alpha \pi i}$，不难发现如果 $\alpha$ 是整数，则 $w$ 必是单值函数，但 $\alpha$ 取小数时，$w$ 可能是多值函数。</p>
<p>  由于 $Lnz$ 的各分支在除去原点和负实轴的平面上是解析的，所以 $w = z^{\alpha}$ <strong>的各分支</strong>在除去原点和负实轴的平面上是解析的（<strong>注意多值函数是不可解析的</strong>）。</p>
<p>  幂函数的导数和之前相同。</p>
</li>
</ul>
<p><img src="2.3-1.png" alt="2.3-1"></p>
<ul>
<li><p>三角函数</p>
<p>  由欧拉公式，易得 $\sin z = \dfrac{e^{iz} - e^{-iz}}{2i}$，$\cos z = \dfrac{e^{iz} + e^{-iz}}{2}$。</p>
<p>  以前学过的三角函数公式全都适用。</p>
<p>  <strong>三角函数在复数域是无界函数。</strong></p>
<p>  $\sin z$ 是奇函数，$\cos z$ 是偶函数，且它们依然是以 $2\pi$ 为周期的。</p>
<p>  求导和之前相同，且在整个复平面上解析。</p>
</li>
</ul>
<h3 id="习题课-1"><a href="#习题课-1" class="headerlink" title="习题课"></a>习题课</h3><h2 id="第三章-复变函数的积分"><a href="#第三章-复变函数的积分" class="headerlink" title="第三章 复变函数的积分"></a>第三章 复变函数的积分</h2><h3 id="第三章总结"><a href="#第三章总结" class="headerlink" title="第三章总结"></a>第三章总结</h3><ul>
<li><p>若 $f(z)$ 不解析，$\int f(z)$ 按路径来设变量，分别积分再加起来。</p>
<blockquote>
<p><strong>此时不能直接积分！一定要按路径来！</strong></p>
<p><strong>只有解析函数积分与路径无关，可以直接求解。</strong></p>
</blockquote>
</li>
<li><p>积分与路径无关的条件是 $f(z)$ 在单连通域内解析。</p>
</li>
<li><p>柯西积分定理 $f(z)$ 在 $C$ 内处处连续，处处解析，那么 $\oint_C f(z)dz = 0$。</p>
</li>
<li><p>复合闭路定理 外面大圈积分等于里面小圈积分和 $\int_C f(z)dz = \sum_{k = 1}^n \oint_{C_k}f(z)dz$。</p>
</li>
<li><p>柯西积分公式 $\oint_C \dfrac{f(z)}{z - z_0}dz = 2 \pi i f(z_0)$，$z_0$ 为任一点，要保证闭曲线内只有一个奇点。</p>
</li>
<li><p>高阶导数公式 $f^{(n)}(z_0) = \dfrac{n!}{2\pi i}\oint_C \dfrac{f(z)}{(z - z_0)^{n + 1}}dz$，$z_0$ 为任一点，要保证闭曲线内只有一个奇点。</p>
</li>
<li><p>对于多个奇点，以这些奇点为圆心做圆周，然后由复合闭路定理：$\int_C f(z)dz = \sum_{k = 1}^n \oint_{C_k}f(z)dz$，就可以化为 $n$ 个单奇点的积分。注意若没有奇点，说明单连通域内处处可解析，此时用柯西 - 古萨特定理直接得出积分为 $0$。</p>
</li>
<li><p>调和函数：满足二阶偏导数连续且满足拉普拉斯方程。</p>
</li>
<li><p>共轭调和函数：指一对调和函数 $u(x, y),v(x, y)$ 满足 $f(z) = u(x, y) + iv(x, y)$ 是解析函数。 这样的 $u(x, y),v(x, y)$ 是一对共轭调和函数。</p>
</li>
<li><p>求解析函数（已知实部或虚部）：全微分法，偏微分法，原函数法（首选）。</p>
</li>
</ul>
<h3 id="S-3-1-复变函数积分的概念"><a href="#S-3-1-复变函数积分的概念" class="headerlink" title="$\S 3.1$ 复变函数积分的概念"></a>$\S 3.1$ 复变函数积分的概念</h3><p>复变函数积分可分解为两个实变函数第二型曲线积分</p>
<ul>
<li><p>若 $f(z) = u(x, y) + iv(x, y)$ 沿 $C$ 可积，则 $\int_C f(z)dz = \int_C u(x, y)dx - v(x, y)dy + i\int_C v(x, y)dx + u(x, y)dy$</p>
<p>若函数不解析，往往根据不同的路径选取积分变换。<strong>此时不能直接积分！一定要按路径来！</strong></p>
</li>
<li><p><strong>且基本上第二型曲线积分中的技巧均可以运用在复变函数积分中。</strong></p>
</li>
</ul>
<h3 id="S-3-2-柯西积分定理"><a href="#S-3-2-柯西积分定理" class="headerlink" title="$\S 3.2$ 柯西积分定理"></a>$\S 3.2$ 柯西积分定理</h3><ul>
<li><p>柯西积分定理（柯西 - 古萨特基本定理）</p>
<p>若 $f(z)$ 在单连通域 $D$ 内<strong>解析</strong>，则对任意一条简单闭曲线 $C$，有 $\oint_C f(z)dz = 0$。</p>
<blockquote>
<p>函数在某一处解析的定义：函数在该点及该点的邻域内处处可导。</p>
</blockquote>
</li>
<li><p>积分与路径无关条件</p>
<p>若 $f(z)$ 在单连通域 $D$ 内解析，则积分与路径无关。</p>
</li>
<li><p>我们将单连通上的柯西定理，同样可以引入到多连通域上。我们定义复合闭路：</p>
<p><img src="3.2-1.png" alt="3.2-1"></p>
<p>复合闭路是长这样的</p>
<p><img src="3.2-2.png" alt="3.2-2"></p>
</li>
<li><p>闭路变形原理：</p>
<p><img src="3.2-3.png" alt="3.2-3"></p>
<p>这个定理告诉我们，对于解析函数 $f(z)$ 沿闭曲线 $C$ 的积分，当闭曲线 $C$ 在函数 $f(z)$ 的解析区域内<strong>连续变形</strong>时，积分值不变。</p>
</li>
<li><p>与单连通域上 积分与路径无关 的情况类似，我们在多连通域上有复合闭路定理、</p>
<p><img src="3.2-4.png" alt="3.2-4"></p>
</li>
<li><p>原函数</p>
<p>对于解析函数 $f(z)$ 在单连通域内，沿简单曲线的积分与路径无关，只与起点终点有关。当我们把起点固定，终点变动时，我们可以定义一个以 $z$ 为变量的单值函数：$F(z) = \int_{z_0}^{z}f(t)dt$。</p>
<p>若 $f(z)$ 在单连通域内解析，那么 $F(z)$ 也在单连通域内解析，且 $F’(z) = f(z)$。</p>
<p>其实和积分上的原函数定义是一样的，原函数的形式是 $F(z) = \int_{z_0}^z f(t)dt + C$。</p>
</li>
</ul>
<h3 id="S-3-3-柯西积分公式"><a href="#S-3-3-柯西积分公式" class="headerlink" title="$\S 3.3$ 柯西积分公式"></a>$\S 3.3$ 柯西积分公式</h3><ul>
<li><p>柯西积分公式</p>
<p><img src="3.3-1.png" alt="3.3-1"></p>
</li>
</ul>
<h3 id="S-3-4-解析函数的高阶导数"><a href="#S-3-4-解析函数的高阶导数" class="headerlink" title="$\S 3.4$ 解析函数的高阶导数"></a>$\S 3.4$ 解析函数的高阶导数</h3><ul>
<li><p>解析函数的高阶导数</p>
<p>解析函数的导数，还是解析函数，并且 $f^{(n)}(z_0) = \dfrac{n!}{2\pi i}\oint_C \dfrac{f(z)}{(z - z_0)^{n + 1}}dz$</p>
<blockquote>
<p>和上一节同理，$z_0$ 一定要是奇点且高阶导数公式只适用于 $C$ 内只有一个奇点的积分。所以解决含多个奇点的情况要以多个奇点为圆心分别进行高阶导数公式。</p>
</blockquote>
</li>
<li><p>例题</p>
<p>求 $\oint_C \dfrac{e^z}{(z^2 + 1)^2}dz$</p>
<p><img src="3.4-1.png" alt="3.4-1"></p>
</li>
</ul>
<h3 id="S-3-5-调和函数"><a href="#S-3-5-调和函数" class="headerlink" title="$\S 3.5$ 调和函数"></a>$\S 3.5$ 调和函数</h3><p><img src="3.5-1.png" alt="3.5-1"></p>
<ul>
<li><p>解析函数与调和函数的关系</p>
<p>若 $f(z) = u(x, y) + iv(x, y)$ 在 $D$ 内解析，则 $u(x, y)$ 和 $(v, y)$ 都是 $D$ 内的调和函数。</p>
<blockquote>
<p><strong>解析的条件比调和更加严格，它需要 $u(x, y)$ 和 $v(x, y)$ 分别调和的情况下，二中之间也满足 $C-R$ 方程。</strong></p>
</blockquote>
</li>
<li><p><img src="3.5-2.png" alt="3.5-2"></p>
</li>
<li><p>由于解析函数实部 $u(x, y)$ 和虚部 $v(x, y)$ 满足 $C-R$ 方程（$\dfrac{\partial u}{\partial x} = \dfrac{\partial v}{\partial y},\dfrac{\partial u}{\partial y} = -\dfrac{\partial v}{\partial x} $），所以我们知道实部或虚部中一个就能求出另外一个。</p>
<blockquote>
<p>具体可用全微分法或偏微分法（先对 $x$ 积分，再对 $y$ 积分）。也可以用原函数法（如下）。</p>
</blockquote>
</li>
<li><p><img src="3.5-3.png" alt="3.5-3"></p>
<blockquote>
<p>公式 $f’(z) = u_x - iu_y = v_y + iv_x$ 由第二章中推出。</p>
</blockquote>
</li>
<li><p>例题</p>
<p><img src="3.5-4.png" alt="3.5-4"></p>
<blockquote>
<p>原函数法的应用。</p>
</blockquote>
</li>
</ul>
<h3 id="习题课-2"><a href="#习题课-2" class="headerlink" title="习题课"></a>习题课</h3><p><img src="3.6-1.png" alt="3.6-1"></p>
<p><img src="3.6-2.png" alt="3.6-2"></p>
<blockquote>
<p>有前面的高阶导数公式可知，这里的 $r$ 取任一个小于 $1$ 的值都可以。</p>
</blockquote>
<p><img src="3.6-3.png" alt="3.6-3"></p>
<h2 id="第四章-级数"><a href="#第四章-级数" class="headerlink" title="第四章 级数"></a>第四章 级数</h2><h3 id="第四章总结"><a href="#第四章总结" class="headerlink" title="第四章总结"></a>第四章总结</h3><ul>
<li><p>复数列收敛要求实部极限和虚部极限均收敛。</p>
</li>
<li><p>复数列收敛半径 $R = \dfrac{1}{\lambda}$（其中 $\lambda$ 可以用比值法或根值法算），复数列的收敛域构成一个收敛圆。</p>
</li>
<li><p>复数列可以泰勒展开，收敛域是一个收敛圆，收敛半径是到最近奇点的距离。</p>
<blockquote>
<p>常用幂级数展开</p>
<script type="math/tex; mode=display">
\begin{gather*}
\frac{1}{1-x} = \sum_{n = 0}^{\infty}x^{n},\ \frac{1}{1+x} = \sum_{n = 0}^{\infty}(-1)^nx^{n}\ (-1 < x < 1)
\newline e^x = \sum_{n = 0}^{\infty}\frac{x^n}{n!}\ (-\infty < x < \infty)
\newline \sin x = \sum_{n = 0}^{\infty}(-1)^n\frac{x^{2n+1}}{(2n+1)!}\ (-\infty < x < \infty)
\newline \cos x = \sum_{n = 0}^{\infty}(-1)^n\frac{x^{2n}}{(2n)!}\ (-\infty < x < \infty)
\newline \ln(1 + x) = \sum_{n = 0}^{\infty} (-1)^n\frac{x^{n + 1}}{n + 1}\ (-1 < x \le 1)
\newline \arctan x = \sum_{n = 0}^{\infty} (-1)^n\frac{x^{2n + 1}}{2n + 1}\ (-1 \le x \le 1)
\end{gather*}</script></blockquote>
</li>
<li><p>复数列可以洛朗展开，其收敛域是收敛圆环，$\sum_{n = 0}^{\infty}c_n(z - z_0)^n = \sum_{n = 1}^{\infty}c_{-n}(z - z_0)^{-n} + \sum_{n = 0}^{\infty}c_n(z - z_0)^n$。且系数 $c_n$ 满足公式 $c_n = \dfrac{1}{2\pi i} \oint\dfrac{f(\xi)}{(\xi - z_0)^{n + 1}}d\xi$。</p>
</li>
<li><p>利用系数 $c_n$ 公式可以推导出 $\oint_C f(z)dz = 2\pi ic_{-1}$。（这里收敛圆环要满足所有奇点都在小圆内）</p>
</li>
</ul>
<h3 id="S-4-1-复级数"><a href="#S-4-1-复级数" class="headerlink" title="$\S 4.1$ 复级数"></a>$\S 4.1$ 复级数</h3><ul>
<li><p>复数列</p>
<p>$\{z_n\} = \{x_n + iy_n\}$ 是复数列，其极限判断以及四则运算与实数列相同。</p>
</li>
<li><p>复数项级数</p>
<p>复数列所有项的和称为复数项级数，$\sum_{n = 1}^{\infty}z_n = z_1 + z_2 + \dots$</p>
<p>级数收敛与发散的定义与实数级数相同。</p>
<p>复数项级数收敛的<strong>充要条件</strong>是实部和虚部<strong>都收敛</strong>。</p>
<p>复数项级数收敛的<strong>必要条件</strong>是 $\lim_{n \to \infty} z_n = 0$。</p>
</li>
<li><p>绝对收敛与条件收敛</p>
<p>若 $\sum_{n = 1}^{\infty} |z_n|$ 收敛，则该复数列绝对收敛。</p>
<p>不绝对收敛的收敛级数称为条件收敛。</p>
</li>
<li><p>判断复数项级数敛散性的方法</p>
<p>实部虚部分开讨论或在一起直接判定。</p>
<blockquote>
<p>一些基本技巧可以用正项级数的判定技巧。</p>
</blockquote>
</li>
<li><p>复变函数项级数</p>
<p>设 $\{f_n(z)\}$ 是区域 $D$ 内的函数列，称 $\sum_{n = 1}^{\infty} f_n(z)$ 为复变函数项级数。</p>
<p>若 $D$ 内有一点 $z_0$，满足 $\lim_{n \to \infty} S_n(z_0) = S(z_0)$，称 $z_0$ 是级数的收敛点。即 $S(z_0) = \sum_{n = 1}^{\infty}f_n(z_0)$。</p>
<p>若级数在 $D$ 内处处收敛，则称 $S(z) = \sum_{n = 1}^{\infty}f_n(z)$ 为级数的和函数。</p>
</li>
<li><p>幂级数</p>
<p>形如 $\sum_{n = 0}^{\infty}c_n(z - z_0)^n$ 的级数。</p>
<p><img src="4.1-1.png" alt="4.1-1"></p>
<p>由 $Abel$ 定理可知，必存在一个圆域，使得幂级数在圆域内绝对收敛，在圆域外发散。但对于圆周上的幂级数的敛散性要单独讨论。</p>
<p>故我们可以定义圆周 $|z| = R$ 称为幂级数 $\sum_{n = 0}^{\infty}c_nz^n$ 的收敛圆，$R$ 称为收敛半径。</p>
</li>
<li><p>求幂级数收敛半径</p>
<p>若 $\lim_{n \to \infty}|\dfrac{c_{n + 1}}{c_n}| = \lambda$ 或 $\lim_{n \to \infty} \sqrt[n]{|c_n|} = \lambda$，则可以得出 $R = \dfrac{1}{\lambda}$。</p>
<blockquote>
<p>注意这里 $c_n$ 是 $z^n$ 前面的系数。</p>
</blockquote>
</li>
<li><p>例题</p>
<p><img src="4.1-2.png" alt="4.1-2"></p>
</li>
</ul>
<h3 id="S-4-2-泰勒级数"><a href="#S-4-2-泰勒级数" class="headerlink" title="$\S 4.2$ 泰勒级数"></a>$\S 4.2$ 泰勒级数</h3><ul>
<li><p>泰勒展开定理</p>
<p><img src="4.2-1.png" alt="4.2-1"></p>
<blockquote>
<p>有关泰勒展开的一些性质</p>
<p>若 $f(z)$ 有奇点，则最近的奇点一定在 $f(z)$ 的收敛圆周上，即收敛半径就是到最近奇点的距离。</p>
<p>函数在 $z_0$ 解析的充要条件是函数在 $z_0$ 点的领域内可展开成幂级数（解析函数的本质特征）。</p>
<p>解析函数的幂级数展开式是唯一的，就是泰勒级数。</p>
</blockquote>
</li>
<li><p>例题（有技巧地泰勒展开）</p>
<p><img src="4.2-2.png" alt="4.2-2"></p>
<p><img src="4.2-3.png" alt="4.2-3"></p>
</li>
</ul>
<h3 id="S-4-3-洛朗级数"><a href="#S-4-3-洛朗级数" class="headerlink" title="$\S 4.3$ 洛朗级数"></a>$\S 4.3$ 洛朗级数</h3><ul>
<li><p>洛朗级数</p>
<p>形如 $\sum_{n = 0}^{\infty}c_n(z - z_0)^n = \sum_{n = 1}^{\infty}c_{-n}(z - z_0)^{-n} + \sum_{n = 0}^{\infty}c_n(z - z_0)^n$ 的级数称为洛朗级数。</p>
<p>当 $c_{-n} = 0(n = 1, 2, \dots)$ 时，洛朗级数就是幂级数。</p>
</li>
<li><p>洛朗级数的收敛圆环</p>
<p>洛朗级数分为正幂项和负幂项，正幂项称为洛朗级数的解析部分，负幂项称为洛朗级数的主要部分。</p>
<p>若两部分在 $z_0$ 处都收敛，则称洛朗级数在 $z_0$ 处收敛。</p>
<p><img src="4.3-1.png" alt="4.3-1"></p>
<p><img src="4.3-2.png" alt="4.3-2"></p>
</li>
<li><p>洛朗定理</p>
<p><img src="4.3-3.png" alt="4.3-3"></p>
<blockquote>
<p>同一解析圆环内，$f(z)$ 的洛朗展开式是唯一的（即 $c_n$ 相同）。</p>
</blockquote>
<p>将函数展开为洛朗级数一般有直接法和间接法。</p>
<blockquote>
<p>直接法可以直接用洛朗定理（套公式），然后用高阶函数求导公式来求。</p>
<p>间接法，利用一些技巧间接转化。<strong>比如 $f(z) = (z - z_0)^kg(z)$，可以先将 $g(z)$ 洛朗展开，然后在乘起来，得出 $f(z)$ 的洛朗级数。还有 $\dfrac{1}{1 - z} = \sum_{n = 0}^{\infty}z^n(|z| &lt; 1)$ 也是一个常用转化公式。</strong></p>
</blockquote>
</li>
<li><p>例题</p>
<p><img src="4.3-4.png" alt="4.3-4"></p>
<blockquote>
<p>注意学习这里的技巧，如果 $\dfrac{1}{1 - z}$ 里 $z &lt; 1$，那么直接用公式 $\dfrac{1}{1 - z} = \sum_{n = 0}^{\infty}z^n(|z| &lt; 1)$，如果 $z &gt; 1$，就进行转化 $\dfrac{1}{1 - z} = \dfrac{1}{z}\cdot\dfrac{1}{\dfrac{1}{z} - 1}$，然后对后面套公式即可。</p>
</blockquote>
</li>
<li><p>积分计算公式</p>
<p><img src="4.3-5.png" alt="4.3-5"></p>
</li>
</ul>
<h3 id="习题课-3"><a href="#习题课-3" class="headerlink" title="习题课"></a>习题课</h3><ul>
<li><p>$\dfrac{1}{(z - a)(z - b)}$ 展开成 $z$ 的幂级数，并指出收敛域。</p>
<p><img src="4.4-1.png" alt="4.4-1"></p>
<p><img src="4.4-2.png" alt="4.4-2"></p>
</li>
<li><p>$\dfrac{1}{(1 + z^2)^2}$ 展开成 $z$ 的幂级数，并指出收敛域。</p>
<p><img src="4.4-3.png" alt="4.4-3"></p>
</li>
<li><p>$\sin^2z$ 展开成 $z$ 的幂级数，并指出收敛域。</p>
<p><img src="4.4-4.png" alt="4.4-4"></p>
</li>
<li><p>$\dfrac{z}{(z + 1)(z + 2)},z_0 = 2$ 求该函数在 $z_0$ 的泰勒展开。</p>
<p><img src="4.4-5.png" alt="4.4-5"></p>
</li>
<li><p>$\dfrac{1}{z^2},z_0 = -1$ 求该函数在 $z_0$ 的泰勒展开。</p>
<p><img src="4.4-6.png" alt="4.4-6"></p>
</li>
<li><p>$\dfrac{1}{4 - 3z},z_0 = 1 + i$ 求该函数在 $z_0$ 的泰勒展开。</p>
<p><img src="4.4-7.png" alt="4.4-7"></p>
</li>
<li><p>$\dfrac{1}{(z - 1)(z - 2)},0 &lt; |z - 1| &lt; 1;1 &lt; |z - 2| &lt; +\infty$ 求该函数在指定圆环内的泰勒展开。</p>
<p><img src="4.4-8.png" alt="4.4-8"></p>
</li>
<li><p>$\dfrac{1}{z^2(z - i)}$，以 $z_0$为中心的圆环域。 求该函数在指定圆环内的泰勒展开。</p>
<p><img src="4.4-9.png" alt="4.4-9"></p>
<p><img src="4.4-10.png" alt="4.4-10"></p>
</li>
<li><p>利用积分公式来算下题</p>
<p><img src="4.4-11.png" alt="4.4-11"></p>
</li>
<li><p>根据洛朗展开倒推收敛圆环与和函数</p>
<p><img src="4.4-12.png" alt="4.4-12"></p>
<p><img src="4.4-13.png" alt="4.4-13"></p>
</li>
</ul>
<h2 id="第五章-留数"><a href="#第五章-留数" class="headerlink" title="第五章 留数"></a>第五章 留数</h2><h3 id="第五章总结"><a href="#第五章总结" class="headerlink" title="第五章总结"></a>第五章总结</h3><p><img src="5.4-1.png" alt="5.4-1"></p>
<p><img src="5.4-2.png" alt="5.4-2"></p>
<p><img src="5.4-3.png" alt="5.4-3"></p>
<p><img src="5.4-4.png" alt="5.4-4"></p>
<p><img src="5.4-5.png" alt="5.4-5"></p>
<p><img src="5.4-6.png" alt="5.4-6"></p>
<blockquote>
<p>一级极点用法则一，多极用法则二，复杂分式（且分母好求导）考虑法则三，无穷用法则四。判断无穷的性质就是转化为判断零处的性质。</p>
</blockquote>
<h3 id="S-5-1-孤立奇点"><a href="#S-5-1-孤立奇点" class="headerlink" title="$\S 5.1$ 孤立奇点"></a>$\S 5.1$ 孤立奇点</h3><ul>
<li><p>孤立奇点</p>
<p>若 $z_0$ 为奇点，且 $z_0$ 邻域内没有奇点，则 $z_0$ 是孤立奇点。</p>
<p>若 $z_0$ 是孤立奇点，则必存在去心邻域 $0 &lt; |z - z_0| &lt; \delta$，$\delta$ 取决于 $z_0$ 到其他奇点的最小距离。</p>
</li>
<li><p>孤立奇点的分类</p>
<p>在孤立奇点的解析邻域内，$f(z)$ 可以进行洛朗展开。根据洛朗展开式中负幂项的多少，把孤立奇点分为三类。</p>
<ul>
<li><strong>可去奇点：</strong>展开式中不含负幂项。</li>
<li><strong>极点：</strong>展开式中有有限个负幂项。</li>
<li><strong>本性奇点：</strong>展开式中有无限个负幂项。</li>
</ul>
</li>
<li><p>可去奇点的判定</p>
<p>若 $f(z)$ 在 $z_0$ 的去心邻域内解析，则 $z_0$ 是 $f(z)$ 可去奇点的充要条件是 $\lim_{z \to z_0} f(z) = c_0$。</p>
</li>
<li><p>极点</p>
<p>若 $f(z)$ 在 $z_0$ 的去心邻域内，洛朗展开式中幂次最小的是 $-m$ 次幂，则称 $z_0$ 为 $f(z)$ 的 $m$ 级极点。</p>
<p><img src="5.1-1.png" alt="5.1-1"></p>
<p><img src="5.1-2.png" alt="5.1-2"></p>
</li>
<li><p>例题</p>
<p><img src="5.1-3.png" alt="5.1-3"></p>
</li>
<li><p>孤立奇点类型的判断方法</p>
<p><img src="5.1-4.png" alt="5.1-4"></p>
</li>
<li><p>函数的零点与极点的关系</p>
<p>若不恒等于 $0$ 的解析函数 $f(z)$ 在 $z_0$ 的邻域内可表示为 $f(z) = (z - z_0)^mg(z)$，其中 $g(z)$ 在 $z_0$ 解析且 $g(z_0) \ne 0$，则称 $z_0$ 为 $f(z)$ 的 $m$ 级零点。</p>
<p><strong>零点级数的判定：</strong>若 $f(z)$ 在 $z_0$ 解析，则 $z_0$ 为 $f(z)$ 的 $m$ 级零点的充要条件是 $f^{(k)}(z_0) = 0(k = 0, 1, \dots, m - 1)$ 且 $f^{(m)}(z_0) \ne 0$。</p>
<p><strong>零点与极点的关系：</strong>若 $z_0$ 是 $f(z)$ 的 $m$ 级极点，则 $z_0$ 是 $\dfrac{1}{f(z)}$ 的 $m$ 级零点。同样的，若 $z_0$ 是 $f(z)$ 的 $m$ 极零点，则 $z_0$ 是 $\dfrac{1}{f(z)}$ 的 $m$ 级极点。</p>
<blockquote>
<p>其实就是看分母的式子在 $z_0$ 上是几重跟就是几重零点。</p>
</blockquote>
</li>
<li><p>分式的零点与极点</p>
<p><img src="5.1-5.png" alt="5.1-5"></p>
<blockquote>
<p><strong>虽然函数的极点级数难以确定，但是零点级数好确定，尤其是分式，可以拆成分子分母来讨论。所以我们可以利用零点级数来求极点级数。</strong></p>
</blockquote>
</li>
<li><p>函数在无穷远点的性态</p>
<p><img src="5.1-6.png" alt="5.1-6"></p>
<p>若判断函数在 $\infty$ 点处的性态，可以令 $\xi = \dfrac{1}{z}$，故 $f(z)$ 在 $\infty$ 的性态则变为 $\phi(\xi)$ 在 $0$ 处的性态。经过一系列推到之后，得到如下定理：</p>
<p><img src="5.1-7.png" alt="5.1-7"></p>
</li>
<li><p>例题</p>
<p><img src="5.1-8.png" alt="5.1-8"></p>
<blockquote>
<p>如果函数可以进行洛朗展开，则直接用洛朗展开然后判断正幂项次数。但对于无法洛朗展开的函数，可以用定义法来解决。</p>
</blockquote>
</li>
</ul>
<h3 id="S-5-2-留数"><a href="#S-5-2-留数" class="headerlink" title="$\S 5.2$ 留数"></a>$\S 5.2$ 留数</h3><p>由前面的 $\oint_C f(z)dz = 2\pi i c_{-1}$，可知 $c_{-1}$ 很重要，我们称之为留数。</p>
<p><img src="5.2-1.png" alt="5.2-1"></p>
<ul>
<li><p>留数定理</p>
<p>函数沿闭曲线的正向积分等于所有奇点的留数和乘以 $2\pi i$</p>
<p>若 $z_0$ 是 $f(z)$ 的可去奇点，则留数 $c_{-1} = 0$。</p>
<p>若 $z_0$ 是 $f(z)$ 的本性奇点，则只能用洛朗展开求 $c_{-1}$。</p>
<p>若 $z_0$ 是 $f(z)$ 的极点，则可以用以下四个法则来相对简便求留数。</p>
<blockquote>
<p>法则一：若 $z_0$ 是 $f(z)$ 的一级极点，则 $\Res[f(z), z_0] = \lim_{z \to z_0}(z - z_0)f(z)$。</p>
<p>法则二：若 $z_0$ 是 $f(z)$ 的 $m$ 级极点，则 $\Res[f(z), z_0] = \dfrac{1}{(m - 1)!}\lim_{z \to z_0}\dfrac{d^{m - 1}}{dz^{m - 1}}[(z - z_0)^mf(z)]$。</p>
<p>法则三：设 $f(z) = \dfrac{P(z)}{Q(z)}$，$P(z)$ 和 $Q(z)$ 在 $z_0$ 解析，若 $P(z_0) \ne 0,Q(z_0) = 0, Q’(z_0) \ne 0$，则 $z_0$ 为 $f(z)$ 的一级极点且 $\Res[f(z), z_0] = \dfrac{P(z_0)}{Q’(z_0)}$。</p>
<p>法则四：无穷远点 $\infty$ 的留数 $\Res[f(z), \infty] = -c_{-1} = -\Res[f(\dfrac{1}{z})\cdot \dfrac{1}{z^2}, 0]$。（我们利用这条法则，当内部积分不好算时，可以转化为外部的积分和来算）</p>
<p><strong>注：$\infty$ 一定是奇点，但不能判断奇点类型。</strong></p>
</blockquote>
</li>
<li><p>无穷远点的留数</p>
<p><img src="5.2-3.png" alt="5.2-3"></p>
<blockquote>
<p><strong>注：$\infty$ 一定是奇点，但不能判断奇点类型。</strong></p>
<p>推论：若 $f(z)$ 在$R &lt; |Z| &lt; +\infty$ 内的洛朗展开为 $f(z) = \sum_{-\infty}^{+\infty} c_nz^n$，则 $\Res[f(z), +\infty] = -c_{-1}$。</p>
</blockquote>
<p><strong>定理：若 $f(z)$ 在扩充复平面上，包括 $\infty$ 在内只有有限个孤立奇点，则 $f(z)$ 所有奇点的留数总和为零。</strong></p>
<blockquote>
<p><strong>判断无穷的性质就是转化为判断零处的性质</strong>。</p>
</blockquote>
</li>
<li><p>例题</p>
<p><img src="5.2-2.png" alt="5.2-2"></p>
<blockquote>
<p>注意这里解法二，$m$ 确实取任一大于等于 $3$ 的数即可（洛朗展开之后可以看出）。</p>
</blockquote>
<p><img src="5.2-4.png" alt="5.2-4"></p>
<p><img src="5.2-5.png" alt="5.2-5"></p>
<p><img src="5.2-6.png" alt="5.2-6"></p>
</li>
</ul>
<h3 id="习题课-4"><a href="#习题课-4" class="headerlink" title="习题课"></a>习题课</h3><ul>
<li><p>求下列函数奇点，若是极点则确定级数</p>
<p><img src="5.4-7.png" alt="5.4-7"></p>
<p><img src="5.4-8.png" alt="5.4-8"></p>
<blockquote>
<p>确定奇点的取值之后，若是在分母上，可以通过不断求导判断是几级零点，然后就可以判断出是几级极点。</p>
</blockquote>
</li>
<li><p>利用留数计算积分</p>
<p><img src="5.4-9.png" alt="5.4-9"></p>
<p><img src="5.4-10.png" alt="5.4-10"></p>
</li>
<li><p>判断 $\infty$ 的奇点类型并求出 $\infty$ 的留数</p>
<p><img src="5.4-11.png" alt="5.4-11"></p>
</li>
<li><p>利用外面算里面</p>
<p><img src="5.4-12.png" alt="5.4-12"></p>
<p><img src="5.4-13.png" alt="5.4-13"></p>
</li>
</ul>
<h2 id="第七章-傅里叶变换"><a href="#第七章-傅里叶变换" class="headerlink" title="第七章 傅里叶变换"></a>第七章 傅里叶变换</h2><h3 id="S-7-1-傅里叶级数"><a href="#S-7-1-傅里叶级数" class="headerlink" title="$\S 7.1$ 傅里叶级数"></a>$\S 7.1$ 傅里叶级数</h3><ul>
<li><p>傅里叶级数</p>
<p><img src="7.1-1.png" alt="7.1-1"></p>
<p><img src="7.1-2.png" alt="7.1-2"></p>
</li>
<li><p>复指数形式的傅里叶级数</p>
<p>将欧拉公式代入到上式子，可以得到：</p>
<p><img src="7.1-3.png" alt="7.1-3"></p>
</li>
</ul>
<h3 id="S-7-2-傅里叶积分与傅里叶变换"><a href="#S-7-2-傅里叶积分与傅里叶变换" class="headerlink" title="$\S 7.2$ 傅里叶积分与傅里叶变换"></a>$\S 7.2$ 傅里叶积分与傅里叶变换</h3><ul>
<li><p>傅里叶积分定理</p>
<p><img src="7.2-1.png" alt="7.2-1"></p>
</li>
<li><p>傅里叶变换</p>
<p>将上式积分式子进行变换，得到如下：</p>
<p><img src="7.2-2.png" alt="7.2-2"></p>
<p><img src="7.2-3.png" alt="7.2-3"></p>
</li>
<li><p>例题</p>
<p><img src="7.2-4.png" alt="7.2-4"></p>
<p><img src="7.2-5.png" alt="7.2-5"></p>
</li>
</ul>
<h3 id="S-7-3-单位脉冲函数"><a href="#S-7-3-单位脉冲函数" class="headerlink" title="$\S 7.3$ 单位脉冲函数"></a>$\S 7.3$ 单位脉冲函数</h3><ul>
<li><p>单位脉冲函数</p>
<p><img src="7.3-1.png" alt="7.3-1"></p>
</li>
<li><p>$\delta$ 的性质</p>
<p><img src="7.3-2.png" alt="7.3-2"></p>
<p><img src="7.3-3.png" alt="7.3-3"></p>
</li>
<li><p>$\delta$ 函数的傅氏变换</p>
<p><img src="7.3-4.png" alt="7.3-4"></p>
<blockquote>
<p>这两个傅氏变换对很重要，很多题目重要需要靠这两个不断变换。</p>
</blockquote>
</li>
<li><p>例题</p>
<p><img src="7.3-5.png" alt="7.3-5"></p>
<p><img src="7.3-6.png" alt="7.3-6"></p>
<p><img src="7.3-7.png" alt="7.3-7"></p>
</li>
</ul>
<h3 id="S-7-4-傅里叶变换的性质"><a href="#S-7-4-傅里叶变换的性质" class="headerlink" title="$\S 7.4$ 傅里叶变换的性质"></a>$\S 7.4$ 傅里叶变换的性质</h3><ul>
<li><p>线性性质</p>
<script type="math/tex; mode=display">
F_1(\omega) = \mathscr{F}[f_1(t)],F_2(\omega) = \mathscr{F}[f_2(t)] \\
\Rightarrow \mathscr{F}[\alpha f_a(t) + \beta f_2(t)] = \alpha F_1(\omega) + \beta F_2(\omega)</script><p>逆变换同理成立。</p>
</li>
<li><p>平移性质</p>
<script type="math/tex; mode=display">
F(\omega) = \mathscr{F}[f(t)] \\
\Rightarrow \mathscr{F}[f(t - t_0)] = e^{-i\omega t_0}F(\omega) ,\\
\mathscr{F}^{-1}[F(\omega - \omega_0)] = e^{i\omega t_0}f(t)</script></li>
<li><p>伸缩性质</p>
<script type="math/tex; mode=display">
F(\omega) = \mathscr{F}[f(t)] \\
\Rightarrow \mathscr{F}[f(at)] = \dfrac{1}{|a|}F(\dfrac{\omega}{a})</script></li>
<li><p>微分性质</p>
<script type="math/tex; mode=display">
若 \lim_{|t| \to +\infty}f(t) = 0, 则 \mathscr{F}[f'(t)] = i\omega \mathscr{F}[f(t)] \\
若 \lim_{|t| \to +\infty}f^{(k)}(t) = 0, 则 \mathscr{F}[f^{(n)}(t)] = (i\omega)^n \mathscr{F}[f(t)]</script></li>
<li><p>积分性质</p>
<script type="math/tex; mode=display">
若\ \  g(t) = \int_{-\infty}^t f(\tau)d\tau,\lim_{t \to +\infty} g(t) = 0,则 \\
\mathscr{F}[g(t)] = \dfrac{1}{i\omega}\mathscr{F}[f(t)]</script><blockquote>
<p>其实就是求导倒过来的式子。</p>
</blockquote>
</li>
<li><p>卷积与卷积定理</p>
<p>$f_1(t)$ 与 $f_2(t)$ 的卷积记为 $f_1(t) \ast f_2(t) = \int_{-\infty}^{+\infty}f_1(\tau)f_2(t - \tau)d\tau$。</p>
<p>且卷积满足交换律，结合律和分配律。</p>
<p><strong>卷积定理</strong></p>
<script type="math/tex; mode=display">
F_1(\omega) = \mathscr{F}[f_1(t)],F_2(\omega) = \mathscr{F}[f_2(t)] \\
\Rightarrow \mathscr{F}[f_1(t) * f_2(t)] = F_1(\omega) \cdot F_2(\omega) \\
推论 \Rightarrow \mathscr{F}[f_1(t) \cdot f_2(t)] = \dfrac{1}{2\pi} F_1(\omega) * F_2(\omega)</script></li>
</ul>
<h3 id="习题课-5"><a href="#习题课-5" class="headerlink" title="习题课"></a>习题课</h3><h2 id="第八章-拉普拉斯变换"><a href="#第八章-拉普拉斯变换" class="headerlink" title="第八章 拉普拉斯变换"></a>第八章 拉普拉斯变换</h2><h3 id="S-8-1-拉普拉斯变换的概念"><a href="#S-8-1-拉普拉斯变换的概念" class="headerlink" title="$\S 8.1$ 拉普拉斯变换的概念"></a>$\S 8.1$ 拉普拉斯变换的概念</h3><ul>
<li><p>拉普拉斯变换</p>
<p><img src="8.1-1.png" alt="8.1-1"></p>
<p><img src="8.1-2.png" alt="8.1-2"></p>
</li>
<li><p>拉普拉斯变换存在的条件</p>
<p><img src="8.1-3.png" alt="8.1-3"></p>
</li>
<li><p>重要公式 &amp; 例题</p>
<p><img src="8.1-5.png" alt="8.1-5"></p>
<p><img src="8.1-6.png" alt="8.1-6"></p>
<p><img src="8.1-4.png" alt="8.1-4"></p>
<p><img src="8.1-7.png" alt="8.1-7"></p>
<p><img src="8.1-8.png" alt="8.1-8"></p>
</li>
</ul>
<h3 id="S-8-2-拉普拉斯变换的性质"><a href="#S-8-2-拉普拉斯变换的性质" class="headerlink" title="$\S 8.2$ 拉普拉斯变换的性质"></a>$\S 8.2$ 拉普拉斯变换的性质</h3><ul>
<li><p>线性性质</p>
<script type="math/tex; mode=display">
F_1(\omega) = \mathscr{L}[f_1(t)],F_2(\omega) = \mathscr{L}[f_2(t)] \\
\Rightarrow \mathscr{L}[\alpha f_a(t) + \beta f_2(t)] = \alpha F_1(\omega) + \beta F_2(\omega)</script><p>逆变换同理</p>
</li>
<li><p>微分性质</p>
<script type="math/tex; mode=display">
若\ \ F(s) = \mathscr{L}[f(t)] \Rightarrow 则\ \mathscr{L}[f'(t)] = sF(s) - f(0)\\
一般地，有\ \ \mathscr{L}[f^{(n)}(t)] = s^nF(s) - s^{n - 1}f(0) - s^{n - 2}f'(0) - \dots - sf^{(n - 2)}(0) - f^{(n - 1)}(0)</script></li>
<li><p>积分性质</p>
<script type="math/tex; mode=display">
设 F(s) = \mathscr{L}[f(t)] \Rightarrow 则\ \mathscr{L}[\int_0^t f(t)dt] = \dfrac{1}{s} F(s)</script></li>
<li><p>位移性质</p>
</li>
</ul>
<ul>
<li>延迟性质</li>
</ul>
<ul>
<li>计算反常积分</li>
</ul>
<ul>
<li>卷积及卷积定理</li>
</ul>
<h3 id="S-8-3-拉普拉斯逆变换"><a href="#S-8-3-拉普拉斯逆变换" class="headerlink" title="$\S 8.3$ 拉普拉斯逆变换"></a>$\S 8.3$ 拉普拉斯逆变换</h3><h3 id="S-8-4-用拉氏变换解常微分方程"><a href="#S-8-4-用拉氏变换解常微分方程" class="headerlink" title="$\S 8.4$ 用拉氏变换解常微分方程"></a>$\S 8.4$ 用拉氏变换解常微分方程</h3><h3 id="习题课-6"><a href="#习题课-6" class="headerlink" title="习题课"></a>习题课</h3>]]></content>
      <tags>
        <tag>数学</tag>
        <tag>大学笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>算法笔记 | 博弈论</title>
    <url>/2023/07/20/Game-In-ACM/</url>
    <content><![CDATA[<p>SG 函数</p>
<span id="more"></span>
<h2 id="博弈论简介"><a href="#博弈论简介" class="headerlink" title="博弈论简介"></a>博弈论简介</h2><p>注：下面这段文字摘抄自 <a href="https://oi-wiki.org/math/game-theory/intro/">OI-Wiki</a></p>
<h3 id="公平组合游戏"><a href="#公平组合游戏" class="headerlink" title="公平组合游戏"></a>公平组合游戏</h3><p>公平组合游戏（Impartial Game）的定义如下：</p>
<ul>
<li>游戏有两个人参与，二者轮流做出决策，双方均知道游戏的完整信息；</li>
<li>任意一个游戏者在某一确定状态可以作出的决策集合只与当前的状态有关，而与游戏者无关；</li>
<li>游戏中的同一个状态不可能多次抵达，游戏以玩家无法行动为结束，且游戏一定会在有限步后以非平局结束。</li>
</ul>
<h3 id="非公平组合游戏"><a href="#非公平组合游戏" class="headerlink" title="非公平组合游戏"></a>非公平组合游戏</h3><p>非公平组合游戏（Partizan Game）与公平组合游戏的区别在于在非公平组合游戏中，游戏者在某一确定状态可以做出的决策集合与游戏者有关。大部分的棋类游戏都 <strong>不是</strong> 公平组合游戏，如国际象棋、中国象棋、围棋、五子棋等（因为双方都不能使用对方的棋子）。</p>
<h3 id="反常游戏"><a href="#反常游戏" class="headerlink" title="反常游戏"></a>反常游戏</h3><p>反常游戏（Misère Game）按照传统的游戏规则进行游戏，但是其胜者为第一个无法行动的玩家。以 Nim 游戏为例，Nim 游戏中取走最后一颗石子的为胜者，而反常 Nim 游戏中取走最后一刻石子的为败者。</p>
<hr>
<p>本文主要研究公平组合游戏。</p>
<h2 id="SG-函数"><a href="#SG-函数" class="headerlink" title="SG 函数"></a>SG 函数</h2><p>我们通过 Nim 游戏来介绍 SG 函数，什么是 Nim 游戏呢？</p>
<p>Nim 游戏是一种两个人玩的回合制数学战略游戏。游戏者轮流从几排棋子（或者任何道具）中选择一排，再由这一排中取走一个或者多个，依规则不同，拿走最后一个的可能是输家，也有可能是赢家。（转自 <a href="https://zh.wikipedia.org/zh-sg/%E5%B0%BC%E5%A7%86%E6%B8%B8%E6%88%8F">尼姆游戏</a>）</p>
<p>我们接下来定义一种函数 $SG(x)$，并且令 $SG(x):=mex\{SG(y)|x \to y\}$，这里 $x$，$y$ 均表示某种状态，$x \to y$ 表示 $x$ 可以通过一次操作到达 $y$，也可以理解为 $y$ 是 $x$ 的后继状态。$mex$ 表示一个集合中未出现的最小自然数（例如 $mex\{0, 1, 3\} = 2$ ）。如果 $SG(x) = n$，说明可以从当前状态转移到 $0\sim n - 1$ 的状态。</p>
<p>对于一个状态，如果它是必胜态，那么它移动一步，下一步一定<strong>可以</strong>变成必败态。如果一个状态是必败态，那么它无论怎么移动，它的下一步<strong>只能</strong>是必胜态。我们令 $SG(x) = 0$ 表示必败，$SG(x) \ne 0$ 表示必胜。那么 $SG(x) = 0$ 时说明下一步的状态 $y$ 全都是 $SG(y) \ne 0$，$SG(x) \ne 0$ 说明下一步存在状态 $y’$ 满足 $SG(y’) \ne 0$。符合我们的胜败状态。</p>
<p>对于单堆的 Nim 游戏，不难证明 $SG(x) = x$，但是对于双堆，三堆，n 堆情况就很复杂。所以我们引入 <strong>SG定理</strong>。</p>
<p><strong>Sprague-Grundy定理</strong>（两个游戏的情形）：</p>
<blockquote>
<p>对于公平组合游戏的两个状态 $x$ 和 $y$，有 $SG(x + y) = SG(x) \oplus SG(y)$</p>
</blockquote>
<p>推广的情形：</p>
<blockquote>
<p>对于公平组合游戏的 $n$ 个状态 $x_1,x_2, \dots,x_n$，有 $SG(x_1 + x_2 + \cdots + x_n) = SG(x_1) \oplus SG(x_2) \oplus \cdots \oplus SG(x_n)$</p>
</blockquote>
<p>定理具体证明见<a href="https://www.zhihu.com/question/51290443">这里</a>。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://oi-wiki.org/math/game-theory/impartial-game/">公平组合游戏 - OI-Wiki</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/257013159">算法学习笔记(51): SG函数 - Pecco - 知乎</a></p>
]]></content>
      <tags>
        <tag>算法竞赛</tag>
        <tag>博弈论</tag>
      </tags>
  </entry>
  <entry>
    <title>算法竞赛 | 计算几何</title>
    <url>/2023/09/22/Geometry-In-ACM/</url>
    <content><![CDATA[<p>计算几何学习笔记</p>
<span id="more"></span>
<h2 id="0-前置知识"><a href="#0-前置知识" class="headerlink" title="0. 前置知识"></a>0. 前置知识</h2><h4 id="凸多边形"><a href="#凸多边形" class="headerlink" title="凸多边形"></a>凸多边形</h4><p>凸多边形是指所有内角大小都在 $[0, \pi]$ 范围内的 <strong>简单多边形</strong>。</p>
<h4 id="凸包"><a href="#凸包" class="headerlink" title="凸包"></a>凸包</h4><p>在平面上能包含所有给定点的最小凸多边形叫做凸包。</p>
<h2 id="1-二维凸包"><a href="#1-二维凸包" class="headerlink" title="1. 二维凸包"></a>1. 二维凸包</h2><p>在二维平面上给定若干点，求一个最小的凸包使得能包含全部给定点。</p>
<h3 id="Andrew-算法求凸包"><a href="#Andrew-算法求凸包" class="headerlink" title="Andrew 算法求凸包"></a>Andrew 算法求凸包</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>首先将每个点按横坐标从小到大排序（横坐标相同就按纵坐标），然后先按升序枚举出下凸壳，然后再按降序求出上凸壳。</p>
<p>升序枚举的时候，我们用栈存储下凸壳中的元素，设 $S_1$，$S_2$ 是栈顶的两个元素，其中 $S_1$ 是栈顶。遇到一个新的点 $P(x, y)$，当 $\vec {S_2S_1} \times \vec {S_1P} \le 0$ 时，说明 $S_1$ 不应该是下凸壳中的点，弹出 $S_1$，继续判断。直到弹不出时，将 $P$ 插入栈中。</p>
<p>降序枚举时同理，判断依据也是 $\vec {S_2S_1} \times \vec {S_1P} \le 0$，所以就是相当于倒着跑一遍，即可求出上凸壳。</p>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> {</span><br><span class="line">  <span class="type">double</span> x, y;</span><br><span class="line">  Node <span class="keyword">operator</span> - (Node a) { <span class="keyword">return</span> {x - a.x, y - a.y}; }</span><br><span class="line">  <span class="type">double</span> <span class="keyword">operator</span> * (Node a) { <span class="keyword">return</span> x * a.y - y * a.x; }</span><br><span class="line">};</span><br><span class="line">Node s[N];</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">len</span><span class="params">(<span class="type">double</span> x, <span class="type">double</span> y)</span> </span>{</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">sqrt</span>(x * x + y * y);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(Node a, Node b)</span> </span>{</span><br><span class="line">  <span class="keyword">return</span> (<span class="built_in">fabs</span>(a.x - b.x) &lt; eps ? a.y &lt; b.y : a.x &lt; b.x);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">  std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line">  cin &gt;&gt; n;</span><br><span class="line">  <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">q</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) {</span><br><span class="line">    cin &gt;&gt; s[i].x &gt;&gt; s[i].y;</span><br><span class="line">  } </span><br><span class="line">  <span class="built_in">sort</span>(s + <span class="number">1</span>, s + <span class="number">1</span> + n, cmp);</span><br><span class="line">  <span class="type">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) {</span><br><span class="line">    <span class="keyword">while</span>(tmp &gt;= <span class="number">2</span> &amp;&amp; (s[q[tmp]] - s[q[tmp - <span class="number">1</span>]]) * (s[i] - s[q[tmp]]) &lt;= <span class="number">0</span>) tmp--;</span><br><span class="line">    q[++tmp] = i;</span><br><span class="line">  }</span><br><span class="line">  <span class="type">int</span> kdl = tmp;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--) {</span><br><span class="line">    <span class="keyword">while</span>(kdl &gt; tmp &amp;&amp; (s[q[kdl]] - s[q[kdl - <span class="number">1</span>]]) * (s[i] - s[q[kdl]]) &lt;= <span class="number">0</span>) kdl--;</span><br><span class="line">    q[++kdl] = i;</span><br><span class="line">  }</span><br><span class="line">  <span class="type">double</span> ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= kdl; i++) {</span><br><span class="line">    ans += <span class="built_in">len</span>(s[q[i]].x - s[q[i - <span class="number">1</span>]].x, s[q[i]].y - s[q[i - <span class="number">1</span>]].y);</span><br><span class="line">  }</span><br><span class="line">  cout &lt;&lt; fixed &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">2</span>) &lt;&lt; ans &lt;&lt; endl; <span class="comment">// 保留两位小数</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>参考文献：</p>
<p><a href="https://oi-wiki.org/geometry/">OI Wiki - 计算几何部分简介</a></p>
]]></content>
      <tags>
        <tag>算法竞赛</tag>
      </tags>
  </entry>
  <entry>
    <title>ICPC-2022</title>
    <url>/2023/10/18/ICPC-2022/</url>
    <content><![CDATA[<p>ICPC 2022 补题合集</p>
<span id="more"></span>
<h2 id="The-2023-ICPC-Asia-Hong-Kong-Regional-Programming-Contest-The-1st-Universal-Cup-Stage-2-Hong-Kong"><a href="#The-2023-ICPC-Asia-Hong-Kong-Regional-Programming-Contest-The-1st-Universal-Cup-Stage-2-Hong-Kong" class="headerlink" title="The 2023 ICPC Asia Hong Kong Regional Programming Contest (The 1st Universal Cup, Stage 2:Hong Kong)"></a><a href="https://codeforces.com/gym/104172">The 2023 ICPC Asia Hong Kong Regional Programming Contest (The 1st Universal Cup, Stage 2:Hong Kong)</a></h2><h3 id="B-Big-Picture"><a href="#B-Big-Picture" class="headerlink" title="B. Big Picture"></a><a href="https://qoj.ac/contest/1099/problem/5456">B. Big Picture</a></h3><h4 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h4><p>给你一个 $(n+1) \times (m+1)$ 的方格矩阵，每个格子一开始是白色。</p>
<p>你会对每一行和每一列进行染色。将第 $i$ 行的前 $j$ 个格子染为黑色的概率为 $p_{i, j}$，将第 $j$ 列的前 $i$ 个格子染为黑色的概率为 $q_{i, j}$。保证每一行的 $p_{i, j}$、每一列的 $q_{i, j}$ 的和为 1。行与列是独立的，这意味着同一个格子可能会同时被行和列各染一次。</p>
<p>求同色连通块的期望个数，模 $998244353$。</p>
<h4 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a><strong>Solution</strong></h4><p>对于每一个染列的操作，我们发现每列第一个（即第一行）一定都会被染色。故所有由染列得到的黑格子都会经由第一行连在一起。</p>
<p>对于每一个染行的操作，我们发现每行第一个（即第一列）一定都会被染色。故所有由染行得到的黑格子都会经由第一列连在一起。</p>
<p>又因为第一行第一列的格子一定会被染色，所以所有黑格子一定都是一个大连通块。并且最后一行，最后一列一定都是白色格子，所以我们要算的就是被黑色格子断开所形成的白色区域个数。</p>
<p>要确定每一个区域的个数，我们只要找一个区域中有标志的格子（含有某个独一无二的特性，只有其中某个格子有，其他格子都没有）。我们自然想到找角落的格子。思考发现由于每次染前缀的特性，左上角，右上角，左下角符合条件的格子均可能不唯一，只有右下角的格子唯一。所以找区域个数变为找区域右下角格子的个数，即计算有多少个格子可能称为右下角格子。这个概率是该格子没被染色并且下面，右边均被染色。</p>
<p><a href="https://codeforces.com/gym/104172/submission/228641466">Code</a></p>
<h3 id="E-Goose-Goose-DUCK"><a href="#E-Goose-Goose-DUCK" class="headerlink" title="E. Goose, Goose, DUCK?"></a><a href="https://codeforces.com/gym/104172/problem/E">E. Goose, Goose, DUCK?</a></h3><h4 id="Description-1"><a href="#Description-1" class="headerlink" title="Description"></a>Description</h4><p>给定一个序列 $\{a_i\}$，对于一个子序列，若其<strong>不合法</strong>，当且仅当子序列中存在某个元素出现了<strong>恰好</strong> $k$ 次。求这个序列中有多少个<strong>合法子序列</strong>。</p>
<p>$n \le 10^6$</p>
<h4 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a><strong>Solution</strong></h4><p>我们可以固定左端点，求有多少合法右端点。也可以固定右端点，求有多少合法左端点。</p>
<p>假设固定一个左端点，我们把右边所有不合法的区域全部标记 $+1$，初始时右边所有区域都是 $0$。题目就变为了求右边有多少个标记为 $0$ 的点。然后每次左端点都可以向右移动一位，移动的时候判断一下，如果这个元素右边区域剩的元素少于 $k$ 个，那么就不用标记 $-1$。反之把这个元素原先不合法的区域都变合法（即标记 $-1$ ），然后再把新的区域标记不合法（标记 $+1$ ）。</p>
<p>整个过程可以用线段树解决。时间复杂度 $\Theta (n\log n)$。</p>
<p><a href="https://codeforces.com/gym/104172/submission/228673534">Code</a></p>
]]></content>
  </entry>
  <entry>
    <title>算法竞赛 | 杭电多校训练</title>
    <url>/2023/07/19/HDU-In-Summer-0/</url>
    <content><![CDATA[<p>浅记录一下暑假 10 次 <del>坐牢</del> 比赛。</p>
<span id="more"></span>
<h2 id="Day-1"><a href="#Day-1" class="headerlink" title="Day 1"></a>Day 1</h2><h3 id="1001-Hide-And-Seek-Game"><a href="#1001-Hide-And-Seek-Game" class="headerlink" title="1001. Hide-And-Seek Game"></a>1001. <a href="https://acm.hdu.edu.cn/showproblem.php?pid=7275">Hide-And-Seek Game</a></h3><h4 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h4><p>两个人都在一棵树上，沿着树的边走，一次走一条边，一个人从 $S_a$ 出发，前往 $T_a$，到达 $T_a$ 后就返回向 $S_a$ 走，如此往复。另一个人在 $S_b$ 和  $T_b$ 之间走，问最早在那个点能相遇，若不相遇，则输出 <code>-1</code> 。$t$ 组数据，每组数据 $n$ 个结点，$m$ 次询问。</p>
<h4 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h4><p>本题 $n$ 和 $m$ 都较小（ $n, m \le 300$），所以可以枚举所有可能相遇的点。判断点 $i$ 是否在 $(S_a, T_a)$ 路线上的方法是判断 $dist(i, S_a) + dist(i, T_a) == dist(S_a, T_a)$。注意，对于每个点 $i$，相遇的时间节点可能是 $2k \times dist(S_a, T_a) + dist(S_a, i)$ 或 $2k \times dist(S_a, T_a) + 2 \times dist(S_a, T_a) - dist(i, S_a)$ 。另一个人的时间同理，所以这就相当于解二元一次方程。（不了解二元一次方程组的可以先做 <a href="https://www.luogu.com.cn/problem/P5656">P5656 【模板】二元一次不定方程 (exgcd)</a>）</p>
<p>注意一下，这里算两点间距离利用 LCA 来求，但不能直接用倍增去求（因为这样会超时），要用 dfs 序来求 LCA（时间复杂度要优化很多）。 </p>
<p><a href="https://acm.hdu.edu.cn/viewcode.php?rid=38826162">Code</a></p>
<h3 id="1002-City-Upgrading"><a href="#1002-City-Upgrading" class="headerlink" title="1002. City Upgrading"></a>1002. <a href="http://acm.hdu.edu.cn/showproblem.php?pid=7276">City Upgrading</a></h3><h4 id="Description-1"><a href="#Description-1" class="headerlink" title="Description"></a>Description</h4><p>一棵树，每个点都有权值，选中一个点的话，这个点相连的节点也会被选中，要求花费最小让整棵树全部点都被选中。</p>
<h4 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h4><p>树形DP，我们令 $f[i][0]$ 表示在 $i$ 位置选，$f[i][1]$ 表示在 $i$ 的儿子位置处选，让 $i$ 被儿子覆盖， $f[i][2]$ 表示在 $i$ 的父亲位置处选，让 $i$ 被父亲覆盖。</p>
<p>如果选 $i$ 位置，那么不难得出 $f[i][1] = a[i] + \sum \min\{f[son][0], f[son][1], f[son][2]\}$ ，因为这时候儿子 $son$ 怎么选都可以。</p>
<p>如果选 $i$ 父亲位置，那么 $f[i][2] = \sum \min\{f[son][1], f[son][2]\}$，这个时候儿子 $son$ 要么自己选，要么被 son 的儿子覆盖。</p>
<p>如果选 $i$ 儿子位置，这个时候有点复杂，因为要决定 $i$ 应该被哪个儿子覆盖，应该由花费最小的儿子覆盖，设这个儿子为 $chosen_son$ ，那么这个儿子一定是要选的，所以代价是 $f[chosen_son][0] + \sum_{son \ne chosen_son} \min\{f[son][0], f[son][1]\}$，而且一定有其他儿子 $son’$ 满足 $f[chosen_son][0] + \sum_{son \ne chosen_son} \min\{f[son][0], f[son][1]\} &lt; f[son’][0] + \sum_{son \ne son’} \min\{f[son][0], f[son][1]\}$，两边同类项抵消后，就是要选 $f[son][0] - \min\{f[son][0], f[son][1]\}$ 最小的儿子作为这个 $chosen_son$，在向下搜索时找到这个儿子，剩下就好解决了。</p>
<p><a href="http://acm.hdu.edu.cn/viewcode.php?rid=38674964">Code</a></p>
<h3 id="1003-Mr-Liang-play-Card-Game"><a href="#1003-Mr-Liang-play-Card-Game" class="headerlink" title="1003. Mr. Liang play Card Game"></a>1003. <a href="https://acm.hdu.edu.cn/showproblem.php?pid=7277">Mr. Liang play Card Game</a></h3><h4 id="Description-2"><a href="#Description-2" class="headerlink" title="Description"></a>Description</h4><p>桌上有 $n$ 张牌，第 $i$ 张牌的类型是 $a_i$，然后又告诉你每种牌的价值 $v_i$，每张牌初始等级为 $1$ 级，你每次可以进行两种操作，第一种操作是将某张牌打出去，若等级为 $k$，则获得 $p^{k - 1} \times v[a[i]]$ 的价值，第二种操作是将相邻的两张同类型同等级的牌合并，等级为合并前等级 $+1$。问全部出完牌之后的最大价值。 </p>
<h4 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h4><p>一道较为基础的区间 DP，想到 $f$ 数组的状态就比较好转移了。</p>
<p>$f[l][r][type][level]$ 表示将 $[l, r]$ 区间全部合并完，只剩下一张 $type$ 类型等级 $level$ 的牌所获得的最大价值。</p>
<p>$g[l][r]$ 表示将 $[l, r]$ 区间内牌全部打出去所获得的最大价值。</p>
<p>每次枚举 $l, r, type, level$，不难推出：</p>
<script type="math/tex; mode=display">
\begin{gather}
g[l][r] = \max \{g[l][r], g[l][mid] + g[mid + 1][r]\}; \\
f[l][r][t][1] =\max \{f[l][r][t][1], f[l][mid][t][1] + g[mid + 1][r], f[mid + 1][r][t][1] + g[l][mid]\}; \\
f[l][r][t][lev] = \max \{f[l][r][t][lev], f[l][mid][t][lev - 1] + f[mid + 1][r][t][lev - 1]\}\ (len > 1)
\end{gather}</script><p>更新完 $f$ 数组后再更新 $g$ 数组。</p>
<script type="math/tex; mode=display">
g[l][r] = \max \{g[l][r], f[l][r][t][lev] + v[t] \times c[lev] \};</script><p><a href="https://acm.hdu.edu.cn/viewcode.php?rid=38826810">Code</a></p>
<h3 id="1009-Assertion"><a href="#1009-Assertion" class="headerlink" title="1009. Assertion"></a>1009. <a href="http://acm.hdu.edu.cn/showproblem.php?pid=7283">Assertion</a></h3><h4 id="Description-3"><a href="#Description-3" class="headerlink" title="Description"></a>Description</h4><p>把 $m$ 个物品放进 $n$ 个柜子，问是否至少有一个里面物品数大于等于 $d$。</p>
<h4 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution"></a>Solution</h4><p>签到题，判断 $d$ 和 $\left \lfloor \dfrac{m - 1}{n} \right \rfloor + 1$ 即可。</p>
<p><a href="http://acm.hdu.edu.cn/viewcode.php?rid=38672478">Code</a></p>
<h2 id="Day-2"><a href="#Day-2" class="headerlink" title="Day 2"></a>Day 2</h2><h3 id="1001-Alice-Game"><a href="#1001-Alice-Game" class="headerlink" title="1001. Alice Game"></a>1001. <a href="http://acm.hdu.edu.cn/showproblem.php?pid=7287">Alice Game</a></h3><h3 id="1002-Binary-Number"><a href="#1002-Binary-Number" class="headerlink" title="1002. Binary Number"></a>1002. <a href="http://acm.hdu.edu.cn/showproblem.php?pid=7288">Binary Number</a></h3><h4 id="Description-4"><a href="#Description-4" class="headerlink" title="Description"></a>Description</h4><p>对二进制数做 $k$ 次操作，每次任取一段 $[l,r]$ 做 $01$ 翻折，问 $k$ 次之后获得的最大数。</p>
<h4 id="Solution-4"><a href="#Solution-4" class="headerlink" title="Solution"></a>Solution</h4><p>总体思路是从高位到低位，把最高位连续的 $0$ 变 $1$，次数多的也不用担心，次数如果多于连续 $0$ 的段数则全为 $1$。这里有两个特判，一个是只给定一位二进制，那么一定是 $1$，答案与 $k$ 的奇偶相关。还有一种情况是给定全是 $1$，$k = 1$，这时候是 $111\dots 10$ 。</p>
<p><a href="http://acm.hdu.edu.cn/viewcode.php?rid=38686833">Code</a></p>
<h3 id="1007-foreverlasting-and-fried-chicken"><a href="#1007-foreverlasting-and-fried-chicken" class="headerlink" title="1007. foreverlasting and fried-chicken"></a>1007. <a href="http://acm.hdu.edu.cn/showproblem.php?pid=7293">foreverlasting and fried-chicken</a></h3><h4 id="Description-5"><a href="#Description-5" class="headerlink" title="Description"></a>Description</h4><p>给定一张图，找出图中有多少个子图，构造如下。</p>
<p><img src="D2-1007.png" alt="D2-1007"></p>
<h4 id="Solution-5"><a href="#Solution-5" class="headerlink" title="Solution"></a>Solution</h4><p>关键是找到中间的两个蓝色和黄色的点。</p>
<p><img src="D2-1007(1" alt="D2-1007(1)">.png)</p>
<p>把点之间的连接关系用 <code>bitset</code> 存储好，枚举蓝点和黄点。中间共有的四个点用 <code>&amp;</code> 操作直接求出，剩下的点的个数也好求出，最后答案是 $\sum C_n^2 \times C_m^4$。</p>
<p><a href="http://acm.hdu.edu.cn/viewcode.php?rid=38687319">Code</a></p>
<h3 id="1009-String-Problem"><a href="#1009-String-Problem" class="headerlink" title="1009. String Problem"></a>1009. <a href="http://acm.hdu.edu.cn/showproblem.php?pid=7295">String Problem</a></h3><h4 id="Description-6"><a href="#Description-6" class="headerlink" title="Description"></a>Description</h4><p>将字符串拆成尽可能少的段，使得每段只包含一种字母。每段对答案的贡献为长度减一。</p>
<h4 id="Solution-6"><a href="#Solution-6" class="headerlink" title="Solution"></a>Solution</h4><p>签到题。</p>
<p><a href="http://acm.hdu.edu.cn/viewcode.php?rid=38685806">Code</a></p>
<h2 id="Day-6"><a href="#Day-6" class="headerlink" title="Day 6"></a>Day 6</h2><h3 id="1001"><a href="#1001" class="headerlink" title="1001."></a>1001.</h3><h4 id="Description-7"><a href="#Description-7" class="headerlink" title="Description"></a>Description</h4><h4 id="Solution-7"><a href="#Solution-7" class="headerlink" title="Solution"></a>Solution</h4><h3 id="1006"><a href="#1006" class="headerlink" title="1006."></a>1006.</h3><h3 id="Description-8"><a href="#Description-8" class="headerlink" title="Description"></a>Description</h3><h4 id="Solution-8"><a href="#Solution-8" class="headerlink" title="Solution"></a>Solution</h4><h2 id="Day-7"><a href="#Day-7" class="headerlink" title="Day 7"></a>Day 7</h2><h3 id="1002"><a href="#1002" class="headerlink" title="1002."></a>1002.</h3><h4 id="Description-9"><a href="#Description-9" class="headerlink" title="Description"></a>Description</h4><h4 id="Solution-9"><a href="#Solution-9" class="headerlink" title="Solution"></a>Solution</h4><h3 id="1011"><a href="#1011" class="headerlink" title="1011."></a>1011.</h3><h4 id="Description-10"><a href="#Description-10" class="headerlink" title="Description"></a>Description</h4><h4 id="Solution-10"><a href="#Solution-10" class="headerlink" title="Solution"></a>Solution</h4><h3 id="1013"><a href="#1013" class="headerlink" title="1013."></a>1013.</h3><h4 id="Description-11"><a href="#Description-11" class="headerlink" title="Description"></a>Description</h4><h4 id="Solution-11"><a href="#Solution-11" class="headerlink" title="Solution"></a>Solution</h4><h2 id="Day-9"><a href="#Day-9" class="headerlink" title="Day 9"></a>Day 9</h2><h3 id="1002-Inference"><a href="#1002-Inference" class="headerlink" title="1002. Inference"></a>1002. <a href="https://acm.hdu.edu.cn/showproblem.php?pid=7382">Inference</a></h3><h4 id="Description-12"><a href="#Description-12" class="headerlink" title="Description"></a>Description</h4><p>有 $m$ 个特征，这些特征之间存在 $k$ 个依赖关系，这些依赖关系组成了一张有向无环图。给定出 $n$ 组数据以及一个推断公式，然后根据这 $n$ 组数据推断一组新的数据里第 $m$ 个特征值最有可能是多少？（$0$ / $1$ / $2$）</p>
<h4 id="Solution-12"><a href="#Solution-12" class="headerlink" title="Solution"></a>Solution</h4><p>本题题意较为复杂，但实际比较简单。</p>
<p>稍微讲解下题意。</p>
<p>$\pi(x_i)$ 表示的是指向 $x_i$ 的点，即 $x_i$ 所依赖的特征。</p>
<p>在公式</p>
<script type="math/tex; mode=display">
P(x_m | x_1, \dots, x_{m - 1}) = \prod_{i = 1}^m P(x_i|\pi(x_i))</script><p>中，对于 $P(x_i | \pi(x_i)) = \dfrac{P(\pi(x_i), x_i)}{P(\pi(x_i))}$，这个公式其实就是条件概率公式。所求的是在 $n$ 组数据中满足 $\pi(x_i)$ 的行中同时满足 $x_i$ 的概率。</p>
<p>比如 $P(x_1 = 1)$ 就是求这 $n$ 组中 $x_1 = 1$ 的概率，$P(x_2 = 1 | x_1 = 0)$ 则是表示这 $n$ 组中满足 $x_1 = 0$ 的行里，$x_2 = 1$ 的概率。</p>
<p>题目最后求的是 $x_m$ 最有可能等于 $1 / 2 / 0$ 中的哪一个数，我们直接把公式套进去比较。题目满足一定会有一个概率比另外两个大，同时，我们观察发现，代入公式时，这三个式子前 $m - 1$ 项都是一样的（因为 $x_m$ 的取值不影响前面的 $P(x_i | \pi(x_i))$），所以只比较第 $m$ 项，所以题目变成了，求满足 $\pi(x_i)$ 的行里，$x_m$ 在 $0 / 1 / 2$ 中哪个数次数出现的最多。 然后题目又说了 $\pi(x) \le 5$，故线性扫一遍即可。时间复杂度 $O(n)$。</p>
<p><a href="https://acm.hdu.edu.cn/viewcode.php?rid=38801204">Code</a></p>
]]></content>
      <tags>
        <tag>算法竞赛</tag>
        <tag>训练合集</tag>
      </tags>
  </entry>
  <entry>
    <title>置顶 | 博客目录</title>
    <url>/2023/07/22/Index/</url>
    <content><![CDATA[<p>茵蒂克丝 <del>Index（雾</del> 小姐姐指引你前行</p>
<span id="more"></span>
<p><img src="INDEX_茵蒂克絲.jpg" alt="INDEX_茵蒂克絲"></p>
<h2 id="算法竞赛"><a href="#算法竞赛" class="headerlink" title="算法竞赛"></a>算法竞赛</h2><p><del>算法竞赛？纯纯网瘾罢！</del></p>
<p><strong>套题合集：</strong></p>
<ul>
<li><p><a href="https://anasuuuu.github.io/2023/07/19/HDU-In-Summer-0/">算法竞赛 | 杭电多校训练</a></p>
</li>
<li><p><a href="https://anasuuuu.github.io/2023/06/26/CF-Instrumentality-Project-I/">CodeForces 补全计划（1826 ~ 1850）</a>    </p>
</li>
<li><p><a href="https://anasuuuu.github.io/2023/08/27/CF-Instrumentality-Project-II/">CodeForces 补全计划（1851 ~ 1875）</a></p>
</li>
</ul>
<p><strong>数学：</strong></p>
<ul>
<li><p><a href="https://anasuuuu.github.io/2023/07/05/Math-In-ACM-I/">算法笔记 | 数论（一）</a>：扩展欧几里得，逆元，欧拉函数，中国剩余定理，卢卡斯定理。</p>
</li>
<li><p><a href="https://anasuuuu.github.io/2023/07/20/Game-In-ACM/">算法笔记 | 博弈论</a>：SG 函数。</p>
</li>
<li><p><a href="https://anasuuuu.github.io/2023/06/28/Poly/">学习笔记 | 多项式与生成函数</a></p>
</li>
</ul>
<p><strong>字符串：</strong></p>
<ul>
<li><a href="https://anasuuuu.github.io/2023/07/10/String-In-ACM-I/">算法笔记 | 字符串（一）</a>：Manacher，KMP。</li>
</ul>
<p><strong>杂项：</strong></p>
<ul>
<li><a href="https://anasuuuu.github.io/2023/07/07/somethingelse-in-ACM/">算法笔记 | 杂项（一）</a></li>
</ul>
<h2 id="大学课程"><a href="#大学课程" class="headerlink" title="大学课程"></a>大学课程</h2><p>摸鱼大专笔记 ⊙﹏⊙∥ 以应付考试为主。</p>
<p><strong>大一下：</strong></p>
<ul>
<li><a href="https://anasuuuu.github.io/2023/06/06/Physics-I/">大学笔记 | 大学物理BI</a></li>
<li><a href="https://anasuuuu.github.io/2023/06/05/Circuit-Analysis/">大学笔记 | 电路原理</a></li>
<li><a href="https://anasuuuu.github.io/2023/06/05/Calculus/">大学笔记 | 微积分</a></li>
<li><a href="https://anasuuuu.github.io/2023/06/06/Linear-Algebra/">大学笔记 | 线性代数</a></li>
</ul>
<p><strong>大二上：</strong></p>
<ul>
<li><a href="https://anasuuuu.github.io/2023/08/30/Physics-II/">大学笔记 | 大学物理BII</a></li>
<li><a href="https://anasuuuu.github.io/2023/08/29/Discrete-Math/">大学笔记 | 离散数学</a></li>
<li><a href="https://anasuuuu.github.io/2023/08/29/Electronic-Devices-and-Circuit-Theory/">大学笔记 | 模拟电子技术基础</a></li>
<li><a href="https://anasuuuu.github.io/2023/08/29/Probability/#more">大学笔记 | 概率论与数理统计</a></li>
<li><a href="https://anasuuuu.github.io/2023/08/29/Probability/#more">大学笔记 | 信号与系统</a></li>
</ul>
<h2 id="学习笔记"><a href="#学习笔记" class="headerlink" title="学习笔记"></a>学习笔记</h2><p><strong>Linux 系列：</strong></p>
<ul>
<li><p><a href="https://anasuuuu.github.io/2023/07/09/UCB-CS61B/">学习笔记 | UCB-CS61B</a></p>
</li>
<li><p><a href="https://anasuuuu.github.io/2023/06/27/Cross-The-Hole/">博客搭建踩坑指北</a></p>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>大学笔记 | 线性代数</title>
    <url>/2023/06/06/Linear-Algebra/</url>
    <content><![CDATA[<p>从入门到入土</p>
<span id="more"></span>
<h2 id="第一章-矩阵的运算与初等变换"><a href="#第一章-矩阵的运算与初等变换" class="headerlink" title="第一章 矩阵的运算与初等变换"></a>第一章 矩阵的运算与初等变换</h2><h3 id="S-1-1-矩阵和向量的概念"><a href="#S-1-1-矩阵和向量的概念" class="headerlink" title="$\S 1.1$ 矩阵和向量的概念"></a>$\S 1.1$ 矩阵和向量的概念</h3><ul>
<li><p>矩阵</p>
<p>  $m \times n$ 的数表构成 $m$ 行 $n$ 列矩阵，这 $m \times n$ 个数是 $A$ 的元素，简称元</p>
<p>  实矩阵就是全是实数元素的矩阵</p>
<p>  复矩阵就是全是复数元素的矩阵</p>
<ul>
<li><p>特殊矩阵</p>
<p>  同型矩阵：行数和列数都分别相等的矩阵（指的是两个矩阵之间的关系）</p>
<p>  相等矩阵：同型矩阵、对应元素相等<br>  方阵：行数列数相等（就单个矩阵而言）</p>
<p>  上（下）三角矩阵：主对角线下（上）元素全为 $0$ 的矩阵</p>
<p>  对角矩阵：只有对角线上元素不为 $0$</p>
<p>  列矩阵，行矩阵：$1 \times n$，$n \times 1$ 的矩阵</p>
<p>  单位矩阵：特殊的对角阵，对角线上全为 $1$</p>
<p>  零矩阵：全为 $0$</p>
<p>  负矩阵：$-A $ 是 $A$ 的负矩阵</p>
<p>  对称矩阵：元素关于对角线对称</p>
<p>  反对称矩阵：元素关于对角线称相反数且对角线上元素全为 $0$</p>
</li>
</ul>
</li>
</ul>
<h2 id="第二章-方阵的行列式"><a href="#第二章-方阵的行列式" class="headerlink" title="第二章 方阵的行列式"></a>第二章 方阵的行列式</h2><h3 id="省流"><a href="#省流" class="headerlink" title="省流"></a>省流</h3><p>行列式</p>
<h2 id="第三章-可逆矩阵"><a href="#第三章-可逆矩阵" class="headerlink" title="第三章 可逆矩阵"></a>第三章 可逆矩阵</h2><h3 id="省流-1"><a href="#省流-1" class="headerlink" title="省流"></a>省流</h3><p>可逆矩阵，行列式的秩，伴随矩阵</p>
<h2 id="第四章-线性方程组和向量组的线性相关性"><a href="#第四章-线性方程组和向量组的线性相关性" class="headerlink" title="第四章 线性方程组和向量组的线性相关性"></a>第四章 线性方程组和向量组的线性相关性</h2><h3 id="省流-2"><a href="#省流-2" class="headerlink" title="省流"></a>省流</h3><p>方程组数和未知数相等可以直接用卡莱姆法则</p>
<p>不同的时候，齐次下直接找通解，非齐次是通解和特解叠加</p>
<h2 id="第五章-方阵的特征值，特征向量与相似化简"><a href="#第五章-方阵的特征值，特征向量与相似化简" class="headerlink" title="第五章 方阵的特征值，特征向量与相似化简"></a>第五章 方阵的特征值，特征向量与相似化简</h2><h3 id="S-5-1-数域-多项式的根"><a href="#S-5-1-数域-多项式的根" class="headerlink" title="$\S 5.1$ 数域 多项式的根"></a>$\S 5.1$ 数域 多项式的根</h3><ul>
<li><p>数域</p>
<p>  设 $\mathbb{Q} \subseteq K \subseteq \mathbb{C}$，称 $K$ 为一个数域，当：</p>
<ol>
<li>$0, 1 \in K$</li>
<li>$\forall a, b \in K. a \pm b, ab \in K$， 且对 $b \not= 0, b^{-1} \in K$</li>
</ol>
</li>
<li><p>多项式，根，零点，标准分解式</p>
</li>
</ul>
<h3 id="S-5-2-方阵的特征值与特征向量"><a href="#S-5-2-方阵的特征值与特征向量" class="headerlink" title="$\S 5.2$ 方阵的特征值与特征向量"></a>$\S 5.2$ 方阵的特征值与特征向量</h3><ul>
<li><p>$n$ 阶 $A$ 矩阵对角线上元素的和称为 $A$ 的迹，记为 $trA$</p>
</li>
<li><p>$\lambda E - A$ 称为 $A$ 的特征矩阵，$|\lambda E - A|$ 的值表达式 $\psi(\lambda)$ 是一   </p>
<p>  个多项式，称为 $A$ 的特征多项式，特征多项式的根称为 $A$ 的特征值，亦称为特征根 </p>
<ul>
<li>$\psi(\lambda) = \lambda^n+c_{n-1}\lambda^{n-1}+ \cdots + c_1\lambda + c_0$ 则有 $c_{n - 1} = -trA,c_0 = (-1)^n|A|$</li>
<li>设 $n$ 阶矩阵 $A$ 的全部特征值 $\lambda_1,\lambda_2,\cdots,\lambda_n$，则有<ol>
<li>$|A| = \lambda_1\cdots\lambda_n$</li>
<li>$tr(A) = \lambda_1 + \cdots + \lambda_n$</li>
<li>由 $(1)$ 可知方阵可逆的充要条件是所有特征值均不为 $0$</li>
</ol>
</li>
</ul>
</li>
<li><p>非零特征向量 $a$ 满足对于特征值 $\lambda_0$，有 $Aa = \lambda_0a$ </p>
<ul>
<li>若存在数 $\lambda_0$ 以及非零向量 $a$ 使 $Aa = \lambda_0a$ ，则必有 $\lambda_0$ 是 $A$ 的特征值，$a$ 是 $A$ 关于 $\lambda_0$ 的特征向量</li>
<li>属于不同特征值的特征向量是线性无关的</li>
<li>对于矩阵 $A$ 的 $r$ 重特征值 $\lambda$ ，属于他的线性无关特征向量个数 $k \le r$</li>
</ul>
</li>
<li><p>一些结论和补充</p>
<ul>
<li>设 $R(A) = n - 1$ ，则 $A^*$ 的特征值为 $0$ （$n-1$ 重）和 $\sum_{i = 1}^{n}A_{ii}$ （$A_{ii}$ 为 $A$ 的元素 $a_{ii}$  对应的代数余子式）</li>
<li>设 $R(A) &lt; n-1$ ，则 $A^*$ 有 $n$ 重零特征值</li>
<li><p>若 $\lambda$ 是 $A$ 的特征值，则 $\varphi(\lambda)$ 是 $\varphi(A)$ 的特征值</p>
</li>
<li><p>|          | $A$       | $\varphi(A)$       | $A^{-1}$            | $A^*$                           | $B=P^{-1}AP$   |<br>  | :———- | ————- | ————————— | —————————- | ———————————————- | ——————— |<br>  | 特征值   | $\lambda$ | $\varphi(\lambda)$ | $\frac{1}{\lambda}$ | $\frac{\vert A \vert}{\lambda}$ | $\lambda$      |<br>  | 特征向量 | $\alpha$  | $\alpha$           | $\alpha$            | $\alpha$                        | $p^{-1}\alpha$ |</p>
</li>
<li><p>$A^T$ 与 $A$ 的特征值相同，但特征向量未必相同</p>
</li>
<li><p>幂等矩阵 $A$ （$A^2 = A$）特征值为 $0$ 或 $1$</p>
<p>  对合矩阵 $A$ （$A^2 = E$）特征值为 $-1$ 或 $1$</p>
<p>  幂零矩阵 $A$ （$A^2 = 0$）特征值为 $0$</p>
<p>  正交矩阵 $A$ （$AA^T = E$）特征值不一定为实数，但模长一定为 $1$ </p>
<p>  $n$ 阶实矩阵 $A$ 满足 $R(A) = n - 1$，特征值 $\lambda_1 = \sum_{i = 1}^na_{ii}$，$\lambda_2=\cdots=\lambda_n = 0$（其实就是方阵秩为 $n-1$ ，其伴随矩阵的特征值）</p>
</li>
</ul>
</li>
</ul>
<h3 id="S-5-3-方阵相似于对角矩阵的条件"><a href="#S-5-3-方阵相似于对角矩阵的条件" class="headerlink" title="$\S 5.3$ 方阵相似于对角矩阵的条件"></a>$\S 5.3$ 方阵相似于对角矩阵的条件</h3><ul>
<li><p>相似矩阵 $P^{-1}AP=B$</p>
<p>  相似变换，反身性，对称性，传递性</p>
<ul>
<li>$A\sim B$，则 $R(A) = R(B)$</li>
<li>$A\sim B$，则 $|A| = |B|$，即 $A,B$ 同时可逆或不可逆</li>
<li>$A\sim B$，则 $A^T \sim B^T$，更进一步，$f(A) \sim f(B)$</li>
<li>$A$ 可逆，$A\sim B$，则 $A^{-1} \sim B^{-1}$</li>
<li>$A\sim B$，则 $A$ 与 $B$ 特征多项式相同，<strong>从而 $A$ 与 $B$ 的特征值相同，但特征向量未必相同</strong>（BTW，特征多项式相同的矩阵未必相似）</li>
<li>$A$ 与对角矩阵相似，则对角矩阵上的元素是 $A$ 的 $n$ 个特征值</li>
</ul>
</li>
<li><p>$n$ 阶方阵 $A$ 可以相似对角化的充要条件是 $A$ 有 $n$ 个线性无关的特征向量</p>
</li>
<li><p>设 $\lambda_i$ 是方阵 $A$ 的 $n_i$ 重特征值，那么 $A$ 对应于 $\lambda_i$ 的特征向量中线性无关组的向量个数最多为 $n_i$ 个</p>
</li>
<li><p>$A$ 的全部特征向量的一个极大无关组，称为 $A$ 的一个特征向量系，其向量个数 $q=\sum_{i=1}^tm_i \le \sum_{t=1}^{t}n_i=n$，$q$ 为 $n$ 时，$A$ 的特征向量时完全的，否则是不完全的，值得注意的是，对于 $A$ 的任一单特征值 $\lambda_i$，必有 $m_i=n_i=1$（$n_i$ 表示第 $i$ 个特征根重数，$m_i$ 表示第 $i$ 个特征根对应方程解的个数）</p>
</li>
</ul>
<h3 id="S-5-4-正交矩阵"><a href="#S-5-4-正交矩阵" class="headerlink" title="$\S 5.4$ 正交矩阵"></a>$\S 5.4$ 正交矩阵</h3><ul>
<li>内积，向量长度，单位向量</li>
<li>正交向量组（对于只含一个向量 $a$ 的向量组，当 $a \ne 0$ 时，该向量组也是正交组）<ul>
<li>正交向量组也线性无关</li>
</ul>
</li>
<li>将一个全是单位向量的且两两正交的向量组称为单位正交向量组</li>
<li>$Schmidt$ 逐步正交化</li>
<li>正交矩阵（$AA^T = E$）<ul>
<li>$n$ 阶实矩阵 $A$ 为正交矩阵的充要条件是 $A$ 的行（列）向量都是两两正交的单位向量</li>
<li>若 $A$ 是正交矩阵，则 $|A| = 1$ 或 $|A| = -1$ </li>
<li>若 $A$，$B$ 均是正交矩阵，则 $AB$ 也是正交矩阵，但 $A+B$ 不是</li>
<li>若 $A$ 是正交矩阵，则 $A^*$，$A^{-k}$ ，$A^k$ 亦为正交矩阵</li>
<li>若 $A$ 是正交矩阵，且 $\lambda$ 是 $A$ 的特征值，则 $|\lambda| = 1$，且 $\frac{1}{\lambda}$ 也是 $A$ 的特征值</li>
</ul>
</li>
<li>设 $P$ 为正交矩阵， $y = Px$ 为正交变换，正交变换不改变模长</li>
</ul>
<h3 id="S-5-5-实对称矩阵的相似对角化"><a href="#S-5-5-实对称矩阵的相似对角化" class="headerlink" title="$\S 5.5$ 实对称矩阵的相似对角化"></a>$\S 5.5$ 实对称矩阵的相似对角化</h3><ul>
<li>实对称矩阵的特征值<strong>必为实数</strong></li>
<li>实对称阵 $A$  <strong>不同特征值对应的特征向量正交</strong>，且二者互为充要条件</li>
<li>实对称阵<strong>一定能相似对角化</strong></li>
<li>实对称矩阵<strong>非零特征值个数等于它的秩</strong></li>
<li>若$A$，$B$ 均为实对称阵，且 $A$ 和 $B$ 特征值完全相同，则必有 $A \sim B$</li>
</ul>
<h2 id="第六章-二次型与对称矩阵"><a href="#第六章-二次型与对称矩阵" class="headerlink" title="第六章 二次型与对称矩阵"></a>第六章 二次型与对称矩阵</h2><h3 id="S-6-1-二次型及其矩阵"><a href="#S-6-1-二次型及其矩阵" class="headerlink" title="$\S 6.1$ 二次型及其矩阵"></a>$\S 6.1$ 二次型及其矩阵</h3><ul>
<li><p>二次型，二次型矩阵，二次型的秩，线性变换（可逆变换，不可逆变换）</p>
</li>
<li><p>合同变换</p>
<p>  $P^TAP = B$，则 $A, B$ 合同，记为 $A \simeq B$，$P$ 为合同因子</p>
<p>  合同必等价，反之不真</p>
<p>  合同和相似是两个独立概念，合同未必相似，相似未必等价</p>
</li>
<li><p>相关结论</p>
<p>  对实对称矩阵 $A, B$ 若 $A \sim B$，则 $A \simeq B$，但是合同未必相似 如 $diag\{3,3,3\}$ 和 $E$ 合同，但不相似</p>
<p>  若对实对称矩阵$A, B$ 特征值相同，则 $A \simeq B$，且$A \sim B$</p>
<p>  若 $A \simeq B$，则 $R(A) = R(B)$</p>
<p>  若 $A \simeq B$，且 $A$ 为对称矩阵则 $B$ 也为对称矩阵（特殊的若 $A \simeq \Lambda$，则 $A$ 必为对称阵）</p>
</li>
</ul>
<h3 id="S-6-2-二次型的标准型"><a href="#S-6-2-二次型的标准型" class="headerlink" title="$\S 6.2$ 二次型的标准型"></a>$\S 6.2$ 二次型的标准型</h3><ul>
<li><p>标准型</p>
<p>  标准型各项系数均是特征值</p>
</li>
<li><p>正交变换法</p>
</li>
<li><p>拉格朗日配方法</p>
<p>  如果只有交叉项利用平方差公式凑出平方项</p>
</li>
<li><p>相关结论</p>
<p>  任何二次型必可经过可逆线性变换为标准型</p>
<p>  任何对称矩阵必可合同于对角矩阵</p>
</li>
</ul>
<h3 id="S-6-3-合同变换与二次型的规范形"><a href="#S-6-3-合同变换与二次型的规范形" class="headerlink" title="$\S 6.3$ 合同变换与二次型的规范形"></a>$\S 6.3$ 合同变换与二次型的规范形</h3><ul>
<li><p>合同变换法</p>
<p>  三种初等合同变换。</p>
<p>  合同变换法 $(A|E) \to (\Lambda|P^T)$。</p>
</li>
<li><p>实二次型的规范形</p>
<p>  任何实对称矩阵必可经过实数域上变换得到如下矩阵</p>
<script type="math/tex; mode=display">
  \begin{bmatrix}
    1&  &  &  &  &  &  &  & \\\
    & \ddots  &  &  &  &  &  &  & \\\
    &  & 1 &  &  &  &  &  & \\\
    &  &  & -1 &  &  &  &  & \\\
    &  &  &  & \ddots &  &  &  & \\\
    &  &  &  &  & -1 &  &  & \\\
    &  &  &  &  &  & 0 &  & \\\
    &  &  &  &  &  &  & \ddots & \\\
    &  &  &  &  &  &  &  &0
  \end{bmatrix}</script></li>
</ul>
<pre><code>其中 $1$ 的个数 $p$ 称为正惯性指数，$-1$ 个数称为负惯性指数，$p-q$ 称为 $A$ 的符号差，正负惯性指数之和是 $A$ 的秩。

两个 $n$ 阶实对称阵合同的充要条件是它们秩相同且正惯性指数也相同。

特别地，若两个 $n$ 阶实对称阵的特征值相同，则它们必相似，从而必合同。
</code></pre><h3 id="S-6-4-实二次型的分类-正定二次型"><a href="#S-6-4-实二次型的分类-正定二次型" class="headerlink" title="$\S 6.4$ 实二次型的分类 正定二次型"></a>$\S 6.4$ 实二次型的分类 正定二次型</h3><ul>
<li><p>实二次型的分类</p>
<p>  对于实二次型 $f(x) = x^TAx$，若对任何非零实向量 $x$ 都有 $f(x)$，则称 $f$ 为正定二次型。</p>
<p>  可逆线性变化不改变实二次型的正定性。</p>
</li>
<li><p>正定二次型与正定矩阵<br>  $n$ 元实二次型正定的充分必要条件是其标准形中 $n$ 个平方项的系数全大于零。<br>  实二次型 $f(x) = x^TAx$ 正定的充分必要条件是 $A$ 的特征值全大于零。<br>  $n$ 元实二次型 $f(x) = x^TAx$ 正定的充分必要条件是它的正惯性指数为 $n$。</p>
<p>  实二次型 $f(x) = x^TAx$ 正定的充分必要条件是 $A$ 的所有顺次主子式全大于零。</p>
<p>  对于实对称矩阵$A$，如果实二次$f(x)=x^TAx$ 正定，则称 $A$ 是正定矩阵。</p>
<p>  实对称矩阵 $A$ 正定的充分必要条件是 $A \simeq E$。</p>
<p>  实对称矩阵 $A$ 正定的充分必要条件是：有可逆 $P$，使得 $A=P^TP$。</p>
</li>
<li><p>正定矩阵的一些简单性质：</p>
<ol>
<li>若 $A$ 是正定矩阵，则 $A^T, A^{-1}, A^*, A^k,kA$（ $k$ 为任意正实数）均为正定矩阵。</li>
<li>若 $A$ 正定，则有 $|A|&gt;0$, 从而 $A$ 必可逆。</li>
<li>设 $A$ 与 $B$ 是正定矩阵，则 $AB$ 是正定矩阵的充要条件是 $A$ 和 $B$ 可交换。</li>
<li>设 $A、B$ 都是 $n$ 阶正定矩阵，则 $A+B$ 也是正定矩阵。</li>
<li>设 $A$ 是 $n$ 阶正定矩阵，则对 $\forall \alpha &gt; 0, |A + \alpha E| &gt; \alpha^n$。</li>
</ol>
</li>
</ul>
]]></content>
      <tags>
        <tag>数学</tag>
        <tag>大学笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux学习笔记：git专题</title>
    <url>/2023/08/27/Linux-Git/</url>
    <content><![CDATA[<p>git 学习笔记。</p>
<span id="more"></span>
<h3 id="0-前言"><a href="#0-前言" class="headerlink" title="0. 前言"></a>0. 前言</h3><p>git 是一款非常强大的版本管理软件，它可以使你的文字稿 / 代码 / 图片等很好地存储管理起来，让其不在丢失，甚至能看到你修改过的不同痕迹。而 github 是一个著名开源平台，你可以将代码放在该网站上，它上面的一个个仓库既可以让你存放你的代码，让别人看见，也可以让你学习到别人的代码，起到 ”我为人人，人人为我“ 的开源作用。</p>
<p>本文参考于 <a href="https://www.bilibili.com/video/BV1Yx411f7Cu/?spm_id_from=333.1007.top_right_bar_window_custom_collection.content.click&amp;vd_source=0f0f84fd4f7853dba4619576003d75fb">再也不丢文件的方法～ Git从入门到精通</a>。</p>
<h3 id="1-本地基础操作"><a href="#1-本地基础操作" class="headerlink" title="1. 本地基础操作"></a>1. 本地基础操作</h3><p>把当前文件夹变为一个 git 仓库 创建 git 仓库：<code>git init</code>。</p>
<p>查看当前仓库文件变化情况：<code>git status</code>。</p>
<blockquote>
<p>如果文件是红色的，说明新的修改还未被添加，只有被添加的修改才能被提交，被保存好。</p>
</blockquote>
<p>添加修改：<code>git add xx</code>（xx 为想添加的文件名称）。</p>
<blockquote>
<p>可使用 <code>git add .</code> 来添加当前仓库所有修改。</p>
</blockquote>
<p>本次还没有提交的更改：<code>git diff</code>（比较工作区与暂存区的区别）。</p>
<p>回滚，撤销提交操作：<code>git reset</code>。</p>
<p>向 git 提交自己身份（name）：<code>git config --global user.name "xxx"</code>。</p>
<p>向 git 提交自己身份（email）：<code>git config --global user.email "xxx@xx.com"</code>。</p>
<p>向 git 提交内容：<code>git commit -m “xx”</code> （xx为对提交的内容进行描述）。</p>
<blockquote>
<p>如果直接 <code>git commit</code> 会进入一个编辑器界面，要求你对本次的修改进行描述。</p>
<p>修改默认编辑器：<code>git config --global core.editor vim / vscode / emacs</code>。</p>
<p><code>git commit -a</code> 可以直接</p>
</blockquote>
<p>让 git 不提交某些文件/忽略某些文件：创建文件 <code>.gitignore</code> 并在文件中添加文件名/文件夹名 即可。 </p>
<blockquote>
<p>若想让 <code>.gitignore</code> 忽略某些文件，但这些文件在之前已经被追踪过了，可以用：<code>git rm --cached xx （xx为文件名）</code> 来使 git 不再追踪这些文件。</p>
</blockquote>
<h3 id="2-git-分支"><a href="#2-git-分支" class="headerlink" title="2. git 分支"></a>2. git 分支</h3><p>git 添加分支：<code>git branch xx</code> （xx为分支名）。</p>
<p>git 切换分支：<code>git checkout xx</code> （xx为分支名）。</p>
<p>合并分支：<code>git merge xx</code>（xx为分支名）。</p>
<p>列出本地分支：<code>git branch</code>。</p>
<p>删除分支：<code>git branch -d xx</code> (xx为分支名，-D强制删除)。</p>
<blockquote>
<p>若 xx 分支有内容未被保存，git 会提醒你，不让你进行操作。</p>
</blockquote>
<h3 id="3-与别人共享代码-——-github-上线"><a href="#3-与别人共享代码-——-github-上线" class="headerlink" title="3. 与别人共享代码 —— github 上线"></a>3. 与别人共享代码 —— github 上线</h3><p>首先确保你在 github 上新建了一个仓库，使你本地的文件有仓库可以存放。</p>
<p>添加远程仓库：<code>git remote add origin git@server-name:path/repo-name.git</code> 。</p>
<p>查看远程仓库信息可以用：<code>git remote -v</code>。</p>
<p>当远程仓库不小心添加错了，也可以删除这个远程仓库：<code>git remote rm orgin</code></p>
<p>首次将本地分支提交到远程仓库：<code>git push -u origin xx</code>（<code>xx</code> 为分支名称）。</p>
<blockquote>
<p>之后会让你输入用户名和密码，若你想输入一次之后就不用再输入，则只用在 <code>git push</code> 之前加上一句 <code>git config credential.helper store</code>。</p>
<p>在次之后再提交这个分支只用 <code>git push</code> 即可。</p>
</blockquote>
<p>此后，每次本地提交后，只要有必要，就可以使用命令 <code>git push origin master</code> 推送最新修改。</p>
<blockquote>
<p>当 <code>git push</code> 失败的时候，常见情况是远程仓库和本地不一致导致冲突，可以先 <code>git pull origin main --allow-unrelated-histories</code>，强行拉去远程仓库信息然后合并，之后再 <code>git push</code> 就不冲突了。</p>
</blockquote>
<p>克隆仓库：<code>git clone xxx</code>（xxx为远程地址）。</p>
<p>若和别人合作之后，再次想把代码拉去下来只需要：<code>git pull</code> 即可。 </p>
]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 学习笔记</title>
    <url>/2023/07/22/Linux/</url>
    <content><![CDATA[<p>Linux 基础配置，包括 pacman 包管理，ranger 文件管理。</p>
<span id="more"></span>
<h3 id="更改字体大小"><a href="#更改字体大小" class="headerlink" title="更改字体大小"></a>更改字体大小</h3><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">nvim ~/.Xresources</span><br></pre></td></tr></tbody></table></figure>
<p>进去之后输入</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">Xft.dpi: 120</span><br></pre></td></tr></tbody></table></figure>
<p>即可将字体调整到合适的大小了。</p>
<h3 id="联网"><a href="#联网" class="headerlink" title="联网"></a>联网</h3><p>刚开始的时候需要输入一下命令:</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">wpa_passphrase Wifi_name Wifi_password &gt; internet.conf</span><br></pre></td></tr></tbody></table></figure>
<p>之后每次启动都要输入以下命令：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">ip link set wlo1 up</span><br><span class="line">sudo wpa_supplicant -c internet.conf -i wlo1 &amp;</span><br><span class="line">sudo dhcpcd</span><br></pre></td></tr></tbody></table></figure>
<h3 id="配置-VPN"><a href="#配置-VPN" class="headerlink" title="配置 VPN"></a>配置 VPN</h3><p>xfce 桌面环境下的 manjaro 没有图形化界面可以设置代理，只能用终端环境去编辑。</p>
<p>更改 proxy 配置，首先打开终端并输入:</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">sudo vim /etc/environment</span><br></pre></td></tr></tbody></table></figure>
<p>然后找到以 “http_proxy” 开头的设置，如果没有就自己新建。</p>
<p>添加如下：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">http_proxy="http://your_proxy_server:proxy_port"</span><br><span class="line">https_proxy="http://your_proxy_server:proxy_port"</span><br><span class="line">socks_proxy="http://your_proxy_server:proxy_port"</span><br></pre></td></tr></tbody></table></figure>
<p><strong>参考：</strong> <a href="https://www.zhihu.com/question/586110918/answer/2910628561">xface如何设置系统代理?</a></p>
<h3 id="pacman-教程"><a href="#pacman-教程" class="headerlink" title="pacman 教程"></a>pacman 教程</h3><p>pacman 之于 Arch，就好比 App store 之于 IOS。</p>
<ul>
<li><p><code>pacman -S xx</code></p>
<p>  安装 xx 软件。</p>
</li>
<li><p><code>pacman -Sy</code></p>
<p>  查询软件库是否是最新并更新。</p>
</li>
<li><p><code>pacman -Syy</code></p>
<p>  强行刷新并更新至最新软件库。</p>
</li>
<li><p><code>pacman -Su</code></p>
<p>  更新软件。</p>
</li>
<li><p><code>pacman -Syu</code></p>
<p>  更新软件库并更新软件。</p>
</li>
<li><p><code>pacman -Syyu</code></p>
<p>  强行刷新，更新至最新软件库并更新软件。</p>
</li>
<li><p><code>pacman -Ss xx</code></p>
<p>  查询所有名称带 xx 的软件。</p>
</li>
<li><p><code>pacman -Sc</code></p>
<p>  删除一些安装包等缓存。</p>
</li>
<li><p><code>pacman -R xx</code></p>
<p>  删除软件。</p>
</li>
<li><p><code>pacman -Rs xx</code></p>
<p>  删除软件及其相关依赖。</p>
</li>
<li><p><code>pacman -Rns xx</code>（推荐）</p>
<p>  删除软件，相关依赖以及全局配置文件（但不会删除个人配置文件，如.vimrc）。</p>
</li>
<li><p><code>pacman -Q</code></p>
<p>  查询电脑上所有软件。</p>
</li>
<li><p><code>pacman -Q | wc -l</code></p>
<p>  快速知道有多少软件。</p>
</li>
<li><p><code>pacman -Qe</code></p>
<p>  查询自己装的所有软件。</p>
</li>
<li><p><code>pacman -Qeq</code></p>
<p>  查询自己装的所有软件且不显示版本号。</p>
</li>
<li><p><code>pacman -Qs xx</code></p>
<p>  查询所有名字带 xx 的软件。</p>
</li>
<li><p><code>pacman -Qdt</code></p>
<p>  查询所有不再被依赖的软件。</p>
</li>
<li><p><code>pacman -Qdtq</code></p>
<p>  查询所有不再被依赖的软件且不显示版本号。</p>
</li>
<li><p><code>pacman -R $(pacman -Qdtq)</code></p>
<p>  删除所有不再被依赖的软件。</p>
</li>
<li><p><code>nvim /etc/pacman.conf</code> </p>
<p>  编辑 pacman 的配置文件。</p>
</li>
</ul>
<h3 id="Ranger-教程"><a href="#Ranger-教程" class="headerlink" title="Ranger 教程"></a>Ranger 教程</h3><ul>
<li><p><code>k</code> <code>j</code> 控制同目录下上下文件移动</p>
</li>
<li><p><code>[</code> <code>]</code>  控制上级目录的上下文件移动</p>
</li>
<li><code>&lt;Shift&gt; + H</code> 在历史记录中退回 <code>&lt;Shift&gt; + L</code> 在历史记录中前进</li>
<li><code>zh</code> 或 <code>&lt;Ctrl&gt; + h</code> 显示或隐藏系统文件</li>
</ul>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul>
<li>查看桌面环境（DE）</li>
</ul>
<p>打开终端并复制粘贴此命令：</p>
<figure class="highlight text"><table><tbody><tr><td class="code"><pre><span class="line">echo $XDG_CURRENT_DESKTOP</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>查看系统信息</li>
</ul>
<p>在终端中输入 <code>screenfetch</code> 即可，显示桌面环境版本以及其他系统信息。</p>
]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux学习笔记：vim专题</title>
    <url>/2023/08/27/Linux-Vim/</url>
    <content><![CDATA[<span id="more"></span>
]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>算法笔记 | 数论（一）</title>
    <url>/2023/07/05/Math-In-ACM-I/</url>
    <content><![CDATA[<p>扩展欧几里得，逆元，欧拉函数</p>
<span id="more"></span>
<h2 id="1-扩展欧几里得算法"><a href="#1-扩展欧几里得算法" class="headerlink" title="1. 扩展欧几里得算法"></a>1. 扩展欧几里得算法</h2><h3 id="1-1-算法介绍"><a href="#1-1-算法介绍" class="headerlink" title="1.1 算法介绍"></a>1.1 算法介绍</h3><p>设 $a, b$ 为不全为 $0$ 的整数，存在整数 $x, y$ 使得 $ax + by = (a, b)$。</p>
<p>进一步地，$ax + by = m$ 有解的充要条件是 $(a, b) | m$ （裴蜀定理，又叫做贝祖定理） 。</p>
<h3 id="1-2-证明"><a href="#1-2-证明" class="headerlink" title="1.2 证明"></a>1.2 证明</h3><p>若我们求 $ax + by = (a, b)$ 的解，不如先求 $bx + (a \mod b) y = (b, a \mod b)$ 的解，而且由欧几里得算法可知 $(a, b) = (b, a \mod b)$。</p>
<p>经过变换 $bx + (a \mod b)y = bx + (a - b \times \left \lfloor \dfrac{a}{b} \right \rfloor )y = ay + b(x - \left \lfloor \dfrac{a}{b} \right \rfloor y)$，所以得出 $bx + (a \mod b) y = (b, a \mod b)$ 的解为 $x_0, y_0$ 后就可以得出 $ax + by = (a, b)$ 的解是 $x = y_0, y = (x_0 - \left \lfloor \dfrac{a}{b} \right \rfloor y_0)$ 而通过不断辗转相除法，显然到最后我们得到的式子为 $(a, b)x + 0\times y = (a, b)$，很容易可以令 $x = 1, y = 0$ 为这里的一组解，然后不断迭代回去求出我们要的解。</p>
<p>对于进一步结论的证明，若 $m$ 是该方程组的解，由于 $(a, b)$ 可以整除左式，那么 $(a, b)$ 也可以整除右式（充分性）。</p>
<p>若 $(a, b)|m$，那么我们已知 $ax + by = (a, b)$ 的一组解，等式两边同时乘以 $\dfrac{m}{(a, b)}$ 便可以得到原方程组的解（必要性）。</p>
<h3 id="1-3-实现"><a href="#1-3-实现" class="headerlink" title="1.3 实现"></a>1.3 实现</h3><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">exgcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> &amp;x, <span class="type">int</span> &amp;y)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>) {</span><br><span class="line">        x = <span class="number">1</span>;</span><br><span class="line">        y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    }</span><br><span class="line">    <span class="type">int</span> d = <span class="built_in">exgcd</span>(b, a % b, y, x); </span><br><span class="line">    y -= (a / b) * x;</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="2-逆元"><a href="#2-逆元" class="headerlink" title="2. 逆元"></a>2. 逆元</h2><h3 id="2-1-定义"><a href="#2-1-定义" class="headerlink" title="2.1 定义"></a>2.1 定义</h3><p>若 $ab \equiv 1(\mod p)$ 则称 $a$，$b$ 在 模 $p$ 意义下互为逆元，记为 $a = inv(b)$。</p>
<h3 id="2-2-扩展欧几里得求逆元"><a href="#2-2-扩展欧几里得求逆元" class="headerlink" title="2.2 扩展欧几里得求逆元"></a>2.2 扩展欧几里得求逆元</h3><p>由上一节可知，扩展欧几里得可以求出 $ax + by = 1$ 的一组 $x, y$ 解，故我们要求 $ax \equiv 1(mod b)$ 即求 $ax + by = 1$ 的一组解，而且这里要求有解的条件是 $(a, b) = 1$，利用扩展欧几里得很容易得出。</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function">ll <span class="title">exgcd</span><span class="params">(ll a, ll b, ll &amp;x, ll &amp;y)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">        x = <span class="number">1</span>;</span><br><span class="line">        y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    }</span><br><span class="line">    ll d = <span class="built_in">exgcd</span>(b, a % b, y, x);</span><br><span class="line">    y -= (a / b) * x;</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">}</span><br><span class="line"><span class="function">ll <span class="title">inv</span><span class="params">(ll a, ll p)</span> </span>{</span><br><span class="line">    ll x, y;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">exgcd</span>(a, p, x, y) != <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> (x % p + p) % p;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="2-3-费马小定理求逆元"><a href="#2-3-费马小定理求逆元" class="headerlink" title="2.3 费马小定理求逆元"></a>2.3 费马小定理求逆元</h3><p>费马小定理的内容如下：</p>
<blockquote>
<p>若 $p$ 为素数，且 $(a, p) = 1$，则 $a^{p - 1} \equiv 1(mod  p)$。</p>
</blockquote>
<p><strong>证明（待完善）</strong></p>
<p>利用该定理，不难得出 $inv(a) \equiv a^{p - 2}(mod  p)$，故可以用快速幂来求解。</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">qpow</span><span class="params">(ll a, ll b, ll p)</span> </span>{</span><br><span class="line">    ll ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (b) {</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) ans = ans % p * a % p;</span><br><span class="line">        a = a % p * a % p;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">inv</span><span class="params">(ll a, ll p)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">qpow</span>(a, p - <span class="number">2</span>, p);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="2-4-线性递推求解逆元"><a href="#2-4-线性递推求解逆元" class="headerlink" title="2.4 线性递推求解逆元"></a>2.4 线性递推求解逆元</h3><p>如果题目要求 $1 \sim n$ 的逆元，那么前两种方法都很低效，这里引入第三种，线性递推来求解。</p>
<p>下面用 $O(n)$ 方法求 $1 \sim n$ 关于 $p$ 的逆元。</p>
<p>首先显然 $1^{-1} \equiv 1(mod  p)$。</p>
<p>对于数 $i$，有 $p = ki + j$，这里 $k = \left \lfloor \dfrac{p}{i} \right \rfloor,j = p \% i$。</p>
<p>那么则有 $ki + j \equiv 0(mod  p)$，等式两边同时乘以 $i^{-1}j^{-1}$，则有 $kj^{-1} + i^{-1} \equiv 0(mod  p)$。</p>
<p>故 $i^{-1} \equiv -\left \lfloor \dfrac{p}{i} \right \rfloor(p  mod  i)^{-1}(mod  p)$，而且 $p  mod  i$ 肯定小于 $i$ ，所以可以由前递推后。</p>
<p>值得一提的是，这里为防止出现负数，所以写的是 <code>p - p / i</code> ，而且当 $i | p$ 时 <code>inv[i]</code> 应该是没有意义的，我们往往用大素数 $10^9 + 7$ 来表示。</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">inv[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) {</span><br><span class="line">  inv[i] = (<span class="type">long</span> <span class="type">long</span>)(p - p / i) * inv[p % i] % p;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="2-5-求任意-n-个数的逆元"><a href="#2-5-求任意-n-个数的逆元" class="headerlink" title="2.5 求任意 n 个数的逆元"></a>2.5 求任意 n 个数的逆元</h3><p>对于求任意 $n$ 个数 $a_i$，我们算这个 $n$ 个数的前缀积，记为 $s_i$。</p>
<p>然后我们计算 $s_n$ 的逆元为 $sInv_n$，那么 $s_i$ 的逆元为 $sInv_i =sInv_{i + 1} \times a_{i + 1}$。</p>
<p>然后易得 $a_i$ 的逆元 $Inv_i = sInv_i \times s_{i - 1}$。</p>
<p>时间复杂度近似 $O(n)$。 </p>
<h2 id="3-欧拉函数"><a href="#3-欧拉函数" class="headerlink" title="3. 欧拉函数"></a>3. 欧拉函数</h2><h2 id="4-中国剩余定理"><a href="#4-中国剩余定理" class="headerlink" title="4. 中国剩余定理"></a>4. 中国剩余定理</h2><h3 id="4-1-问题简述"><a href="#4-1-问题简述" class="headerlink" title="4.1 问题简述"></a>4.1 问题简述</h3><p>中国剩余定理是用来求解诸如</p>
<script type="math/tex; mode=display">
\begin{cases} x \equiv a_1(\mod n_1) \\ x \equiv a_2(\mod n_2) \\ \ \ \ \ \vdots \\ x \equiv a_k(\mod n_k) \end{cases}</script><p>这样的方程组问题。</p>
<h3 id="4-2-过程"><a href="#4-2-过程" class="headerlink" title="4.2 过程"></a>4.2 过程</h3><ol>
<li>算所有模数的积 $n$；</li>
<li>对于第 $i$ 个方程：<ul>
<li>计算 $m_i = \dfrac{n}{n_i}$；</li>
<li>计算 $m_i$ 在模 $n_i$ 意义下的逆元 $m_i^{-1}$；</li>
<li>计算 $c_i = m_im_i^{-1}$（这时不要对 $n_i$ 取模）</li>
</ul>
</li>
<li>方程组在模 $n$ 意义下的唯一解为 $x = \sum_{i = 1}^k a_ic_i(\mod n)$</li>
</ol>
<h3 id="4-3-实现"><a href="#4-3-实现" class="headerlink" title="4.3 实现"></a>4.3 实现</h3><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CRT</span><span class="params">()</span> </span>{</span><br><span class="line">  ll n, M = <span class="number">1</span>, ans = <span class="number">0</span>;</span><br><span class="line">  cin &gt;&gt; n; </span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) {</span><br><span class="line">    cin &gt;&gt; b[i] &gt;&gt; a[i];</span><br><span class="line">    M *= b[i];</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) {</span><br><span class="line">    ll m = M / b[i];</span><br><span class="line">    ll x, y;</span><br><span class="line">    <span class="built_in">exgcd</span>(m, b[i], x, y); <span class="comment">// 注：如果模数不为质数时，求逆元不能用费马小定理来算，只能用扩欧来算</span></span><br><span class="line">    x = (x + b[i]) % b[i]; x %= M;</span><br><span class="line">    m *= x; m %= M;</span><br><span class="line">    ans += a[i] * m % M;</span><br><span class="line">    ans %= M;</span><br><span class="line">  }</span><br><span class="line">  cout &lt;&lt; (ans % M + M) % M &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">return</span> ;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="4-4-扩展中国剩余定理"><a href="#4-4-扩展中国剩余定理" class="headerlink" title="4.4 扩展中国剩余定理"></a>4.4 扩展中国剩余定理</h3><p>中国剩余定理的适用范围是模数互质的情况，那么当方程模数不互质时我们要用到扩展中国剩余定理。</p>
<p>思路是不断把 $n$ 个方程两两合并，对于</p>
<script type="math/tex; mode=display">
\begin{cases} x \equiv b(\mod a) \\ x \equiv B(\mod A)  \end{cases}</script><p>我们令 $x = ya + b = YB + A$ ，那么有 $B - b = ya - YA$，我们利用扩欧可以求解出 $x’a + y’A = (a,A)$ 的一组解，那么若 $(a, A) \nmid B-b$ 则方程无解，对于有解的情况 $(x’ \times \dfrac{B - b}{(a, A)})a + (y’ \times \dfrac{B - b}{(a, A)})A = B - b$，令 $X = x’ \times \dfrac{B - b}{(a, A)}, Y = y’ \times \dfrac{B - b}{(a, A)}$ 若是让解最小即是让 $X$ 最小，我们调整 $X$ 可以通过让 $X + k \times \dfrac{A}{(a, A)}$，这时 $Y$ 相应减去同等系数的 $\dfrac{a}{(a, A)}$。所以 $X = (X \mod \dfrac{A}{(a, A)} + \dfrac{A}{(a, A)}) \mod \dfrac{A}{(a, A)}$。求出新的 $X$ 后再根据 $x = yX + a$ 可以求出新的 $x$，新的 $b = x \mod \dfrac{A \times a}{(a, A)}$，新的 $a = \dfrac{A \times a}{(a, A)}$。那么就可以得出新的方程 $x \equiv b(\mod a)$ 了。最后通过不断合并变为一个方程就能求出答案了。  </p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ExCRT</span><span class="params">()</span> </span>{</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) {</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>, &amp;A, &amp;B);</span><br><span class="line">    <span class="keyword">if</span>(i == <span class="number">1</span>) {</span><br><span class="line">      a = A;</span><br><span class="line">      b = B;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> {</span><br><span class="line">      g = <span class="built_in">exgcd</span>(a, A, x, y);</span><br><span class="line">      <span class="keyword">if</span>((B - b) % g) {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"-1"</span>);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">      }</span><br><span class="line">      x = x * ((B - b) / g);</span><br><span class="line">      x = (x % (A / g) + (A / g)) % (A / g);</span><br><span class="line">      l = A / g * a;</span><br><span class="line">      b = ((a * x + b) % l + l) % l;</span><br><span class="line">      a = l;</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, b % a);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="5-卢卡斯定理"><a href="#5-卢卡斯定理" class="headerlink" title="5. 卢卡斯定理"></a>5. 卢卡斯定理</h2><h3 id="5-1-定义"><a href="#5-1-定义" class="headerlink" title="5.1 定义"></a>5.1 定义</h3><p>对于质数 $p$，有</p>
<script type="math/tex; mode=display">
\begin{pmatrix} n \\ m \end{pmatrix} \mod p = \begin{pmatrix} \left \lfloor \dfrac{n}{p} \right \rfloor \\ \left \lfloor \dfrac{m}{p}\right \rfloor \end{pmatrix} \cdot \begin{pmatrix} n \mod p \\m \mod p \end{pmatrix} \mod p</script><p>由于$n \mod p$ 和 $m \mod p$ 肯定小于 $p$，所以直接算即可，对 $\left \lfloor \dfrac{n}{p} \right \rfloor$ 部分再用卢卡斯定理计算。</p>
<p>也即 $Lucas(n,m,p)=c(n\%p,m\%p)×Lucas(\dfrac{n}{p},\dfrac{m}{p},p)$。</p>
<h3 id="5-2-证明"><a href="#5-2-证明" class="headerlink" title="5.2 证明"></a>5.2 证明</h3><p>首先证明首先我们需要证明 $C_p^i \equiv \dfrac{p}{i}C_{p - 1}^{i - 1} \equiv 0(\mod p)(1 \le i \le p-1)$ 由于 $p$ 为质数，故 $\dfrac{1}{i}C_{p - 1}^{i - 1}$ 为整数，乘以 $p$ 后和 $p$ 同余为 $0$，故得证。</p>
<p>根据这个性质有 $(1 + x)^p \equiv 1 + x^p(\mod p)$</p>
<p>对于 $C_m^n \mod p$，其实就是求 $(1 + x^n)\mod p$ 中 $x^m$ 的系数。</p>
<p>我们令 $n = ap +b$，$m = cp + d$。所以接下来证 $C_n^m \equiv C_a^c \times C_b^d(\mod p)$。</p>
<p>我们有</p>
<script type="math/tex; mode=display">
(1 + x)^n \equiv (1 + x)^{pa}(1 + x)^b \equiv (1 + x^p)^a(1 + x)^b(\mod p)</script><p>观察 $x^m$ 的系数，故 $C_n^m x^m \equiv C_a^c x^{cp}C_b^dx^d(\mod p)$，由于 $x^b$ 系数一致，所以 </p>
<script type="math/tex; mode=display">
C_n^m \equiv C_a^c \times C_b^d \equiv C_{\left \lfloor \frac{n}{p} \right \rfloor}^{\left \lfloor \frac{m}{p} \right \rfloor} \times C_{n \mod p}^{m \mod p}(\mod p)</script><p>故得证。</p>
<h3 id="5-3-实现"><a href="#5-3-实现" class="headerlink" title="5.3 实现"></a>5.3 实现</h3><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function">ll <span class="title">Lucas</span><span class="params">(ll n, ll m)</span> </span>{</span><br><span class="line">  <span class="keyword">return</span> ((m == <span class="number">0</span>) ? <span class="number">1</span> : (<span class="built_in">c</span>(n % p, m % p) % p * <span class="built_in">Lucas</span>(n / p, m / p) % p));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="5-4-扩展卢卡斯定理"><a href="#5-4-扩展卢卡斯定理" class="headerlink" title="5.4 扩展卢卡斯定理"></a>5.4 扩展卢卡斯定理</h3>]]></content>
      <tags>
        <tag>算法竞赛</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>大学笔记 | 大学物理BI</title>
    <url>/2023/06/06/Physics-I/</url>
    <content><![CDATA[<p>从入门到放弃。</p>
<span id="more"></span>
<p>公式汇总</p>
<script type="math/tex; mode=display">
\begin{gather}
热力学\\ \\
内能 \ \Delta E = \frac{i}{2}\frac{m}{M}R\Delta T = \frac{i}{2}pV\\ \\
热量 \ Q = \frac{m}{M}C_k \Delta T \\ \\
等体过程\ C_V = \frac{i}{2}R \ \ 等压过程\ C_p = \frac{i + 2}{2}R\\ \\
等温过程\ A = \frac{m}{M}RTln\frac{V_2}{V_1}\\ \\ 
一般PV围成的面积减小是放热，增大是吸热\\ \\ 
p = nkT(微观形式)\\ \\
\varepsilon_k = \frac{3}{2}kT\\ \\
电场\\ \\
均匀带电圆环轴线上电场 \ E = \frac{qx}{4\pi \varepsilon_0 (R^2 + x^2) ^{3/2}}\\ \\
圆电流圆心处电场 \ E = 0\\ \\
平板电容\ C = \frac{\varepsilon S}{d}\ 圆柱形电容\ C = \frac{2\pi \varepsilon l}{ln\frac{R_B}{R_A}}\ 平板电容\ C = \frac{4\pi\varepsilon R_A R_B}{R_A - R_B}\ \\ \\
磁场 \\ \\
圆电流轴线上磁场 \ B = \frac{\mu_0 I R^2}{2(R^2 + x^2)^{3 / 2}}\\ \\
圆电流圆心处产生磁场 \ B = \frac{\mu I}{2R} \\ \\
\end{gather}</script><h2 id="第三章-刚体的定轴转动"><a href="#第三章-刚体的定轴转动" class="headerlink" title="第三章 刚体的定轴转动"></a>第三章 刚体的定轴转动</h2><ul>
<li>常见几何体的转动惯量<ul>
<li>细圆环 &amp; 薄圆环 $MR^2$</li>
<li>薄圆盘 &amp; 圆柱体 $\frac{1}{2}MR^2$</li>
<li>细棒 中心轴 $\frac{1}{12}MR^2$ 一端 $\frac{1}{3}ML^2$</li>
<li>薄球壳 $\frac{2}{3}MR^2$</li>
<li>球体 $\frac{2}{5}MR^2$</li>
</ul>
</li>
</ul>
<h2 id="第六章-热力学基础"><a href="#第六章-热力学基础" class="headerlink" title="第六章 热力学基础"></a>第六章 热力学基础</h2><h3 id="S-6-1-热力学第一定律"><a href="#S-6-1-热力学第一定律" class="headerlink" title="$\S 6.1$ 热力学第一定律"></a>$\S 6.1$ 热力学第一定律</h3><ul>
<li><p>热力学过程，准静态过程(曲线描述， 方程描述)</p>
<p>  <strong>只有准静态过程才能用曲线描述出来</strong></p>
</li>
<li><p>内能， 热量， 功</p>
<p>​    </p>
<p>​    </p>
</li>
</ul>
<h3 id="6-2-理想气体的典型热力学过程"><a href="#6-2-理想气体的典型热力学过程" class="headerlink" title="$6.2$ 理想气体的典型热力学过程"></a>$6.2$ 理想气体的典型热力学过程</h3><ul>
<li><p>等体过程<script type="math/tex">\begin{cases} 功 & \\ 内能 & \\ 热量 & \end{cases}</script></p>
</li>
<li><p>等压过程<script type="math/tex">\begin{cases} 功 & \\ 内能 & \\ 热量 & \end{cases}</script></p>
</li>
<li><p>等温过程<script type="math/tex">\begin{cases} 功 & \\ 内能 & \\ 热量 & \end{cases}</script></p>
</li>
<li>绝热过程<script type="math/tex">\begin{cases} 功 & \\ 内能 & \\ 热量 & \end{cases}</script></li>
</ul>
<h3 id="S-6-3-循环过程"><a href="#S-6-3-循环过程" class="headerlink" title="$\S 6.3$ 循环过程"></a>$\S 6.3$ 循环过程</h3><h3 id="S-6-4-热力学第二定律"><a href="#S-6-4-热力学第二定律" class="headerlink" title="$\S 6.4$ 热力学第二定律"></a>$\S 6.4$ 热力学第二定律</h3><h2 id="第七章-静电场"><a href="#第七章-静电场" class="headerlink" title="第七章 静电场"></a>第七章 静电场</h2><h4 id="第七章总结"><a href="#第七章总结" class="headerlink" title="第七章总结"></a>第七章总结</h4><ol>
<li>$k = \frac{1}{4\pi \varepsilon_0}$ ，$F = \frac{q_1q_2}{4\pi \varepsilon r^2}$</li>
<li>无限长均匀带电直线和均匀带电半圆弧对圆心处场强相等</li>
<li><p>电位移矢量 $\vec D = \varepsilon_0\varepsilon_r\vec E = \varepsilon \vec E$ ，很多时候 $\vec D$ 和 $\vec E$ 很相像，只是 $D$ 既与 $E$ 有关，又与电介质有关 </p>
</li>
<li><p>$\oint \vec D \cdot d\vec S = q$ ，多用对称做</p>
</li>
<li>$W_e = \frac{1}{2}U_{ab}Q, w_e = \frac{1}{2}DE$</li>
<li>平行板电容 $C = \frac{\varepsilon S}{d}$ ，圆柱形电容 $C = \frac{2 \pi \varepsilon l}{ln\frac{R_B}{R_A}}$， 球形电容 $C = \frac{4\pi \varepsilon R_A R_B}{R_B - R_A}$</li>
</ol>
<h3 id="S-7-1-点电荷-库仑定律"><a href="#S-7-1-点电荷-库仑定律" class="headerlink" title="$\S 7.1$ 点电荷 库仑定律"></a>$\S 7.1$ 点电荷 库仑定律</h3><ul>
<li>电荷的分类，电荷的量子化，电荷守恒定律，点电荷</li>
<li>库伦定律<ul>
<li>真空中， $\vec{F} = k\frac{q_1q_2}{r^2}\vec{e_r} = \frac{1}{4\pi\varepsilon_0}\frac{q_1q_2}{r^2}\vec{e_r}$</li>
<li>电介质中，$\vec{F} = \frac{1}{4\pi\varepsilon_0\varepsilon_r}\frac{q_1q_2}{r^2}\vec{e_r} = \frac{1}{4\pi\varepsilon}\frac{q_1q_2}{r^2}\vec{e_r}$</li>
</ul>
</li>
</ul>
<h3 id="S-7-2-电场-电场强度"><a href="#S-7-2-电场-电场强度" class="headerlink" title="$\S 7.2$ 电场 电场强度"></a>$\S 7.2$ 电场 电场强度</h3><p>​    电荷之间的作用是通过电场实现的</p>
<ul>
<li><p>电场强度 $\vec{E}= \frac{\vec{F}}{q_0} $</p>
</li>
<li><p>场强叠加原理</p>
</li>
<li><p>场强计算</p>
<ul>
<li><p>点电荷 $\vec{E} = \frac{q}{4\pi\varepsilon_0r^2}\vec{e_r}$</p>
</li>
<li><p>电偶极子（偶极矩 $\vec{p} = q\vec{l}$）（特殊情况下场强用中垂线和轴线场强叠加得到）</p>
<p>  中垂线上场强 $E_B = \frac{ql}{4\pi\varepsilon_0(r^2 + \frac{l^2}{4})^{3/2}}\approx \frac{-\vec{p}}{4\pi\varepsilon_0r^3}$</p>
<p>  轴线上场强 $E_A = \frac{1}{4\pi\varepsilon_0}[\frac{q}{(r - \frac{l}{2})^2} - \frac{q}{(r + \frac{l}{2})^2}] \approx\frac{ql}{2\pi\varepsilon_0r^3} = \frac{\vec{p}}{2\pi\varepsilon_0r^3}$</p>
</li>
<li><p><img src="例4.1.png" alt="例4.1"></p>
<p>  对于一均匀带电直线（$l,q$) 如上图，与其垂直相距 $a$ 的一点场强</p>
<p>  $E_x = \frac{\lambda}{4\pi\varepsilon_0a}(sin\theta_2 - \sin\theta_1)$</p>
<p>  $E_y = \frac{\lambda}{4\pi\varepsilon_0a}(cos\theta_1 - \cos\theta_2)$</p>
<p>  特殊的，中垂线上 $E = E_y = \frac{q}{4\pi\varepsilon_0a\sqrt{a^2 + l^2/4}}$</p>
<p>  ​                直线无限长时，$E = E_y = \frac{\lambda}{2\pi\varepsilon_0a}$</p>
</li>
<li><p>圆环轴线电场计算既可以直接算，也可以把上下分成两部分，各压缩为 $\frac{q}{2}$ 的点电荷来算 $E = \frac{1}{4\pi\varepsilon_0}\frac{qx}{(R^2 + x^2)^{\frac{3}{2}}}$</p>
</li>
<li><p>算圆盘电场可看作无数个圆环电场叠加 $E = \int_0^R\frac{1}{4\pi\varepsilon_0}\frac{2x\sigma\pi rdr}{(x^2 + r^2)^{3/2}} = \frac{\sigma}{2\varepsilon_0}[1-\frac{x}{\sqrt{x^2+R^2}}]$</p>
<p>  特殊的，当 $R \to \infty$，$E = \frac{\sigma}{2\varepsilon_0}$</p>
<p>  将两个带有等量异种电荷无限大板放一块，板中间 $E = \frac{\sigma}{\varepsilon_0}$，板外是 $0$</p>
<p>  注：电荷量密度是代数量，本身有正负</p>
</li>
<li><p>无限长均匀带电直线和均匀带电半圆弧对圆心产生的q等效</p>
</li>
</ul>
</li>
</ul>
<h3 id="S-7-3-静电场中的电介质-电位移"><a href="#S-7-3-静电场中的电介质-电位移" class="headerlink" title="$\S 7.3$ 静电场中的电介质 电位移"></a>$\S 7.3$ 静电场中的电介质 电位移</h3><ul>
<li><p>电介质，偶极子模型，有极分子，无极分子</p>
</li>
<li><p>电介质的极化（一般电场越强，温度越低（温度低使分子无规律性降低），分子排列越有序，极化效果越显著）</p>
<ul>
<li><p>位移极化</p>
<p>  分子中正负电荷各收到电场力，由于正负电荷中心相对位移而极化</p>
</li>
<li><p>转向极化</p>
<p>  分子收到电场产生的力矩作用而有序排列，从而产生的极化</p>
<p>二者宏观表现相同，一般不刻意区分</p>
<p>当介质中分子电偶极矩和不为零时，介质被极化</p>
<p>分子极化导致介质端面上出现的电荷称为束缚电荷，这种现象称为电极化</p>
<p>介质中电场 $E$ 是由自由电荷电场 $E_0$ 和极化电荷电场 $E’$ 叠加的结果，有 $\vec{E} = \vec{E’} + \vec{E_0}$（$E_0, E’$ 方向相反）</p>
<p>当介质<strong>均匀充满</strong>电场时，介质中任一点场强 $\vec{E}$ 为原来真空中该处场强 $\vec{E_0}$ 的 $\frac{1}{\varepsilon_r}$，$\varepsilon_r$ 因介质而异</p>
<p>电介质不被击穿的最大电场强度为该电介质的介电强度</p>
</li>
</ul>
</li>
<li><p>电极化强度</p>
<p>  $\vec P = \frac{\sum \vec P_{mole}}{\Delta V}$，单位是 $C·m^{-2}$ ，称为电极化强度矢量，反映了介质内电极化的强弱和方向</p>
<p>  均匀极化后的电极化强度等于极电荷密度 $\vec P = \sigma’$</p>
<p>  故有 $\vec E_0 = \frac{\sigma}{\varepsilon_0},\vec E’ = \frac{\sigma’}{\varepsilon_0},\vec E = \frac{\sigma}{\varepsilon_0\varepsilon_r}$，带入三者关系式得 $\sigma’ = \frac{\varepsilon_r - 1}{\varepsilon_r} \sigma$，反映了自由电荷和极化电荷的关系</p>
<p>  令 $\chi_e = \varepsilon_e - 1$，称为电介质的电极化率，那么 $P = \frac{\varepsilon_r - 1}{\varepsilon_r} \sigma = \varepsilon_0\chi_eE$</p>
</li>
<li><p>电位移矢量</p>
<p>  $\vec D = \varepsilon_0\vec E + \vec P = \varepsilon_0\varepsilon_r\vec E = \varepsilon\vec E$，$\vec D$ 为电位移矢量，$\varepsilon$ 称为介电常数</p>
</li>
</ul>
<h3 id="S-7-4-静电场中高斯定理"><a href="#S-7-4-静电场中高斯定理" class="headerlink" title="$\S 7.4$ 静电场中高斯定理"></a>$\S 7.4$ 静电场中高斯定理</h3><ul>
<li><p>电场线（有源性，无旋性，互不相交），电位移线，电通量$\Phi_e$（穿出闭合面为正，穿出为负）</p>
</li>
<li><p>高斯定理</p>
<p>  $\oint_S \vec D d\vec S = \sum q_i$ 这里的 $q$ 均为高斯面内部，高斯面并不客观存在</p>
</li>
</ul>
<h3 id="S-7-5-静电场的环路定理-电势"><a href="#S-7-5-静电场的环路定理-电势" class="headerlink" title="$\S 7.5$ 静电场的环路定理 电势"></a>$\S 7.5$ 静电场的环路定理 电势</h3><ul>
<li><p>静电场的环路定理</p>
<p>  $\oint_L E·dl = 0$，电场力是保守力，静电场是保守力场（有势场）</p>
</li>
<li><p>电势，电势叠加原理，</p>
</li>
</ul>
<h3 id="S-7-6-电场强度与电势梯度的关系"><a href="#S-7-6-电场强度与电势梯度的关系" class="headerlink" title="$\S 7.6$ 电场强度与电势梯度的关系"></a>$\S 7.6$ 电场强度与电势梯度的关系</h3><ul>
<li><p>等势面，电势梯度</p>
<p>  $\bigtriangledown = \frac{\partial}{\partial x}\vec i + \frac{\partial}{\partial y}\vec j + \frac{\partial}{\partial z}\vec k \to \vec E = -\bigtriangledown U$</p>
</li>
</ul>
<h3 id="S-7-7-静电场中的导体"><a href="#S-7-7-静电场中的导体" class="headerlink" title="$\S 7.7$ 静电场中的导体"></a>$\S 7.7$ 静电场中的导体</h3><ul>
<li><p>静电平衡</p>
<ul>
<li><p>条件</p>
<p>  导体内部 $\vec E = 0$，导体表面 $\vec E$ 与导体垂直，故导体为等势体</p>
</li>
<li><p>净电荷只分布于表面</p>
<p>  对于有空腔，空腔内无电荷的导体，净电荷依然只分布在外表面</p>
<p>  对于有空腔且空腔内有电荷的导体，内空腔表面产生电荷是内空腔电荷代数和为 $0$</p>
<p>  处于静电平衡的导体表面电荷面密度与该处表面曲率半径成正比</p>
<p>导体表面<strong>附近</strong>电场强度 $E = \frac{\sigma}{\varepsilon_0}$</p>
</li>
</ul>
</li>
<li><p>静电屏蔽</p>
<p>  导体空腔可以使腔内空间不受腔外带电体影响</p>
<p>  接地导体空腔可以使腔外空间不受腔内带电体影响</p>
</li>
<li><p>电容器</p>
<ol>
<li><p>平板电容器</p>
<p> $E = \frac{\sigma}{\varepsilon},U_{AB} = \frac{\sigma}{\varepsilon}d = \frac{qd}{\varepsilon s},C = \frac{q}{U_{AB}} = \frac{\varepsilon S}{d}$</p>
</li>
<li><p>圆柱形电容器</p>
<p> $E = \frac{\lambda}{2\pi\varepsilon r},U_{AB} = \frac{\lambda}{2\pi\varepsilon}ln\frac{R_B}{R_A},C = \frac{q}{U_{AB}} = \frac{2\pi\varepsilon l}{ln\frac{R_B}{R_A}}$</p>
</li>
<li><p>球形电容器</p>
<p> $E = \frac{q}{4\pi\varepsilon r^2},U_{AB} = \frac{q}{4\pi\varepsilon}(\frac{1}{R_A}-\frac{1}{R_B}),C = \frac{q}{U_{AB}} = \frac{4\pi\varepsilon R_A R_B}{R_B-R_A}$</p>
<p>决定电容器电容的因素是电容器的大小，形状，板间电介质</p>
</li>
</ol>
</li>
<li><p>电场能量</p>
<p>  $W_e = \frac{1}{2}U_{ab}Q = \frac{1}{2}CU_{ab}^2 = \frac{1}{2}\frac{Q_{ab}^2}{C}$</p>
<p>  $w_e = \frac{W_e}{V} = \frac{1}{2}\varepsilon E^2$，$w_e$ 是电场能量密度</p>
<p>  $W_e = \int_V w_edV$</p>
</li>
</ul>
<h2 id="第八章-稳恒磁场"><a href="#第八章-稳恒磁场" class="headerlink" title="第八章 稳恒磁场"></a>第八章 稳恒磁场</h2><h3 id="S-8-1-恒定电流"><a href="#S-8-1-恒定电流" class="headerlink" title="$\S 8.1$ 恒定电流"></a>$\S 8.1$ 恒定电流</h3><ul>
<li><p>电流和电流密度</p>
<p>  $I = \frac{dq}{dt} = qnvs$</p>
<p>  传导电流：到电介质中电荷的定向移动</p>
<p>  运流电流：带电导体的机械运动</p>
<p>  电流密度 $\vec J = \frac{dI}{dS_\tau}\vec e_n = \rho \vec v = nq \vec v$ </p>
<p>  $dI = JdS \times cos\theta = \vec J \cdot d\vec S,I = \int_S \vec J \cdot d\vec S$</p>
</li>
<li><p>欧姆定律</p>
<p>  $I = \frac{U}{R} = GU$</p>
<p>  $R = \int \frac{\rho dl}{S}$</p>
<p>  $J = \sigma E$      $\sigma$ 是电导率，$E$ 是场强</p>
</li>
<li><p>电动势</p>
<p>  电源提供非静电力使正电荷沿逆静电场方向运动</p>
<p>  电动势是单位正电荷绕闭合回路运动一周非静电力做的功 $\varepsilon = \frac{A}{q} = \oint_L\vec E_k d\vec l$ </p>
<p>  与电势不同的是，电动势与路径<strong>有关</strong></p>
</li>
</ul>
<h3 id="S-8-2-基本磁现象-安培定律"><a href="#S-8-2-基本磁现象-安培定律" class="headerlink" title="$\S 8.2$ 基本磁现象 安培定律"></a>$\S 8.2$ 基本磁现象 安培定律</h3><ul>
<li><p>基本磁现象</p>
</li>
<li><p>安培定律</p>
<p>  $F = \frac{\mu_0}{4\pi}\oint_{c_2}I_2d\vec l_2 \times \oint_{c_1} \frac{I_1d\vec l_1 \times \vec r_{12}}{\vec r_{12}^3} $</p>
<p>  方向：右手法则</p>
<p>  电流元之间的安培力不满足力的作用力和反作用力定律</p>
<blockquote>
<p>可以这样想，看是否满足力的相互作用关系就是看它们是否动量守恒，而两个电流元和它们中间的电磁场作为一个整体是守恒的，而电磁场动量不为 $0$，故不满足作用力与反作用力关系</p>
</blockquote>
</li>
</ul>
<h3 id="S-8-3-磁场-毕奥-萨伐尔定律"><a href="#S-8-3-磁场-毕奥-萨伐尔定律" class="headerlink" title="$\S 8.3$ 磁场 毕奥-萨伐尔定律"></a>$\S 8.3$ 磁场 毕奥-萨伐尔定律</h3><ul>
<li><p>磁场 磁感应强度</p>
<p>  磁场是一种特殊形态的<strong>物质</strong></p>
<p>  磁矩 $\vec m = IS\vec e_n$ 其中 $\vec e_n$ 与 $I$ 成方向满足右手螺旋定则</p>
<p>  $B = \frac{F_{max}}{qv} = \frac{dF}{Idl}$ ，$\vec B$ 的方向：$\vec F_{max} \times \vec v$</p>
</li>
<li><p>毕奥-萨伐尔定律</p>
<p>  电流元视为运动电荷的集合 $Id\vec l = dNq\vec v = nsd\vec lq \vec v$</p>
<p>  $dB = \frac{\mu_0Id\vec l \times \vec r}{4\pi r^3} = N\frac{\mu_0}{4\pi}\frac{q\vec v \times \vec r}{r^3}, \mu_0 = 4\pi \times 10 ^{-7} N / A^2$</p>
<p>  方向遵循右手法则 $Id\vec l \times \vec r$</p>
<ul>
<li><p>有限长的载流直导线磁场 $B = \frac{\mu_0I}{4\pi x}(cos\theta_1 - cos\theta_2)$</p>
<p><img src="载流直导线磁场.png" alt="载流直导线磁场"></p>
<p>​    一些特殊情况</p>
<p>​        点在直导线延长线上时 $B = 0$</p>
<p>​        无限长的载流直导线磁场 $B = \frac{\mu_0I}{2\pi a}$</p>
<p>​        半无限长的载流直导线磁场 $B = \frac{\mu_0I}{4\pi a}$</p>
<p>​        圆电流轴线上的磁场</p>
<p>​        $B = \frac{\mu_0IR^2\vec i}{2(R^2 + x^2)^{3/2}}$</p>
</li>
<li><p>圆电流直线上磁场磁场 $B = \frac{\mu_0IR^2\vec i}{2(R^2 + x^2)^{3/2}}$</p>
<p>  <img src="圆电流轴线上的磁场.png" alt="圆电流轴线上的磁场"></p>
<p>  一些说明</p>
<p>  ​            x=0时 $B = \frac{\mu_0 I}{2R}$</p>
<p>  ​            方向满足右手螺旋定则</p>
<p>  ​            N匝时， $B = N\frac{\mu_0IR^2\vec i}{2(R^2 + x^2)^{3/2}}$</p>
<p>  半无限长的载流直导线磁场 $B = \frac{\mu_0I}{4\pi a}$</p>
</li>
<li><p>载流直螺线管内部磁场 $B = \frac{\mu_0 nI}{2}(cos \beta_2 - cos\beta_1)$</p>
</li>
</ul>
</li>
</ul>
<p><img src="螺线管内部磁场-1.png" alt="螺线管内部磁场-1"></p>
<p><img src="螺线管内部磁场-2.png" alt="螺线管内部磁场-2"></p>
<p>​        一些特殊情况</p>
<p>​            无限长螺线管内部磁场 $B = \mu_0nI$</p>
<p>​            半无限长螺线管内部磁场 $B = \frac{\mu_0nI}{2}$</p>
<h3 id="S-8-4-磁通量-磁场中的高斯定理"><a href="#S-8-4-磁通量-磁场中的高斯定理" class="headerlink" title="$\S 8.4$ 磁通量 磁场中的高斯定理"></a>$\S 8.4$ 磁通量 磁场中的高斯定理</h3><ul>
<li>磁场线</li>
</ul>
<p>​        该点切线方向为该点磁场方向</p>
<p>​        不相交，是闭合的，磁场线和形成磁场的电流成右手螺旋关系</p>
<ul>
<li><p>磁通量</p>
<p>  匀强时 $\phi_m = \vec B \cdot \vec S$</p>
<p>  对任意磁场 $\phi_m = \int \vec B \cdot d\vec S$</p>
</li>
<li><p>磁场高斯定理</p>
<p>  $\oint \vec B \cdot d\vec S = 0$ 说明磁场是无源场</p>
</li>
</ul>
<h3 id="S-8-5-磁场对载流导线和运动电荷的作用"><a href="#S-8-5-磁场对载流导线和运动电荷的作用" class="headerlink" title="$\S 8.5$ 磁场对载流导线和运动电荷的作用"></a>$\S 8.5$ 磁场对载流导线和运动电荷的作用</h3><ul>
<li><p>安培力</p>
<p>  磁场中导线受到力的作用 $dF = Id\vec l \times \vec B$</p>
</li>
<li><p>磁场对直导线</p>
<p>  $F = BIlsin \alpha$</p>
</li>
<li><p>磁场对线圈</p>
<p>  当磁场与线圈倾斜一个角度时，会产生力矩 $M = BISsin\phi$</p>
<p>  定义磁矩 $\vec P_m = NIS\cdot \vec n, \vec M = \vec P_m \times \vec B$</p>
<p>  磁矩方向和磁场方向对线圈具体影响如下</p>
<p>  <img src="磁场方向对线圈的影响.png" alt="磁场方向对线圈的影响"></p>
</li>
<li><p>洛伦兹力</p>
<p>  $\vec F_m = q\vec v\times \vec B$ 同样符合右手螺旋定则，注意 $q$ 的方向是以电流方向而定</p>
</li>
<li><p>霍尔效应</p>
<p>  霍尔电势差 $U_H = R_H\frac{IB}{b}$，$R_H$ 称为霍尔系数，平衡后电子受到洛伦兹力和电场力平衡<br>  $R_H$ 为正，空穴载流子，$p$ 型半导体；$R_H$ 为负，导体或 $n$ 型半导体</p>
<p>   <img src="霍尔效应-半导体类型.png" alt="霍尔效应-半导体类型"></p>
</li>
</ul>
<h3 id="S-8-6-磁介质-磁化过程"><a href="#S-8-6-磁介质-磁化过程" class="headerlink" title="$\S 8.6$ 磁介质 磁化过程"></a>$\S 8.6$ 磁介质 磁化过程</h3><ul>
<li><p>磁介质</p>
<p>  $\vec B = \vec B_0 + \vec B’$ 右式两项同向时，是顺磁质（磁化后使空间磁场变强），反之为抗磁质（磁化后使空间磁场变弱），若未顺磁质且 $\vec B’ &gt;&gt; \vec B_0$ 称为铁磁质</p>
</li>
<li><p>分子磁矩</p>
<p>  物质分子中，每个电子参与两种运动——绕核的轨道运动（轨道磁矩）和自身旋转运动（自旋磁矩）</p>
<p>  两种磁矩矢量和是分子磁矩，可以用一个圆电流表示，称为分子电流</p>
</li>
<li><p>磁化强度</p>
<p>  $\vec M = \frac{\sum \vec P_m}{\Delta V}$ 单位体积内分子磁矩矢量和</p>
</li>
<li><p>磁场强度</p>
<p>  磁介质存在时，介质中磁感应强度 $\vec B = \vec B_0 + \mu_0 \vec M$</p>
<p>  引入磁场强度 $\vec H = \frac{\vec B}{\mu_0} - \vec M$</p>
<p>  研究表明对于各向同性非铁磁介质，磁化强度和磁场强度满足 $\vec M = \chi_m \vec H$，$\chi_m$ 称为介质的磁化率</p>
<p>  则有 $\vec B = \mu_0(1 + \chi_m)\vec H = \mu_0\mu_r \vec H = \mu \vec H$，其中 $\mu_r = 1 + \chi_m$ $\mu, \mu_r$ 分别被称为磁导率和相对磁导率，$\vec H = \frac{\vec B}{\mu}$</p>
<p>  <img src="磁介质数值.png" alt="磁介质数值"></p>
</li>
<li><p>铁磁质</p>
<p>  磁导率大，磁饱和现象，磁滞回线</p>
</li>
</ul>
<h3 id="S-8-7-安培环路定理"><a href="#S-8-7-安培环路定理" class="headerlink" title="$\S 8.7$ 安培环路定理"></a>$\S 8.7$ 安培环路定理</h3><ul>
<li>安培环路定理</li>
</ul>
<p>​        $\oint \vec B \cdot d\vec l = \mu_0 \sum I_内$ 或 $\oint \vec H \cdot d\vec l = \sum I_内$ 电流方向有正有负，和 $B$ 成右手螺旋关系则为正，反之为负 </p>
<p>​        积分回路是 $N$ 圈时，$\oint \vec H \cdot d\vec l = N\sum I_内$</p>
<p>​        无限长线圈场内 $B = \mu_0 n I$ </p>
<p>​        无限大平面（线密度 $I$） $B = \frac{\mu_0 I}{2}$</p>
<h2 id="第九章-电磁感应与麦克斯韦方程组"><a href="#第九章-电磁感应与麦克斯韦方程组" class="headerlink" title="第九章 电磁感应与麦克斯韦方程组"></a>第九章 电磁感应与麦克斯韦方程组</h2><h3 id="S-9-1-电磁感应的基本规律"><a href="#S-9-1-电磁感应的基本规律" class="headerlink" title="$\S 9.1$ 电磁感应的基本规律"></a>$\S 9.1$ 电磁感应的基本规律</h3><ul>
<li><p>法拉第电磁感应定律</p>
<p>  $\varepsilon = -N\frac{d\phi}{dt} \rightarrow q = \frac{\phi_1 - \phi_2}{R}$</p>
</li>
<li><p>楞次定律</p>
<p>  感应电流总是反抗磁场引起的变化</p>
</li>
</ul>
<h3 id="S-9-2-动生电动势与感生电动势"><a href="#S-9-2-动生电动势与感生电动势" class="headerlink" title="$\S 9.2$ 动生电动势与感生电动势"></a>$\S 9.2$ 动生电动势与感生电动势</h3><ul>
<li><p>动手电动势</p>
<p>  $\varepsilon = Bvl$，方向：右手法 / 楞次定律 </p>
</li>
<li><p>感生电动势</p>
<p>  $\varepsilon = -\frac{d\phi_m}{dt} = \frac{\partial\vec B}{\partial t}\cdot dS$</p>
</li>
<li><p>涡流与趋肤效应</p>
</li>
</ul>
<h3 id="S-9-3-自感与互感"><a href="#S-9-3-自感与互感" class="headerlink" title="$\S 9.3$ 自感与互感"></a>$\S 9.3$ 自感与互感</h3><ul>
<li><p>自感</p>
<p>  $N\phi_m = LI  \rightarrow L = N\frac{\phi}{I} \rightarrow \varepsilon = -N\frac{d\phi_m}{dt} = -NL\frac{dI}{dt}$</p>
</li>
<li><p>互感</p>
<p>  $\varepsilon_1 = -M\frac{dI_2}{dt},\varepsilon_2 = -M\frac{dI_1}{dt}$ ，$M$ 只与线圈各属性和磁介质情况有关 </p>
</li>
</ul>
<h3 id="S-9-4-磁场的能量"><a href="#S-9-4-磁场的能量" class="headerlink" title="$\S 9.4$ 磁场的能量"></a>$\S 9.4$ 磁场的能量</h3><p>磁场能量密度 $w_m = \frac{B^2}{2\mu} = \frac{1}{2}\mu H^2 = \frac{1}{2}BH \rightarrow W_m = \int w_mdV$</p>
<h3 id="S-9-5-位移电流"><a href="#S-9-5-位移电流" class="headerlink" title="$\S 9.5$ 位移电流"></a>$\S 9.5$ 位移电流</h3><ul>
<li><p>位移电流</p>
<p>  由于变化的磁场也可以产生电流，故麦克斯韦提出可以假设变化的磁场之间（如两个电极板之间）也看作是有电流存在，这个电流被称为位移电流，$I_d = \frac{d\phi}{dt}$ 位移电流密度 $\vec J_d = \frac{d\vec D}{dt}$</p>
<p>  位移电流的实质其实就是变化的电场，只要有变化的电场，或有磁场使电场变化，则有位移电流</p>
<p>  值得一提的是，两种电流在产生磁场方面是等效的，但是位移电流不产生焦耳热</p>
</li>
<li><p>全电流</p>
<p>  $I_全 = I + I_d$ </p>
<p>  安培环路定理完善为 $\oint \vec H\cdot d\vec l = \sum I_全 = \sum I + \sum I_d$</p>
</li>
</ul>
<h3 id="S-9-6-麦克斯韦方程组"><a href="#S-9-6-麦克斯韦方程组" class="headerlink" title="$\S 9.6$ 麦克斯韦方程组"></a>$\S 9.6$ 麦克斯韦方程组</h3><p><img src="麦克斯韦方程组.png" alt="麦克斯韦方程组"></p>
]]></content>
      <tags>
        <tag>大学笔记</tag>
        <tag>物理</tag>
      </tags>
  </entry>
  <entry>
    <title>大学笔记 | 大学物理BII</title>
    <url>/2023/08/30/Physics-II/</url>
    <content><![CDATA[<p>大物笔记彻底变成 PPT clipboard 力（悲</p>
<span id="more"></span>
<h2 id="第十章-振动"><a href="#第十章-振动" class="headerlink" title="第十章 振动"></a>第十章 振动</h2><h3 id="第十章总结（待完成）"><a href="#第十章总结（待完成）" class="headerlink" title="第十章总结（待完成）"></a>第十章总结（待完成）</h3><h3 id="S-10-1-简谐运动"><a href="#S-10-1-简谐运动" class="headerlink" title="$\S 10.1$ 简谐运动"></a>$\S 10.1$ 简谐运动</h3><ol>
<li>简谐振动方程</li>
</ol>
<p>​    最简单的简谐运动，以弹簧振子来举例，其受力满足，</p>
<script type="math/tex; mode=display">
F = -kx \\
F = ma = m \dfrac{d^2x}{dt^2}</script><p>​    然后引入$\omega^2 =\dfrac{k}{m}$，这里 $\omega$ 只与系统自身性质有关，也称为角频率。<br>​    化简得 $\dfrac{d^2x}{dt^2} + \omega^2 x = 0$，这是简谐运动的微分方程，求解可得</p>
<script type="math/tex; mode=display">
x = A \cos (\omega t +\phi)</script><p>​    便得到了简谐运动的运动方程，<strong>这十分重要</strong>，求一阶导可得速度方程，求二阶导可得加速度方程。</p>
<blockquote>
<p> 通常化作余弦形式。</p>
</blockquote>
<ol>
<li>简谐振动的特征量</li>
</ol>
<p>​    速度 $v = \omega Acos(\omega t + \phi + \dfrac{\pi}{2})$，$\omega A= v_m$ 表示速度振幅。</p>
<p>​    加速度 $a = \omega^2 A cos(\omega t + \phi)$，$\omega^2A = a_m$ 表示加速度振幅。</p>
<p>​    周期满足 $T\omega = 2\pi$。</p>
<p>​    振幅 $A = \sqrt{x_0^2 + \dfrac{v_0^2}{\omega^2}}$，相位角 $tan \phi = -\dfrac{v_0}{\omega x_0}$。</p>
<ol>
<li>简谐运动能量</li>
</ol>
<script type="math/tex; mode=display">
E = E_p + E_k \\
Ep = \dfrac{1}{2}kx^2, \ E_k = \dfrac{1}{2}mv^2
\\代入得 \ E = \dfrac{1}{2}kA^2</script><ol>
<li>旋转矢量<br>矢量绕 $O$ 点按逆时针旋转，$t$ 时刻，点在 $x$ 轴上的位置为 $A\cos(\omega t + \phi)$。<br>速度与 $x$ 轴上的夹角为 $\omega t + \phi + \dfrac{\pi}{2}$，$v_x = \omega A\cos(\omega t + \phi + \dfrac{\pi}{2}) = -\omega A\sin(\omega t + \phi)$。<br>加速度 $a_x = \omega^2 A \cos(\omega t + \phi + \pi) = -\omega^2 x$。</li>
</ol>
<h3 id="S-10-3-简谐运动的合成"><a href="#S-10-3-简谐运动的合成" class="headerlink" title="$\S 10.3$ 简谐运动的合成"></a>$\S 10.3$ 简谐运动的合成</h3><ol>
<li>同方向，同频率简谐运动的合成</li>
</ol>
<p><img src="10.3-1.jpg" alt="10.3-1"></p>
<ol>
<li>振动方向垂直，同频率简谐运动的合成</li>
</ol>
<p><img src="10.3-2.jpg" alt="10.3-2"></p>
<ul>
<li><p>当 $\phi_2 - \phi_1 = k\pi$ 时，质点做直线运动。</p>
</li>
<li><p>当 $\phi_2 - \phi_1 = (2k \pm1)\dfrac{\pi}{2}$ 时，质点运动轨迹是圆。</p>
</li>
<li>当 $\phi_2 - \phi_1$ 为其他值时，质点运动轨迹是椭圆。</li>
</ul>
<h3 id="S-10-5-阻尼振动-受迫振动-共振"><a href="#S-10-5-阻尼振动-受迫振动-共振" class="headerlink" title="$\S 10.5$ 阻尼振动 受迫振动 共振"></a>$\S 10.5$ 阻尼振动 受迫振动 共振</h3><ol>
<li><p>阻尼振动<br> 振幅随时间减小的振动叫阻尼振动。<br> 阻尼模型有摩擦阻尼和辐射阻尼。<br> 对于低速运动的物体，引入阻力 $F = -\gamma v $。</p>
<p>对于高速运动的物体，引入阻力 $F = -\gamma v^2 $（用的较少）。</p>
<p>以弹簧振子为例，我们可以列出方程</p>
<script type="math/tex; mode=display">
\begin{gather}
m\dfrac{d^2x}{dt^2} = -kx - \gamma v \\
\omega_0^2 = \dfrac{k}{m}\ \ \ 2\beta = \dfrac{\gamma}{m}\\
\Rightarrow \dfrac{d^2x}{dt^2} + 2\beta\dfrac{dx}{dt} + \omega_0^2x = 0\\
\Rightarrow x = c_1e^{-(\beta - \sqrt{\beta^2 - \omega_0^2})t} + c_2e^{-(\beta + \sqrt{\beta^2  -\omega_0^2})t}
\end{gather}</script><p>​    当 $\beta$ 和 $\omega_0$ 大小关系不同时，所对应的结果也不同。</p>
</li>
</ol>
<p><img src="10.3-3.jpg" alt="10.3-3"></p>
<p>​    临界阻尼到达平衡点最快，过阻尼和临界阻尼不能往返运动。</p>
<ol>
<li>受迫振动<br>物体在周期性外力下持续发生振动称为受迫振动，这个外力称为驱动力（要考虑弹性力，阻尼力和驱动力）。</li>
</ol>
<p>​        这块貌似了解即可，在此贴出 ppt。</p>
<p>​    <img src="10.3-4.png" alt="10.3-4"></p>
<p><img src="10.3-5.png" alt="10.3-5"></p>
<p><img src="10.3-6.png" alt="10.3-6"></p>
<p><img src="10.3-7.png" alt="10.3-7"></p>
<ol>
<li>共振<br>当外界驱动力频率接近或等于系统固有频率时，受迫振动振幅达到最大值的现象称为<strong>共振</strong>，其频率为<strong>共振频率</strong>。</li>
</ol>
<p><img src="10.3-8.png" alt="10.3-8"></p>
<p><img src="10.3-9.png" alt="10.3-9"></p>
<h3 id="习题课（待完成）"><a href="#习题课（待完成）" class="headerlink" title="习题课（待完成）"></a>习题课（待完成）</h3><h2 id="第十一章-机械波"><a href="#第十一章-机械波" class="headerlink" title="第十一章 机械波"></a>第十一章 机械波</h2><h3 id="第十一章总结（待完成）"><a href="#第十一章总结（待完成）" class="headerlink" title="第十一章总结（待完成）"></a>第十一章总结（待完成）</h3><h3 id="S-11-1-波动的基本概念"><a href="#S-11-1-波动的基本概念" class="headerlink" title="$\S 11.1$ 波动的基本概念"></a>$\S 11.1$ 波动的基本概念</h3><ol>
<li>机械波的产生和传播<ul>
<li>波源：激发波动的振动系统。</li>
<li>弹性介质：能够传播机械振动的弹性介质。</li>
<li><strong>振动是质点的个体行为，波动是质点振动的群体行为。</strong>波动是振动相位的传递，注意每个质点依然是在垂直方向上移动，并未左右移动。</li>
<li><strong>横波</strong>：振动方向与波的传播方向垂直，如绳波。<strong>纵波</strong>：振动方向与波的传播方向平行，是靠介质疏密变化传播的，如声波，弹簧波。纵波可以在固液气中传播，而横波一般只在固体中传播。</li>
</ul>
</li>
<li>波的几何描述<ul>
<li>波线：表示波的传播方向的射线。</li>
<li>波面：相位相同的点组成的面。</li>
<li>波前：某一时刻，最前面的波面。</li>
<li>平面波：波面是平面的波。球面波：波面是球面的波。</li>
</ul>
</li>
<li>描述波的物理量<ul>
<li>波长：振动在一个周期内传播的距离为波长 $\lambda$，反映波在空间上的周期性。</li>
<li>周期和频率：周期 $T$，频率 $\nu$。反映波在时间上的周期。</li>
<li>波速：用 $u$ 表示。$\lambda = uT$，$u = \lambda \nu$。</li>
<li>周期由波源决定，波速由介质决定。</li>
<li>不同频率的同一类型波在同一介质波速相同。</li>
<li>波在不同介质中频率不变。</li>
</ul>
</li>
</ol>
<h3 id="S-11-2-平面简谐波-波函数"><a href="#S-11-2-平面简谐波-波函数" class="headerlink" title="$\S 11.2$ 平面简谐波 波函数"></a>$\S 11.2$ 平面简谐波 波函数</h3><ul>
<li>平面简谐波：波面是平面，各质点做简谐运动的波。</li>
<li>波函数：描述任意时刻任意位置处质点的<strong>振动位移</strong>。这里往往用某一质点的振动方程代替任意质点的振动方程。</li>
</ul>
<ol>
<li><p>平面简谐波的波函数</p>
<ul>
<li><p>波函数未特地说明时，默认在原点处。</p>
</li>
<li><p>波形以波速沿波线平移的波称为行波。</p>
</li>
<li><p>$y = A\cos [\omega(t - \dfrac{x}{u}) + \phi]$，把对应的时间 $t_0$，$x_0$ 代入公式即可算出某时刻某位置的振动位置。</p>
</li>
<li><p>此类常考题型如下：</p>
<p><img src="11.2-3.png" alt="11-2.3"></p>
</li>
</ul>
</li>
<li><p>波动方程（考试不考）</p>
</li>
</ol>
<p><img src="11.2-1.png" alt="11-2.1"></p>
<p><img src="11.2-2.png" alt="11.2-2"></p>
<h3 id="S-11-3-波的能量-能流密度"><a href="#S-11-3-波的能量-能流密度" class="headerlink" title="$\S 11.3$ 波的能量 能流密度"></a>$\S 11.3$ 波的能量 能流密度</h3><ol>
<li><p>波的能量</p>
<ul>
<li><p>波具有动能和势能</p>
<p>对于质元而言</p>
</li>
<li><p>动能 $dE_k = \dfrac{1}{2}(dm)v^2 = \dfrac{1}{2}(\rho dV)A^2\omega^2\sin^2\omega(t - \dfrac{x}{u})$</p>
</li>
<li><p>势能 $dE_P = \dfrac{1}{2}(\rho dV)A^2\omega^2\sin^2\omega(t - \dfrac{x}{u})$（貌似上课也没讲怎么推导的，记住就行吧？.jpg）</p>
<blockquote>
<p>注意质元在平衡位置处，动能，势能和总机械能均最大，质元位移最大时，三者均为 $0$。</p>
</blockquote>
</li>
</ul>
</li>
</ol>
<p>​        $dE = dE_p + dE_k = (\rho dV)A^2\omega^2\sin^2\omega(t - \dfrac{x}{u})$</p>
<p>​        能量密度 $w = \dfrac{dE}{dV} = \rho A^2\omega^2\sin^2\omega(t - \dfrac{x}u{})$</p>
<p>​        平均能量密度 $\bar w = \dfrac{1}{T}\int_0^T wdt = \dfrac{1}{2}\rho A^2\omega^2$</p>
<p>​        不难发现每时每刻，动能和势能总是相同的，质元不与外界能量交换，总能量总是守恒的。</p>
<p>​        对于所有弹性波，平均能量密度和振幅平方，频率平方，介质密度成正比。</p>
<ol>
<li>波的能流 平均能流密度</li>
</ol>
<p>​        单位时间内通过垂直于波传播方向的某面积上能量称为能流，方向与速度相同。$P = \dfrac{dE}{dt}$。</p>
<p><img src="11.3-1.png" alt="11.3-1"></p>
<p>​        平均能流 $\bar P = \bar wuS = \dfrac{1}{2}\rho A^2\omega^2uS$</p>
<p>​        平均能流密度：单位面积上的能流。</p>
<p>​        $I = \dfrac{\bar P}{S} = \dfrac{1}{2}\rho A^2\omega^2u$</p>
<p>​        矢量式 $\vec I = \dfrac{1}{2}\rho A^2\omega^2\vec u$</p>
<p>​        能流密度 $I$ 也被称为波的强度。</p>
<p>​        平面简谐波 $E = IS$。</p>
<p>​        球面简谐波 $E = 4\pi r^2I$。</p>
<p>​        设单位半径上的球面振幅是 $a$，半径为 $r$ 的球面上振幅为 $A$，由球心处放出的总能量相等，可以得出 $A(r) = \dfrac{a}{r}$，若球心处 $y_o(t) \propto \cos(\omega t + \phi)$，则 $y_球 = \dfrac{a}{r}\cos(\omega(t - \dfrac{r}{u}) + \phi)$。</p>
<ol>
<li>声强 声强级<ul>
<li>声振动：能够引起人们听觉效应的机械振动。</li>
<li>声波：在弹性介质中由声振动激发的波叫声波。</li>
<li>声波范围：20 ~ 20000 Hz 超声波：&gt; 20000 Hz 次声波：&lt; 20 Hz</li>
<li>声强：声波的平均能流密度叫声强。$I = \dfrac{1}{2}\rho A^2\omega^2u$，单位：$W / m^2$。</li>
<li>声强级：$I_1 = 10lg\dfrac{I}{I_0}$，单位：$dB$（分贝）。</li>
</ul>
</li>
</ol>
<h3 id="S-11-4-惠更斯原理"><a href="#S-11-4-惠更斯原理" class="headerlink" title="$\S 11.4$ 惠更斯原理"></a>$\S 11.4$ 惠更斯原理</h3><ul>
<li><p>惠更斯原理：波在传播过程中，波面上每一点可以看作是发射子波的波源，这些子波源相当于继承原先波的能量，然后再传递给之后的波，后继的包迹决定新的波阵面。</p>
</li>
<li><p>波的衍射：波在传播过程中能够绕过障碍物而偏离直线传播的现象。衍射是波的基本特征之一，其强弱由障碍物尺寸和波长的关系决定。惠更斯原理只能定性解释波的衍射现象。</p>
</li>
</ul>
<h3 id="S-11-5-波的叠加原理-波的干涉"><a href="#S-11-5-波的叠加原理-波的干涉" class="headerlink" title="$\S 11.5$ 波的叠加原理 波的干涉"></a>$\S 11.5$ 波的叠加原理 波的干涉</h3><ol>
<li>波的叠加原理：<ul>
<li>独立传播原理：波相遇后依然按照各自原来的特性，互不干涉。</li>
<li>叠加原理：某点的振动为引起该点振动波的矢量和。</li>
</ul>
</li>
<li>波的干涉（这段 ppt 比较完整，直接放 ppt 力）</li>
</ol>
<p><img src="11.5-1.png" alt="11.5-1"></p>
<p><img src="11.5-2.png" alt="11.5-2"></p>
<blockquote>
<p>值得一提的是，这里波的干涉和前面第十章第三节的简谐振动的合成是十分类似的。</p>
</blockquote>
<p><img src="11.5-3.png" alt="11.5-3"></p>
<p><img src="11.5-4.png" alt="11.5-4"></p>
<p>​    练习在精不在多，这里贴一道给出两种方法的练习题，分别用到本节知识和前面波函数的知识。</p>
<p><img src="11.5-5.png" alt="11.5-5"></p>
<p><img src="11.5-6.png" alt="11.5-6"></p>
<p><img src="11.5-7.png" alt="11.5-7"></p>
<h3 id="S-11-6-驻波"><a href="#S-11-6-驻波" class="headerlink" title="$\S 11.6$ 驻波"></a>$\S 11.6$ 驻波</h3><ul>
<li>驻波：沿相反方向传播的振幅相同的两列相干波相遇叠加会形成一种波形不向前传播的波。</li>
</ul>
<p><img src="11.6-1.png" alt="11.6-1"></p>
<p><img src="11.6-2.png" alt="11.6-2"></p>
<p><img src="11.6-3.png" alt="11.6-3"></p>
<p><img src="11.6-4.png" alt="11.6-4"></p>
<blockquote>
<p>值得一提的是，能量在驻波中的分布是不均匀的，振动的能量在波节处分布相对更为集中。</p>
</blockquote>
<ul>
<li><p>半波损失</p>
<p>  从一个介质到另一个介质，一部分反射形成的波叫反射波，一部分透射形成的波叫透射波。</p>
<p>  透射波没有相位的损失，总是与入射波同相，但反射波，从光疏到光密会有相位 $\pi$ 的突变，$\phi’ = \phi - \pi$。</p>
</li>
<li><p>弦线上的驻波</p>
<p>  驻波就是行波在弦线上前进过程中受到了阻挡，产生了反射，然后反射波和入射波叠加导致的。</p>
</li>
</ul>
<p><img src="11.6-5.png" alt="11.6-5"></p>
<p>前面的那道算两振源干涉的题目，也可以当作驻波来算：</p>
<p><img src="11.6-6.png" alt="11.6-6"></p>
<p><img src="11.6-7.png" alt="11.6-7"></p>
<h3 id="S-11-7-多普勒效应"><a href="#S-11-7-多普勒效应" class="headerlink" title="$\S 11.7$ 多普勒效应"></a>$\S 11.7$ 多普勒效应</h3><p><img src="11.7-1.png" alt="11.7-1"></p>
<p><img src="11.7-2.png" alt="11.7-2"></p>
<p><img src="11.7-3.png" alt="11.7-3"></p>
<p><img src="11.7-4.png" alt="11.7-4"></p>
<p><img src="11.7-5.png" alt="11.7-5"></p>
<h3 id="习题课（待完成）-1"><a href="#习题课（待完成）-1" class="headerlink" title="习题课（待完成）"></a>习题课（待完成）</h3><h2 id="第十二章-电磁波"><a href="#第十二章-电磁波" class="headerlink" title="第十二章 电磁波"></a>第十二章 电磁波</h2><blockquote>
<p>前置知识回顾：</p>
<ul>
<li><p>麦克斯韦方程组（部分）：</p>
<p>  $\oint E \cdot dl = -\dfrac{d\Phi_m}{dt}$（法拉第电磁感应定律）</p>
<p>  $\oint H \cdot dl = -\dfrac{d\Phi_e}{dt}$（安培定律）</p>
<p>  其中 $\Phi_m$ 是磁感应强度 $B$ 的通量，$\Phi_e$ 是电位移 $D$ 的通量。</p>
</li>
<li><p>$D = \varepsilon_0 E$ ，其中 $D$ 是电位移矢量，$E$ 是电场强度，$\varepsilon_0$ 是真空介电常数。</p>
</li>
<li><p>$H = \dfrac{B}{\mu_0}$ ，其中 $H$ 是磁场强度，$B$ 是磁感应强度，$\mu_0$ 是磁导率。</p>
</li>
</ul>
</blockquote>
<h3 id="第十二章总结（待完成）"><a href="#第十二章总结（待完成）" class="headerlink" title="第十二章总结（待完成）"></a>第十二章总结（待完成）</h3><h3 id="S-12-1-电磁波"><a href="#S-12-1-电磁波" class="headerlink" title="$\S 12.1$ 电磁波"></a>$\S 12.1$ 电磁波</h3><ul>
<li>变化磁场产生涡旋电场，变化电场产生涡旋磁场。电磁振源产生交变电磁场，交变电场和交变磁场相互激发，形成电磁波。</li>
<li>下面的推导了解即可</li>
</ul>
<p><img src="12.1-1.png" alt="12.1-1"></p>
<p><img src="12.1-2.png" alt="12.1-2"></p>
<p><img src="12.1-3.png" alt="12.1-3"></p>
<p><img src="12.1-4.png" alt="12.1-4"></p>
<ul>
<li>求解平面电磁波的微分方程，解为 $E_x = E_0\cos\omega(t - \dfrac{z}{u}),H_y = H_0\cos\omega(t - \dfrac{z}{u})$。</li>
</ul>
<p><img src="12.1-5.png" alt="12.1-5"></p>
<ul>
<li><p>电磁波的能量传播</p>
<p>  以电磁波形式传播出去的电磁能量称为辐射能。</p>
<p>  能量密度 $w = w_e + w_m = \dfrac{1}{2}\varepsilon E^2 + \dfrac{1}{2}\mu H^2 = \varepsilon E^2 = \mu H^2$ 。</p>
<p>  单位时间通过垂直于传播方向的单位面积的电磁能称为能流密度，$S = wu$（其中 $w$ 是能量密度）。</p>
<p>  将 $w = \dfrac{1}{2}\varepsilon E^2 + \dfrac{1}{2}\mu H^2$ 和 $u = \dfrac{1}{\sqrt{\varepsilon \mu}}$ 代入公式，得 $S = EH$。矢量形式 $\vec S = \vec E \times \vec H$。$\vec S$ 称为 Poynting vector。</p>
<p>  将 $S$ 对时间取平均值，$I = \bar S = \bar E \bar H$。$I$ 称为电磁波的强度。</p>
<p>  对于平面电磁波：$I = \dfrac{1}{T}\int_0^TE_0H_0\cos^2\omega(t - \dfrac{z}{u})dt = \dfrac{1}{2}E_0H_0$。</p>
</li>
</ul>
<h3 id="S-12-2-电偶极子辐射电磁波"><a href="#S-12-2-电偶极子辐射电磁波" class="headerlink" title="$\S 12.2$ 电偶极子辐射电磁波"></a>$\S 12.2$ 电偶极子辐射电磁波</h3><ul>
<li><p>任何 LC 振荡电路都可以作为发射电磁波的振源，要想有效把电路中的电磁发射出去，除了补充能量外，还需要：1. 足够高的频率。2. 必须有开放的电路。</p>
</li>
<li><p>电偶极子辐射电磁波</p>
<p>  <img src="12.2-1.png" alt="12.2-1"></p>
</li>
</ul>
<p><img src="12.2-2.png" alt="12.2-2"></p>
<p><img src="12.2-3.png" alt="12.2-3"></p>
<h3 id="S-12-3-电磁波谱"><a href="#S-12-3-电磁波谱" class="headerlink" title="$\S 12.3$ 电磁波谱"></a>$\S 12.3$ 电磁波谱</h3><blockquote>
<p> 内容不重要，稍作了解即可（略）。</p>
</blockquote>
<h3 id="习题课（待完成）-2"><a href="#习题课（待完成）-2" class="headerlink" title="习题课（待完成）"></a>习题课（待完成）</h3><h2 id="第十三章-几何光学成像原理"><a href="#第十三章-几何光学成像原理" class="headerlink" title="第十三章 几何光学成像原理"></a>第十三章 几何光学成像原理</h2><h3 id="第十三章总结"><a href="#第十三章总结" class="headerlink" title="第十三章总结"></a>第十三章总结</h3><ul>
<li><p>光程 $L = ns$  光在某一介质中的光程对应在真空中走相同时间的位移。</p>
</li>
<li><p>折射定律 $n’ \sin I’ = n\sin I$。光密到光疏可能发生全反射。</p>
</li>
<li><p>$n_{21} = \dfrac{v_1}{v_2} = \dfrac{n_2}{n_1}$ 称为介质 $2$ 相对于介质 $1$ 的相对折射率，若介质 $1$ 是真空则是绝对折射率。</p>
</li>
<li><p><strong>一定要清楚符号规则。</strong></p>
</li>
<li><p>高斯光学满足 $u \approx \sin u$。</p>
</li>
<li><p>$\dfrac{n’}{l’} - \dfrac{n}{l} = \dfrac{n’ - n}{r}$ 是本章最重要的公式，后续公式都是它的变形。</p>
<blockquote>
<p>球面反射镜成像就是 $n’ = -n$ 的情况。</p>
</blockquote>
</li>
<li><p>凸透镜 $r &gt; 0$，凹面镜 $r &lt; 0$。透镜左边的距离都是负的，右边距离都是正的。光轴向上是正的，光轴向下是负的。代入公式时一定要注意。</p>
</li>
<li><p>薄透镜成像 </p>
<p>像方焦距 $f’ = \dfrac{n_2’}{\dfrac{n_2’ - n}{r_2} + \dfrac{n - n_1}{r_1}}$</p>
<p>物方焦距 $f = \dfrac{-n_1}{\dfrac{n_2’ - n}{r_2} + \dfrac{n - n_1}{r_1}}$</p>
<p>物像关系满足 $\dfrac{f’}{l’} + \dfrac{f}{l} = 1$，不过大多数都是在空气中传播，故有 $\dfrac{1}{l’} - \dfrac{1}{l} = \dfrac{1}{f’}$</p>
</li>
</ul>
<h3 id="S-13-1-光线及其传播的基本定律"><a href="#S-13-1-光线及其传播的基本定律" class="headerlink" title="$\S 13.1$ 光线及其传播的基本定律"></a>$\S 13.1$ 光线及其传播的基本定律</h3><ul>
<li><p>光程与光程方程</p>
<p>  $L = ns$ 光程等于路线距离和折射率的乘积。</p>
<p>  光在某一介质中的光程对应在真空中走相同时间的位移。</p>
<p>  <strong>光程方程</strong> $(\dfrac{\partial L}{\partial x})^2 + (\dfrac{\partial L}{\partial y})^2 + (\dfrac{\partial L}{\partial z})^2 = n^2$。</p>
</li>
<li><p>光线与光波方程</p>
<p>  某一时刻，光波相位相同点构成的曲面称为波面，其法线是光线。</p>
<p>  <strong>光线方程</strong> $\dfrac{d}{ds} (n\dfrac{d \vec r}{ds}) = \nabla n$。</p>
</li>
<li><p>几何光学定律</p>
<p>  <strong>在不考虑光的波动性的情况下</strong>，光沿直线传播，且光束之间互不干扰。</p>
<p>  反射定律 $I’’ = -I$。</p>
<p>  折射定律 $n’ \sin I’ = n\sin I$。</p>
<blockquote>
<p>特殊的，若 $\sin I’ = \dfrac{n}{n’} \sin I \ge 1$ 是会发生全反射现象。</p>
</blockquote>
</li>
<li><p>折射率</p>
<p>  $n_{21} = \dfrac{v_1}{v_2} = \dfrac{n_2}{n_1}$ 称为介质 $2$ 相对于介质 $1$ 的相对折射率。</p>
<p>  若介质 $1$ 为真空，则 $n = \dfrac{c}{v}$ 为介质 $2$ 的绝对折射率。</p>
</li>
</ul>
<h3 id="S-13-2-成像基本概念与光路计算"><a href="#S-13-2-成像基本概念与光路计算" class="headerlink" title="$\S 13.2$ 成像基本概念与光路计算"></a>$\S 13.2$ 成像基本概念与光路计算</h3><ul>
<li><p>光学系统</p>
<p>  若干光学零件组成的系统称为<strong>光学系统</strong>，穿过表面曲率中心的公共轴线叫<strong>光轴</strong>。</p>
</li>
<li><p>物与像</p>
<p>  物是入射光线汇聚成的，像是出射光线汇聚成的。</p>
<p>  物所在一侧称为物空间，但像既可能在物空间也可能在像空间。</p>
<p>  物与像是成对出现的，而且限定在光学系统中讨论。</p>
</li>
</ul>
<p><img src="13.2-1.png" alt="13.2-1"></p>
<h3 id="S-13-3-高斯光学"><a href="#S-13-3-高斯光学" class="headerlink" title="$\S 13.3$ 高斯光学"></a>$\S 13.3$ 高斯光学</h3><ul>
<li><p>近轴光线</p>
<p>  由于入射角很小，故满足 $u \approx \sin u$，研究近轴光线物象关系的光学称为近轴光学，又称为高斯光学。</p>
</li>
<li><p>球面折射物像位置关系</p>
<p>  <img src="13.3-1.png" alt="13.3-1"></p>
<p>  通过推导以及高斯光学的特点，我们可以得到折射球面物像位置公式：</p>
<script type="math/tex; mode=display">
  \dfrac{n'}{l'} - \dfrac{n}{l} = \dfrac{n' - n}{r} \\
  n'(\dfrac{1}{r} - \dfrac{1}{l'}) = n(\dfrac{1}{r} - \dfrac{1}{l}) = Q(阿贝不变量)</script><p>  成的像称为高斯像。</p>
<ul>
<li>横向放大率</li>
</ul>
</li>
</ul>
<pre><code>![13.3-2](13.3-2.png)

​        $\beta &gt; 0$，$l$ 与 $l'$ 同号，物像位于同一侧，方向相同，虚实性质相反，正立。

​        $\beta &lt; 0$，$l$ 与 $l'$ 异号，物像位于两侧，方向相反，虚实性质相同，倒立。

- 轴向放大率

    $\alpha = \dfrac{dl'}{dl} = \dfrac{n'}{n} \beta^2$
</code></pre><p><img src="13.3-3.png" alt="13.3-3"></p>
<blockquote>
<p>通过这道例题主要是要知道怎么取值的正负。</p>
</blockquote>
<ul>
<li><p>球面反射镜近轴成像光路</p>
<p>  可以看作折射的一种特殊情况，把 $n’ = -n$ 即可。</p>
<p>  物像位置公式 $\dfrac{1}{l’} + \dfrac{1}{l} = \dfrac{2}{r}$。</p>
<ul>
<li><p>横向放大率 $\beta = \dfrac{nl’}{n’l} = -\dfrac{l’}{l}$。</p>
<p>$\beta &lt; 0$，$l$ 与 $l’$ 同号，物像位于同一侧，虚实性质相同，倒立。</p>
<p>$\beta &gt; 0$，$l$ 与 $l’$ 异号，物像位于两侧，虚实性质相反，正立。    </p>
</li>
<li><p>轴向放大率 $\alpha = -\dfrac{l’^2}{l^2} = -\beta^2$。</p>
<p><img src="13.3-6.png" alt="13.3-6"></p>
</li>
</ul>
</li>
<li><p>薄透镜近轴成像光路</p>
<p><img src="13.3-5.png" alt="13.3-5"></p>
<p>由于薄透镜有前后两个面，利用两次 $\dfrac{n’}{l’} - \dfrac{n}{l} = \dfrac{n’ - n}{r}$ 公式，可以得到 $\dfrac{n_2’}{l_2’} - \dfrac{n_1}{l_1} = \dfrac{n_2’ - n}{r_2} + \dfrac{n - n_1}{r_1}$。</p>
<blockquote>
<p>特殊的，由于 $l_1 \to \infty$ 时可以得出像方焦距 $l_2’ = f’$，带入上述公式得到 $f’ = \dfrac{n_2’}{\dfrac{n_2’ - n}{r_2} + \dfrac{n - n_1}{r_1}}$。</p>
<p>由于 $l_2 \to \infty$ 时可以得出物方焦距 $l_1 = f$，带入上述公式得到 $f = \dfrac{-n_1}{\dfrac{n_2’ - n}{r_2} + \dfrac{n - n_1}{r_1}}$。</p>
</blockquote>
<p>对于光焦度的定义是 $\Phi = \dfrac{n_2’}{f’} = \dfrac{n_2’ - n}{r_2} + \dfrac{n - n_1}{r_1}$。</p>
<p>两个焦距之间关系是 $\dfrac{f’}{f} = -\dfrac{n_2’}{n_1}$。</p>
<p>物像之间关系满足 $\dfrac{f’}{l’} + \dfrac{f}{l} = 1$。</p>
<blockquote>
<p>特殊的，当透镜出于同种介质内，有 $f + f’ = 0$，此时上述公式可以变为 $\dfrac{1}{l’} - \dfrac{1}{l} = \dfrac{1}{f’}$。</p>
</blockquote>
<ul>
<li><p>横向放大率 $\beta = \dfrac{y_2’}{y_1} = \dfrac{y_1’}{y_1} \cdot \dfrac{y_2’}{y_2} = \beta_1 \cdot \beta_2  =\dfrac{n_1l_2’}{n_2’l_1}$。</p>
<p>$\beta &gt; 0$，$l$ 与 $l’$ 同号，物像位于同一侧，方向相同，虚实性质相反，正立。</p>
<p>$\beta &lt; 0$，$l$ 与 $l’$ 异号，物像位于两侧，方向相反，虚实性质相同，倒立。</p>
</li>
<li><p>轴向放大率 $\alpha = \dfrac{n_2’}{n_1}\beta^2$。</p>
<blockquote>
<p>特殊的，空气中 $\beta = \dfrac{l’}{l}, \alpha = \beta^2$。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h3 id="习题课（待完成）-3"><a href="#习题课（待完成）-3" class="headerlink" title="习题课（待完成）"></a>习题课（待完成）</h3><h2 id="第十四章-光的干涉"><a href="#第十四章-光的干涉" class="headerlink" title="第十四章 光的干涉"></a>第十四章 光的干涉</h2><h3 id="第十四章总结（待完成）"><a href="#第十四章总结（待完成）" class="headerlink" title="第十四章总结（待完成）"></a>第十四章总结（待完成）</h3><p><img src="E:\Blog\Ana_Su\source\_posts\Physics-II\14.3-1.png" alt="14.3-1"></p>
<p><img src="E:\Blog\Ana_Su\source\_posts\Physics-II\14.3-2.png" alt="14.3-2"></p>
<p><img src="E:\Blog\Ana_Su\source\_posts\Physics-II\14.3-3.png" alt="14.3-3"></p>
<p><img src="E:\Blog\Ana_Su\source\_posts\Physics-II\14.3-4.png" alt="14.3-4"></p>
<p><img src="E:\Blog\Ana_Su\source\_posts\Physics-II\14.3-5.png" alt="14.3-5"></p>
<p><img src="E:\Blog\Ana_Su\source\_posts\Physics-II\14.3-6.png" alt="14.3-6"></p>
<h3 id="S-14-1-光的相干性"><a href="#S-14-1-光的相干性" class="headerlink" title="$\S 14.1$ 光的相干性"></a>$\S 14.1$ 光的相干性</h3><ul>
<li><p>光的干涉，想干条件</p>
<p>光是电磁波，感光主要是靠电磁波，所以将电场强度 $\vec E$ 称为光矢量。</p>
<p>光波相遇可以看作是若干振动的叠加，振动的加强是亮条纹，减弱是暗条纹，这种现象称为光的干涉。</p>
<p><strong>相干条件</strong></p>
<ol>
<li>只有平行振动分量间才能发生干涉。</li>
<li>频率相同的光波之间才能发生干涉。</li>
<li>相位差恒定的光波才能发生干涉。</li>
</ol>
<p><img src="14.1-1.png" alt="14.1-1"></p>
<blockquote>
<p>光强 I 在这里表示某种平方。</p>
</blockquote>
</li>
<li><p>光程差</p>
<p>在不同介质中，$\delta = n_2r_2 - n_1r_1$ 称为光程差，$\Delta \varphi = \dfrac{2 \pi}{\lambda} \delta$ 是相位差。</p>
<p><img src="14.1-2.png" alt="14.1-2"></p>
</li>
<li><p>获得相干光的方法</p>
<p>主要分为以下两类</p>
<p><img src="14.1-3.png" alt="14.1-3"></p>
<blockquote>
<p>注：振幅相差不能太大。并且光程差也不能太大。</p>
</blockquote>
</li>
</ul>
<h3 id="S-14-2-分波阵面干涉"><a href="#S-14-2-分波阵面干涉" class="headerlink" title="$\S 14.2$ 分波阵面干涉"></a>$\S 14.2$ 分波阵面干涉</h3><ul>
<li><p>杨氏双缝干涉</p>
<p><img src="14.2-1.png" alt="14.2-1"></p>
<p><img src="14.2-2.png" alt="14.2-2"></p>
<p>条纹明暗相间且条纹等间距（单色光情况），对称分布在中央明纹两边。满足 $\Delta x = \dfrac{D}{a}\lambda$。（指的是相邻明纹与明纹 / 暗纹与暗纹的间距）</p>
<blockquote>
<p>若将整个装置放在折射率为 $n$ 的介质中，$\Delta x = \dfrac{D}{na}\lambda$。</p>
</blockquote>
<p>对于白色光，条纹是彩色条纹。</p>
</li>
<li><p>劳埃德镜实验</p>
<blockquote>
<p>验证了半波损失。</p>
</blockquote>
</li>
<li><p>空间相干性和时间相干性</p>
<blockquote>
<p>光的相干性质会和时间，空间相关。空间会影响光程差，而时间太长会直接导致无法相干。</p>
</blockquote>
<p><strong>空间相干性</strong></p>
<blockquote>
<p>由于实际中光源的光是由宽度的，所以要考虑空间相干性对光的干涉产生的影响。</p>
</blockquote>
<p><img src="14.2-5.png" alt="14.2-5"></p>
<p><img src="14.2-6.png" alt="14.2-6"></p>
<p><strong>时间相干性</strong></p>
<p><img src="14.2-4.png" alt="14.2-4"></p>
</li>
<li><p>例题</p>
<p><img src="14.2-3.png" alt="14.2-3"></p>
</li>
</ul>
<h3 id="S-14-3-分振幅干涉"><a href="#S-14-3-分振幅干涉" class="headerlink" title="$\S 14.3$ 分振幅干涉"></a>$\S 14.3$ 分振幅干涉</h3><blockquote>
<p>本节中提到了半波损失，半波损失条件：</p>
<ol>
<li>反射。</li>
<li>从光疏介质到光密介质的反射。</li>
</ol>
</blockquote>
<ul>
<li><p>薄膜干涉</p>
<p><img src="E:\Blog\Ana_Su\source\_posts\Physics-II\14.2-7.png" alt="14.2-7"></p>
<p><img src="E:\Blog\Ana_Su\source\_posts\Physics-II\14.2-8.png" alt="14.2-8"></p>
<p><img src="E:\Blog\Ana_Su\source\_posts\Physics-II\14.2-9.png" alt="14.2-9"></p>
<p><img src="E:\Blog\Ana_Su\source\_posts\Physics-II\14.2-10.png" alt="14.2-10"></p>
<p><img src="E:\Blog\Ana_Su\source\_posts\Physics-II\14.2-11.png" alt="14.2-11"></p>
<p><img src="E:\Blog\Ana_Su\source\_posts\Physics-II\14.2-12.png" alt="14.2-12"></p>
</li>
<li><p>劈尖干涉</p>
<blockquote>
<p>劈尖干涉要求两个劈尖平面夹角很小。</p>
</blockquote>
<p><img src="E:\Blog\Ana_Su\source\_posts\Physics-II\14.2-13.png" alt="14.2-13"></p>
<p><img src="E:\Blog\Ana_Su\source\_posts\Physics-II\14.2-14.png" alt="14.2-14"></p>
<p><img src="E:\Blog\Ana_Su\source\_posts\Physics-II\14.2-15.png" alt="14.2-15"></p>
</li>
</ul>
<h2 id="第十五章-光的衍射"><a href="#第十五章-光的衍射" class="headerlink" title="第十五章 光的衍射"></a>第十五章 光的衍射</h2><h3 id="S-15-1-光的衍射现象-惠更斯-菲涅尔原理"><a href="#S-15-1-光的衍射现象-惠更斯-菲涅尔原理" class="headerlink" title="$\S 15.1$ 光的衍射现象 惠更斯 - 菲涅尔原理"></a>$\S 15.1$ 光的衍射现象 惠更斯 - 菲涅尔原理</h3><ul>
<li><p>光的衍射现象</p>
<p>光在传播过程中绕过障碍物的边缘，偏离直线传播的现象叫光的衍射。</p>
<p>光的衍射和分为菲涅尔衍射和夫琅禾费衍射。</p>
<p><img src="E:\Blog\Ana_Su\source\_posts\Physics-II\15.1-01.png" alt="15.1-01"></p>
</li>
<li><p>惠更斯 - 菲涅尔原理</p>
<p><img src="E:\Blog\Ana_Su\source\_posts\Physics-II\15.1-02.png" alt="15.1-02"></p>
</li>
</ul>
<h3 id="S-15-2-夫琅禾费单缝衍射"><a href="#S-15-2-夫琅禾费单缝衍射" class="headerlink" title="$\S 15.2$ 夫琅禾费单缝衍射"></a>$\S 15.2$ 夫琅禾费单缝衍射</h3>]]></content>
      <tags>
        <tag>大学笔记</tag>
        <tag>物理</tag>
      </tags>
  </entry>
  <entry>
    <title>学习笔记 | 多项式与生成函数</title>
    <url>/2023/06/28/Poly/</url>
    <content><![CDATA[<p>浅挖个坑，期末考完填上</p>
<span id="more"></span>
]]></content>
      <tags>
        <tag>算法竞赛</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>大学笔记 | 概率论与数理统计</title>
    <url>/2023/08/29/Probability/</url>
    <content><![CDATA[<p>你能算出你入门的概率吗。</p>
<span id="more"></span>
<h2 id="第一章-随机事件及其概率论"><a href="#第一章-随机事件及其概率论" class="headerlink" title="第一章 随机事件及其概率论"></a>第一章 随机事件及其概率论</h2><h3 id="第一章总结（待完成）"><a href="#第一章总结（待完成）" class="headerlink" title="第一章总结（待完成）"></a>第一章总结（待完成）</h3><h3 id="S-1-1-随机试验与随机事件"><a href="#S-1-1-随机试验与随机事件" class="headerlink" title="$\S 1.1 $ 随机试验与随机事件"></a>$\S 1.1 $ 随机试验与随机事件</h3><ol>
<li><p>基本概念</p>
<ul>
<li>我们通常用字母 $E$ 表示一个随机试验。随机试验 $E$ 的基本结果称为样本点，用 $\omega$ 表示。称随机试验 $E$ 的所有基本结果的集合为样本空间，用 $\Omega =\{ \omega\} $ 表示。</li>
<li>样本空间 $\Omega$ 的部分子集称为随机试验 $E$ 的随机事件 $A$，若试验结果 $\omega \in A$，则称事件 $A$ 发生。</li>
<li>由一个样本点组成的事件称为基本事件。必然发生的事件称为必然事件，不可能发生事件称为不可能事件。</li>
<li>有限的样本点的空间称为有限样本空间，无限的样本点的空间称为无限样本空间。</li>
</ul>
</li>
<li><p>事件关系</p>
<ul>
<li>当 $A$ 发生时 $B$ 一定发生，则 $B$ 包含事件 $A$，记作 $A \subseteq B$。</li>
<li>相互包含的事件称为事件相等，记作 $A=B$。</li>
<li>$A$，$B$ 不能同时发生称为互不相容。</li>
<li>$A$，$B$ 事件中必有一个发生且不能同时发生称为事件的互逆，它们是 互逆 / 对立 的。其中一个事件是另一个事件的逆事件。记作 $\bar A = B$。显然 $\bar{\bar A} = A$。</li>
</ul>
</li>
<li><p>随机事件的运算</p>
<ul>
<li><p>事件的交，说明两个事件中至少发生一个事件，又称为$A$，$B$ 事件的并事件或和事件，记作 $A \cup B$。</p>
</li>
<li><p>事件的并，说明两个事件中都发生，又称为 $A$，$B$ 事件的交事件或积事件，记作 $A \cap B$。</p>
</li>
<li><p>事件的差，事件 $A$ 发生而 $B$ 不发生，记作 $A-B$。</p>
<blockquote>
<script type="math/tex; mode=display">
A - B = A\bar B = A - AB \\ 
(A - B) \cup B = A \cup B</script></blockquote>
</li>
<li><p>集合的运算满足结合律，交换律，分配律。这里着重强调一下对偶率。写作 $\bar{A \cup B} = \bar{A}\bar{B}$，$\bar{AB}=\bar A \cup \bar B$。</p>
</li>
</ul>
</li>
<li><p>几个常见结论</p>
<script type="math/tex; mode=display">
 A - B = A - AB = A \bar B \\
 A \cup B = A \cup (B-A) = A\cup(B - AB) \\
 A = A\Omega = A(B\cup \bar B) = AB\cup A\bar B</script></li>
</ol>
<h3 id="S-1-2-随机事件的概率"><a href="#S-1-2-随机事件的概率" class="headerlink" title="$\S 1.2$ 随机事件的概率"></a>$\S 1.2$ 随机事件的概率</h3><ol>
<li><p>频率 &amp; 概率</p>
<ul>
<li><p>频（概）率有非负性；对于必然事件，其频（概）率是 $1$；对于<strong>互不相容</strong>的事件，频（概）率具有可加性。</p>
</li>
<li><p>频率随试验次数的增加趋于稳定，其稳定值作为事件的概率。</p>
</li>
<li><p>对于任一事件，有 $P(\bar A) = 1 - P(A)$。</p>
</li>
<li><p><strong>若 $A \subseteq B$</strong>，则有 $P(B - A) = P(B) - P(A)$。</p>
</li>
<li><p>对于<strong>任意事件</strong>，有 $P(B - A) = P(B) - P(AB)$。</p>
</li>
<li><p>对于<strong>任意事件</strong>，有 $P(A \cup B) = P(A) + P(B) - P(AB)$。</p>
<blockquote>
<p>该公式推广到 $n$ 的情况即是容斥定理。</p>
</blockquote>
</li>
</ul>
</li>
<li><p>古典概型</p>
<ul>
<li>基本特点：样本空间只含有限个点且每个样本点的出现是等可能的。称为等可能概型，也称古典概型。</li>
</ul>
</li>
</ol>
<p>​    <img src="1.1.jpg" alt="1.1"></p>
<p>​    <img src="1.2.jpg" alt="1.2"></p>
<ol>
<li>几何概型</li>
</ol>
<p>$P(A) = \dfrac{A 的度量}{\omega 的度量}$</p>
<p><img src="1.3.jpg" alt="1.3"></p>
<p><img src="1.4.jpg" alt="1.4"></p>
<blockquote>
<p>注意这里 $x$ 的范围是 $[0, a]$，所以不用考虑另外一条边。</p>
</blockquote>
<p><img src="1.5.jpg" alt="1.5"></p>
<blockquote>
<p>分别设出第一段，第二段长度 $x$，$y$，然后找出 $x$，$y$，$a$ 之间的关系，画出图像来求几何概率，答案为 $\dfrac{1}{4}$。</p>
</blockquote>
<p><img src="1.6.jpg" alt="1.6"></p>
<blockquote>
<p>确定总事件数和符合的事件数是关键。</p>
</blockquote>
<h3 id="S-1-3-条件概率"><a href="#S-1-3-条件概率" class="headerlink" title="$\S 1.3$ 条件概率"></a>$\S 1.3$ 条件概率</h3><ul>
<li>事件 A 在事件 B 发生下发生的概率是 $P(B | A) = \dfrac{P(AB)}{P(A)}$。</li>
<li>对于两两不相容事件，有 $P((\bigcup_{i = 1}^{\infty}B_i) | A) = \sum_{i = 1} ^ {\infty}P(B_i | A)$。</li>
<li>常见公式有<br>  $P(\Phi | A) = 0$<br>  $P(\bar B | A) = 1 - P(B | A)$<br>  $P((B_1 \cup B_2) | A) = P(B_1 | A) + P(B_2 | A) - P((B_1B_2) | A)$</li>
<li>乘法公式 $P(AB) = P(A | B)P(B) = P(B | A)P(A)$<br>  推广 $P(ABC) = P(A)P(B | A)P(C | AB)$<pre><code>  $P(A_1A_2 \dots A_n) = P(A_1)P(A_2 | A_1)P(A_3 | A_1A_2) \dots P(A_n | A_1A_2 \dots A_n)$
</code></pre></li>
<li>全概率公式<br>  若事件 $A_1$，$A_2$，$\cdots$，$A_n$ 满足两两互不相容且 $A_1 \cup A_2 \cup \dots A_n = \Omega$，那么称 $A_1$，$A_2$，$\cdots$，$A_n$ 为样本空间的一个<strong>分解</strong>或<strong>完全事件组</strong>。则对于事件 $B$，有 $P(B) = \sum_{i = 1}^n P(B | A_i)P(A_i)$。</li>
<li>贝叶斯公式<br>  将乘法公式带入全概率公式可得 $P(A_i | B) = \dfrac{P(B | A_i)P(A_i)}{\sum_{j = 1}^n P(B | A_j)P(A_j)}$（分子表示 $BA_i$ 发生的概率，分母表示 $B$ 发生的概率）。<br>  贝叶斯公式称为后验概率公式，其中为 $P(A_i | B)$ 后验概率，$P(A_i)$ 为先验概率。</li>
</ul>
<h3 id="S-1-4-事件的独立性"><a href="#S-1-4-事件的独立性" class="headerlink" title="$\S 1.4$ 事件的独立性"></a>$\S 1.4$ 事件的独立性</h3><ul>
<li><p>若有事件 $A$，$B$ 满足 $P(AB) = P(A)P(B)$，则称 $A$，$B$ 相互独立。</p>
<p>  <strong>那么此时则有 $P(B | A) = P(B)$，$P(A | B) = P(A)$。</strong></p>
<p>  特殊的，必然事件和不可能事件和其他任何事件都是相互独立的。</p>
<p>  若 $A$ 与 $B$ 独立，那么 $A$ / $\bar A$ 与 $B$ / $\bar B$ 也相互独立。</p>
<p>  注意事件的独立与互不相容不存在必然的关系。但在 $P(A)$，$P(B)$ 都大于 $0$ 的情况下，相互独立和不相容不能同时成立，因为</p>
<blockquote>
<script type="math/tex; mode=display">
P(AB) = P(A)P(B) > 0 \ne 0</script></blockquote>
<p>   $A$，$B$ 独立时常用公式</p>
<script type="math/tex; mode=display">
  P(AB) = P(A)P(B) \\ 
  P(A \cup B) = P(A) + P(B) - P(A)P(B) \\
  P(A - B) = P(A) - P(A)P(B)</script></li>
<li><p>对于三个事件的独立性</p>
<p>  <img src="1.4-11.png" alt="1.4-11"></p>
<p>  <img src="1.4-2.png" alt="1.4-2"></p>
</li>
<li><p>推广到 $n$ 个事件</p>
<p>  <img src="1.4-3.png" alt="1.4-3"></p>
<p>  <img src="1.4-4.png" alt="1.4-4"></p>
</li>
</ul>
<h3 id="S-1-5-伯努利概型"><a href="#S-1-5-伯努利概型" class="headerlink" title="$\S 1.5$ 伯努利概型"></a>$\S 1.5$ 伯努利概型</h3><p><img src="1.5-1.png" alt="1.5-1"></p>
<p><img src="1.5-2.png" alt="1.5-2"></p>
<p><img src="1.5-3.png" alt="1.5-3"></p>
<h3 id="习题课（待完成）"><a href="#习题课（待完成）" class="headerlink" title="习题课（待完成）"></a>习题课（待完成）</h3><p>1.1 </p>
<script type="math/tex; mode=display">
(A \cup B)(A \cup \bar B)(\bar A \cup B)</script><script type="math/tex; mode=display">
解：原 = (A \cup (B\bar B))(\bar A \cup B) = A(\bar A \cup B) = (A\bar A) \cup (AB) = AB</script><h2 id="第二章-随机变量及其概率分布"><a href="#第二章-随机变量及其概率分布" class="headerlink" title="第二章 随机变量及其概率分布"></a>第二章 随机变量及其概率分布</h2><h3 id="第二章总结"><a href="#第二章总结" class="headerlink" title="第二章总结"></a>第二章总结</h3><p><img src="2.5-8.png" alt="2.5-8"></p>
<h3 id="S-2-1-随机变量及其分布函数"><a href="#S-2-1-随机变量及其分布函数" class="headerlink" title="$\S 2.1$ 随机变量及其分布函数"></a>$\S 2.1$ 随机变量及其分布函数</h3><ul>
<li><p>对于随机试验的样本空间 $\Omega$，若其中每一个样本点 $\omega \in \Omega$，都有一个实数 $x$ 与其相对于，则称 $X = X(\omega)$ 为随机变量。</p>
</li>
<li><p>设 $X$ 是一随机变量， $x$ 是任意实数，称 $F(x) = P\{X \le x\},(-\infty &lt; x &lt; \infty)$ 为随机变量 $X$ 的函数</p>
<blockquote>
<p>$F(x)$ 函数值分布在 $0 \sim 1$ 之间，是单调不减的，且具有右连续性，$F(x^+) = F(x)$。</p>
<p>$F(-\infty) = 0$，$F(\infty) = 1$</p>
<p>$P\{a &lt; X \le b\} = F(b) - F(a)$</p>
</blockquote>
</li>
</ul>
<h3 id="S-2-2-离散型随机变量及其概率分布"><a href="#S-2-2-离散型随机变量及其概率分布" class="headerlink" title="$\S 2.2$ 离散型随机变量及其概率分布"></a>$\S 2.2$ 离散型随机变量及其概率分布</h3><ul>
<li><p>若随机变量 $X$ 可取到的不同值是有限个或<strong>可列无限多个项</strong>，并且以确定的概率取这些值，则称 $X$ 为<strong>离散型随机变量</strong>。</p>
</li>
<li><p><img src="2.2-1.png" alt="2.2-1"></p>
<p><img src="2.2-2.png" alt="2.2-2"></p>
</li>
</ul>
<p><img src="2.2-3.png" alt="2.2-3"></p>
<h3 id="S-2-3-连续型随机变量及其概率密度"><a href="#S-2-3-连续型随机变量及其概率密度" class="headerlink" title="$\S 2.3$ 连续型随机变量及其概率密度"></a>$\S 2.3$ 连续型随机变量及其概率密度</h3><ul>
<li><p>与离散相对应的便是连续型。$f(x)$ 是概率密度函数，简称概率密度，满足 $F(x) = P\{X \le x\} = \int_{-\infty}^{x}f(t)dt$。</p>
<blockquote>
<p>值得注意的是，连续型的分布函数 $F(x)$ 在 $(-\infty, +\infty)$ 但概率密度 $f(x)$ 不一定连续，<strong>也不唯一</strong>。（注意，这里不唯一可以体现在，改变有限个 $f(x)$ 点的取值，并不影响 $F(x)$）</p>
</blockquote>
</li>
<li><p>概率密度 $f(x)$ 性质</p>
<ul>
<li>$f(x) \ge 0$ </li>
<li>$\int_{-\infty}^{+\infty}f(x)dx = 1$。</li>
<li>$P\{a &lt; X \le b\} = F(b) - F(a) =\int_{a}^{b}f(x)dx$。</li>
<li>在 $f(x)$ 的连续点处满足 $f(x) = F’(x)$。</li>
<li>$P\{X = c\} = 0$。<strong>这说明概率为 $0$ 不一定是不可能事件，概率为 $1$ 不一定是必然事件。</strong></li>
<li>$P\{a &lt; X &lt; b\} = P\{a \le X &lt; b\} = P\{a &lt; X \le b\} = P\{a \le X \le b\} $。</li>
</ul>
</li>
</ul>
<h3 id="S-2-4-几种常用的分布"><a href="#S-2-4-几种常用的分布" class="headerlink" title="$\S 2.4$ 几种常用的分布"></a>$\S 2.4$ 几种常用的分布</h3><p><strong>几种常用的离散型随机变量</strong></p>
<ul>
<li><p>（0 - 1）分布（两点分布）</p>
<p>若随机变量 $X$ 的分布律为 $P\{X = 1\} = p$，$P\{X = 0\} = 1 - p$ （$0 &lt; p &lt; 1$），则满足（0 - 1）分布。</p>
</li>
<li><p>二项分布</p>
<p>每次实验只有 $A$ 和 $\bar A$ 结果，独立实验 $n$ 次，用 $X$ 表示 $n$ 次实验中 $A$ 发生的次数，$P\{x = k\} = C_{n}^{k}p^k(1 - p)^{n - k}$，则称 $X$ 服从参数为 $np$ 的二项分布，记作 $X \sim B(n, p)$。</p>
<p><img src="2.4-1.png" alt="2.4-1"></p>
<p>若 $(n + 1) \cdot p$ 是整数 $m$，则 $P\{X = m\} = P\{X = m - 1\}$ 且在这两处可以取到最大值。</p>
<p>若 $(n + 1) \cdot p$ 不是整数，则令 $m = \left \lfloor  (n + 1) \cdot p\right \rfloor $，在 $P\{X = m\}$ 处可以取到最大值。</p>
</li>
<li><p>泊松（Poisson）分布</p>
<p>设 $X$ 的所有可能取值为 $0, 1, 2, \dots$，并且 $P\{X = k\} = \dfrac{\lambda^ke^{-\lambda}}{k!}(k = 0, 1, 2, \dots)$，其中 $\lambda &gt; 0$，则称 $x$ 服从泊松分布，记作 $X \sim P(\lambda)$ 或 $X \sim \pi(\lambda)$。</p>
<p><strong>泊松定理：</strong>若满足 $np_n = \lambda$，则对任一固定的非负整数 $k$，有 $\lim_{n \to \infty}C_{n}^{k}p_n^k(1 - p_n)^{n - k} = \dfrac{\lambda^ke^{-\lambda}}{k!}(k = 0, 1, 2, \dots)$。（说明了二项分布与泊松分布的关系）</p>
<blockquote>
<p>泊松定理说明，泊松分布是二项分布的极限分布，当 $n$ 很大而 $p$ 很小时，二项分布可近似看作参数 $\lambda = np$ 的泊松分布。</p>
</blockquote>
</li>
<li><p>几何分布</p>
<p>若某事件只有 $A$ 和 $\bar A$ 两种可能，且 $P(A) = p,P(\bar A) = 1 - p$，将事件独立重复发生直到出现结果 $A$ 为止，$X$ 表示所需试验的次数，则 $P\{X = k\} = (1 - p)^{k - 1}p$，称随机变量 $X$ 服从几何分布，记作 $X \sim G(p)$。</p>
</li>
<li><p>超几何分布</p>
<p>随机变量 $X$ 的分布律满足 $P\{X = m\} = \dfrac{C_M^mC_{N - M}^{n - m}}{C_N^n}$，则称 $X$ 服从超几何分布。（可以理解为拿走不放回时的概率）</p>
<blockquote>
<p><strong>超几何分布的极限分布是二项分布，二项分布的极限分布是 Poisson 分布。</strong></p>
</blockquote>
</li>
</ul>
<p><strong>几种常用的连续型随机变量</strong></p>
<ul>
<li><p>均匀分布</p>
<p>若连续型随机变量 $X$ 的概率密度函数为 $f(x) = \begin{cases} \dfrac{1}{b - a}  a &lt; x &lt; b\ 0         其他\end{cases}$，则称 $X$ 在区间 $(a, b)$ 上服从均匀分布。</p>
</li>
<li><p>指数分布</p>
<p>若连续型随机变量 $X$ 的概率密度函数为 $f(x) = \begin{cases} \lambda e^{-\lambda x}  x &gt; 0\ 0         x \le 0\end{cases}$，其中 $\lambda &gt; 0$ 是常数，则称 $X$ 服从参数为 $\lambda$ 的指数分布，记为 $X \sim E(\lambda)$。</p>
</li>
<li><p>正态分布</p>
<p>若连续型随机变量 $X$ 的概率密度函数为 $f(x) = \dfrac{1}{\sigma\sqrt{2\pi}}e^{-\dfrac{(x - \mu)^2}{2\sigma^2}}$，其中 $-\infty &lt; \mu &lt; +\infty, \sigma &gt; 0$，则称 $X$ 服从参数为 $\mu,\sigma$ 的正态分布，记作 $X \sim N(\mu, \sigma^2)$。</p>
<p><img src="2.4-2.png" alt="2.4-2"></p>
<p>正态分布以 $\mu$ 为中心，两边对称相等。其中 $\mu$ 是位置参数，$\mu$ 变大，图形右移，$\mu$ 变小，图形左移（$x = \mu$ 是对称中心）。$\sigma$ 是形状参数，$\sigma$ 变大，图形变平坦，$\sigma$ 变小，图形变陡峭。</p>
</li>
<li><p>标准正态分布</p>
<p>若 $X \sim N(\mu, \sigma^2)$ 且 $\mu = 0, \sigma = 1$，则称 $x$ 服从标准正态分布，记为 $X \sim N(0, 1)$。此时概率密度 $\varphi(x) = \dfrac{1}{\sqrt{2 \pi}}e^{-\dfrac{x^2}{2}}$，分布函数 $\Phi(x) = \int_{-\infty}^x \varphi(x)dx$，且有 $\Phi(x) + \Phi(-x) = 1$。</p>
<p>若 $X \sim N(\mu, \sigma^2)$，则 $Y = \dfrac{X - \mu}{\sigma} \sim N(0, 1)$（正态分布与标准正态分布的关系）。这个关系可以将正态分布的概率计算化为标准正态分布来计算。</p>
<p><img src="2.4-3.png" alt="2.4-3"></p>
<p><img src="2.4-4.png" alt="2.4-4"></p>
<p><img src="2.4-5.png" alt="2.4-5"></p>
<p><img src="2.4-6.png" alt="2.4-6"></p>
</li>
</ul>
<h3 id="S-2-5-随机变量的函数的分布"><a href="#S-2-5-随机变量的函数的分布" class="headerlink" title="$\S 2.5$ 随机变量的函数的分布"></a>$\S 2.5$ 随机变量的函数的分布</h3><ul>
<li><p>常规情况下直接按题意做即可，用一道例题简单说明。</p>
<p><img src="2.5-1.png" alt="2.5-1"></p>
<p><img src="2.5-2.png" alt="2.5-2"></p>
</li>
<li><p>特殊情况</p>
<p><img src="2.5-3.png" alt="2.5-3"></p>
<p><img src="2.5-4.png" alt="2.5-4"></p>
<p>用一道例题具体说明一下该方法的使用</p>
<p><img src="2.5-5.png" alt="2.5-5"></p>
<p>我们根据这种方法可以得出一个有关正态分布的结论：</p>
<p><img src="2.5-6.png" alt="2.5-6"></p>
</li>
<li><p>随机变量的函数分布的两种方法</p>
<p><img src="2.5-7.png" alt="2.5-7"></p>
</li>
</ul>
<h3 id="习题课（待完成）-1"><a href="#习题课（待完成）-1" class="headerlink" title="习题课（待完成）"></a>习题课（待完成）</h3><h2 id="第三章-多维随机变量及其概率分布"><a href="#第三章-多维随机变量及其概率分布" class="headerlink" title="第三章 多维随机变量及其概率分布"></a>第三章 多维随机变量及其概率分布</h2><h3 id="S-3-1-二维随机变量"><a href="#S-3-1-二维随机变量" class="headerlink" title="$\S 3.1$ 二维随机变量"></a>$\S 3.1$ 二维随机变量</h3><ul>
<li><p>二维随机变量</p>
<p><img src="3.1-1.png" alt="3.1-1"></p>
<p><img src="3.1-2.png" alt="3.1-2"></p>
<p><img src="3.1-3.png" alt="3.1-3"></p>
<p><img src="3.1-4.png" alt="3.1-4"></p>
</li>
<li><p>边缘函数</p>
<p>关于 $X$ 的边缘分布函数 $F_x(x) = \lim_{y \to +\infty} F(x, y)$。关于 $Y$ 的边缘分布函数 $F_y(Y) = \lim_{x \to +\infty} F(x, y)$。</p>
<p>若 $F(x, y) = F_X(x) \cdot F_Y(y)$，则说明 $X$ 与 $Y$ 相互独立。（类比 $P(AB) = P(A)P(B)$）</p>
<p><strong>若 $X, Y$ 不相互独立，联合函数 $F(x, y)$ 可以确定两个边缘函数，但是两个边缘函数不能确定一个联合函数。若 $X, Y$ 相互独立，联合分布函数能确定边缘分布函数，边缘函数也能确定联合函数。</strong></p>
</li>
</ul>
<h3 id="S-3-2-二维离散型随机变量及其概率分布"><a href="#S-3-2-二维离散型随机变量及其概率分布" class="headerlink" title="$\S 3.2$ 二维离散型随机变量及其概率分布"></a>$\S 3.2$ 二维离散型随机变量及其概率分布</h3><ul>
<li><p><img src="3.2-1.png" alt="3.2-1"></p>
</li>
<li><p>二维离散型随机变量边缘分布</p>
<p><img src="3.2-2.png" alt="3.2-2"></p>
</li>
<li><p>二维离散型随机变量的独立性</p>
<p>若 $p_{ij} = p_i \cdot p_j$，则满足两事件相互独立。</p>
<p><img src="3.2-3.png" alt="3.2-3"></p>
</li>
</ul>
<h3 id="S-3-3-二维连续型随机变量及其概率分布"><a href="#S-3-3-二维连续型随机变量及其概率分布" class="headerlink" title="$\S 3.3$ 二维连续型随机变量及其概率分布"></a>$\S 3.3$ 二维连续型随机变量及其概率分布</h3><p><img src="3.3-1.png" alt="3.3-1"></p>
<p><img src="3.3-2.png" alt="3.3-2"></p>
<p><img src="3.3-3.png" alt="3.3-3"></p>
<p><img src="3.3-4.png" alt="3.3-4"></p>
<ul>
<li>二维连续型随机变量边缘分布</li>
</ul>
<p><img src="3.3-5.png" alt="3.3-5"></p>
<ul>
<li><p>二维连续型随机变量的独立性</p>
<p>若 $f(x, y) = f_X(x)f_Y(y)$，则 $X$ 和 $Y$ 事件相互独立。</p>
</li>
<li><p>二维均匀分布和正态分布</p>
<p><img src="3.3-6.png" alt="3.3-6"></p>
<p><img src="3.3-7.png" alt="3.3-7"></p>
<p><img src="3.3-8.png" alt="3.3-8"></p>
</li>
</ul>
<h3 id="S-3-4-条件分布"><a href="#S-3-4-条件分布" class="headerlink" title="$\S 3.4$ 条件分布"></a>$\S 3.4$ 条件分布</h3><ul>
<li><p>离散型随机变量的条件分布</p>
<p>$P\{X = x_i | Y = y_j\} = \dfrac{P\{X = x_i, Y = y_j\}}{P\{Y = y_j\}}$</p>
</li>
<li><p>连续性随机变量的条件分布</p>
<p>$f(X \le x|Y = y) = f_{X|Y}(x|y) = $</p>
<p>$F_{X|Y}(x|y) = P(X \le x| Y = y)$ 表示条件 $Y = y$ 下 $X$ 的条件分布。 </p>
<p>$f_{X|Y}(x|y) = \dfrac{f(x, y)}{f_Y(y)}$ 表示条件 $Y = y$ 下 $X$ 的条件概率密度。 </p>
<p>条件分布和条件概率密度满足 $F_{X|Y}(x|y) = \int_{-\infty}^{x}\dfrac{f(u, y)}{f_Y(y)}du$</p>
<p><img src="3.4-1.png" alt="3.4-1"></p>
<p><img src="3.4-2.png" alt="3.4-2"></p>
<p><img src="3.4-5.png" alt="3.4-5"></p>
</li>
<li><p>例题</p>
<p><img src="3.4-3.png" alt="3.4-3"></p>
<p><img src="3.4-4.png" alt="3.4-4"></p>
</li>
</ul>
<h3 id="S-3-5-二维随机变量的函数的分布"><a href="#S-3-5-二维随机变量的函数的分布" class="headerlink" title="$\S 3.5$ 二维随机变量的函数的分布"></a>$\S 3.5$ 二维随机变量的函数的分布</h3><blockquote>
<p>本节要多做点题。会用公式法，图形定限法，卷积法。</p>
</blockquote>
<ul>
<li><p>离散型</p>
<p>$Z = g(x, y)$，通过列表格法，确定不同 $x, y$ 数值所对应 $z$ 的值，然后再求出每个 $P\{Z = z_k\}$ 概率。</p>
<p><img src="3.5-1.png" alt="3.5-1"></p>
</li>
<li><p>连续型</p>
<p><img src="3.5-2.png" alt="3.5-2"></p>
</li>
<li><p>三种特殊的连续型情况</p>
<p>$Z = X + Y$</p>
<p><img src="3.5-3.png" alt="3.5-3"></p>
<p><img src="3.5-4.png" alt="3.5-4"></p>
<p><img src="3.5-5.png" alt="3.5-5"></p>
<p><img src="3.5-6.png" alt="3.5-6"></p>
<p><img src="3.5-7.png" alt="3.5-7"></p>
<p><img src="3.5-8.png" alt="3.5-8"></p>
<p><img src="3.5-9.png" alt="3.5-9"></p>
</li>
<li><p>例题</p>
<p><img src="3.5-10.png" alt="3.5-10"></p>
</li>
</ul>
<h3 id="S-3-6-n-维随机变量"><a href="#S-3-6-n-维随机变量" class="headerlink" title="$\S 3.6$ $n$ 维随机变量"></a>$\S 3.6$ $n$ 维随机变量</h3><blockquote>
<p>这节真没我什么事qwq。</p>
</blockquote>
<p><img src="3.6-1.png" alt="3.6-1"></p>
<p><img src="3.6-2.png" alt="3.6-2"></p>
<p><img src="3.6-3.png" alt="3.6-3"></p>
<p><img src="3.6-4.png" alt="3.6-4"></p>
<p><img src="3.6-5.png" alt="3.6-5"></p>
<p><img src="3.6-6.png" alt="3.6-6"></p>
<p><img src="3.6-7.png" alt="3.6-7"></p>
<h2 id="第四章-随机变量数字特征"><a href="#第四章-随机变量数字特征" class="headerlink" title="第四章 随机变量数字特征"></a>第四章 随机变量数字特征</h2><h3 id="S-4-1-数学期望"><a href="#S-4-1-数学期望" class="headerlink" title="$\S 4.1$ 数学期望"></a>$\S 4.1$ 数学期望</h3><p><img src="4.1-1.png" alt="4.1-1"></p>
<p><img src="4.1-2.png" alt="4.1-2"></p>
<ul>
<li><p>常见随机分布的期望</p>
<p>$X$ 服从 $(0, 1)$ 分布，$E(X) = p$。</p>
<p>$X \sim B(n, p)$ ，$E(X) = np$。</p>
<p>$X \sim P(\lambda)$ ，$E(X) = \lambda$。</p>
<p>$X$ 服从参数为 $p$ 的几何分布，$E(X) = \dfrac{1}{p}$。</p>
<p>$X$ 服从 $(a, b)$ 上的均匀分布，$E(X) = \dfrac{a + b}{2}$。</p>
<p>$X \sim N(\mu, \sigma^2)$ ，$E(X) = \mu$。</p>
<p>$X$ 服从参数为 $\lambda$ 的指数分布，$E(X) = \dfrac{1}{\lambda}$。</p>
</li>
<li><p>随机变量的函数的随即期望</p>
<p><img src="4.1-3.png" alt="4.1-3"></p>
<p><img src="4.1-5.png" alt="4.1-5"></p>
</li>
<li><p>数学期望性质</p>
<ol>
<li><p>$E(aX + bY + c) = aE(X) + bE(Y) + c$（$a, b, c$ 均为常数）</p>
</li>
<li><p>设 $X$，$Y$ 相互独立，则有 $E(XY) = E(X)X(Y)$。（但是反过来不一定成立，看下面第二个例题） </p>
</li>
<li><p>设有随机变量 $X$ 和 $Y$，若 $E(X^2)$ 和 $E(Y^2)$ 都存在，则 $[E(XY)]^2 \le E(X^2)E(Y^2)$ 称为 Cauchy-Schwarz 不等式。</p>
<p><img src="4.1-8.png" alt="4.1-8"></p>
</li>
<li><p>额外补充</p>
<p><img src="4.1-11.png" alt="4.1-11"></p>
</li>
</ol>
</li>
<li><p>例题</p>
<p><img src="4.1-4.png" alt="4.1-4"></p>
<p><img src="4.1-6.png" alt="4.1-6"></p>
<p><img src="4.1-7.png" alt="4.1-7"></p>
<p><img src="4.1-9.png" alt="4.1-9"></p>
<p><img src="4.1-10.png" alt="4.1-10"></p>
</li>
</ul>
<h3 id="S-4-2-方差"><a href="#S-4-2-方差" class="headerlink" title="$\S 4.2$ 方差"></a>$\S 4.2$ 方差</h3><ul>
<li><p>方差</p>
<p>若随机变量的 $E(X - E(X))^2$ 存在，则称它为 $X$ 的方差，记作 $D(X)$，记 $\sigma(X) = \sqrt{D(X)}$ 为随机变量 $X$ 的均方差（标准差）。</p>
<p><img src="4.2-1.png" alt="4.2-1"></p>
<p><img src="4.2-2.png" alt="4.2-2"></p>
<blockquote>
<p><strong>这个公式非常重要，算 $E(x^2)$ 或 $E^2(x)$ 时，要么利用定义，要么用这个公式来转化。同理如果 $D(x)$ 不好算而 $E(x^2)$ 和 $E^2(x)$ 好算，也可以利用这个公式。</strong></p>
</blockquote>
<p><strong>重要附录表</strong></p>
<p><img src="4.2-3.png" alt="4.2-3"></p>
</li>
<li><p>方差的性质</p>
<p><img src="4.2-4.png" alt="4.2-4"></p>
<p><img src="4.2-5.png" alt="4.2-5"></p>
<blockquote>
<p>注意，这里方差为 $0$ 可以表示 $E(X)$ 为常数的概率为 $1$，但是期望为常数的概率是 $1$ 也不能说明期望一定是常数，在 <code>注2</code> 里举了反例。所以不能说 $X$ 取值相等，只能说<strong>几乎处处</strong>相等。</p>
</blockquote>
</li>
<li><p>随机变量的标准化</p>
<p>设 $X$ 的数学期望 $E(X) = \mu$，方差 $D(X) = \sigma^2 &gt; 0$，则称 $X^<em> = \dfrac{X - \mu}{\sigma}$ 为 $X$ 的标准化随机变量。标准化随机变量的数学期望是 $0$，方差是 $1$，即 $E(X^</em>) = 0, D(X^*) = 1$。</p>
</li>
<li><p>例题<strong>（这些证明都要求掌握）</strong></p>
<p><img src="4.2-6.png" alt="4.2-6"></p>
<p><img src="4.2-7.png" alt="4.2-7"></p>
<p><img src="4.2-8.png" alt="4.2-8"></p>
<p><img src="4.2-13.png" alt="4.2-13"></p>
<p><img src="4.2-9.png" alt="4.2-9"></p>
<p><img src="4.2-10.png" alt="4.2-10"></p>
<p><img src="4.2-11.png" alt="4.2-11"></p>
<p><img src="4.2-12.png" alt="4.2-12"></p>
</li>
</ul>
<h3 id="S-4-3-协方差与相关系数"><a href="#S-4-3-协方差与相关系数" class="headerlink" title="$\S 4.3$ 协方差与相关系数"></a>$\S 4.3$ 协方差与相关系数</h3><ul>
<li><p>协方差</p>
<p><img src="E:\Blog\Ana_Su\source\_posts\Probability\4.3-1.png" alt="4.3-1"></p>
<p><img src="E:\Blog\Ana_Su\source\_posts\Probability\4.3-2.png" alt="4.3-2"></p>
</li>
<li><p>相关系数</p>
<p><img src="E:\Blog\Ana_Su\source\_posts\Probability\4.3-3.png" alt="4.3-3"></p>
</li>
<li></li>
</ul>
<h3 id="S-4-4-矩"><a href="#S-4-4-矩" class="headerlink" title="$\S 4.4$ 矩"></a>$\S 4.4$ 矩</h3><ul>
<li>原心矩和中心矩</li>
</ul>
<ul>
<li>协方差矩阵</li>
</ul>
<ul>
<li>$n$ 维正态分布</li>
</ul>
<h2 id="第五章-大数定律及中心极限定理"><a href="#第五章-大数定律及中心极限定理" class="headerlink" title="第五章 大数定律及中心极限定理"></a>第五章 大数定律及中心极限定理</h2><h3 id="S-5-1-切比雪夫不等式"><a href="#S-5-1-切比雪夫不等式" class="headerlink" title="$\S 5.1$ 切比雪夫不等式"></a>$\S 5.1$ 切比雪夫不等式</h3><h3 id="S-5-2-大数定律"><a href="#S-5-2-大数定律" class="headerlink" title="$\S 5.2$ 大数定律"></a>$\S 5.2$ 大数定律</h3><h3 id="S-5-3-中心极限定理"><a href="#S-5-3-中心极限定理" class="headerlink" title="$\S 5.3$ 中心极限定理"></a>$\S 5.3$ 中心极限定理</h3><ul>
<li><p>依分布收敛</p>
<p><img src="E:\Blog\Ana_Su\source\_posts\Probability\5.3-1.png" alt="5.3-1"></p>
</li>
<li></li>
</ul>
]]></content>
      <tags>
        <tag>数学</tag>
        <tag>大学笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>大学笔记 | 信号与系统</title>
    <url>/2023/08/30/Signals-and-Systems/</url>
    <content><![CDATA[<p>——你说入门，它真入了吗？</p>
<p>——如入。</p>
<span id="more"></span>
<blockquote>
<p><strong>写在前面</strong></p>
<p>本笔记内容排布主要参考于郑君里的《信号与系统》。</p>
<p>同时内容一定程度上参考于郑君里的《信号与系统》和 <a href="https://www.bilibili.com/video/BV1g94y1Q76G/?spm_id_from=333.1007.top_right_bar_window_custom_collection.content.click&amp;vd_source=0f0f84fd4f7853dba4619576003d75fb">b 站浙大胡浩基老师的视频</a>。</p>
</blockquote>
<h2 id="第一章-信号与系统"><a href="#第一章-信号与系统" class="headerlink" title="第一章 信号与系统"></a>第一章 信号与系统</h2><h3 id="S-1-2-信号与系统"><a href="#S-1-2-信号与系统" class="headerlink" title="$\S 1.2$ 信号与系统"></a>$\S 1.2$ 信号与系统</h3><p>信号常表现为时间函数。</p>
<blockquote>
<p>我们通常用解析式法和图像法来表示信号。</p>
</blockquote>
<ul>
<li><p>信号分类</p>
<p>  <strong>确定信号 &amp; 随机信号</strong></p>
<blockquote>
<p>前者对于任一时间点可以给出确切表达式，而后者不行。</p>
</blockquote>
<p>  <strong>连续信号 &amp; 离散信号</strong></p>
<p>  $x(t),t \in \R$：连续信号。</p>
<p>  $x[n],n\in \Z$：离散信号。</p>
<blockquote>
<p>自变量是连续（离散）的信号称为连续（离散）信号。</p>
<p>而模拟信号要求自变量和因变量都是连续的，数字变量要求自变量和因变量都是离散的。</p>
</blockquote>
<p>  <strong>周期信号 &amp; 非周期信号</strong></p>
<p>  $x(t) = x(t + mT),t \in \R$</p>
<p>  $x[n] = x[n + mN],n\in \Z$</p>
<blockquote>
<p>任一个信号都可以拆成偶信号和奇信号，且拆法唯一。</p>
</blockquote>
<p>  <strong>能量信号 &amp; 功率信号</strong></p>
<p>  $E = \int_{t_0}^{t_1}|x(t)|^2dt$</p>
<p>  能量有限信号是 $0 &lt; E &lt; \infty$，$P = 0$。</p>
<p>  $P = \dfrac{1}{t_1 - t_0}\int_{t_0}^{t_1}|x(t)|^2dt$</p>
<p>  功率有限信号是 $0 &lt; P &lt; \infty$，$E = \infty$。</p>
</li>
<li><p>系统</p>
<p>  有输入有输出的称为系统。</p>
</li>
</ul>
<h3 id="S-1-3-信号的基本运算"><a href="#S-1-3-信号的基本运算" class="headerlink" title="$\S 1.3$ 信号的基本运算"></a>$\S 1.3$ 信号的基本运算</h3><p><strong>信号自变量变换规则</strong></p>
<ul>
<li>化为标准形式。</li>
<li>有负号翻转。</li>
<li>系数 &gt; 1，压缩。系数 &lt; 1，拉伸。</li>
<li>左加右减。</li>
</ul>
<h3 id="S-1-4-阶跃函数和冲激函数（待补充）"><a href="#S-1-4-阶跃函数和冲激函数（待补充）" class="headerlink" title="$\S 1.4$ 阶跃函数和冲激函数（待补充）"></a>$\S 1.4$ 阶跃函数和冲激函数（待补充）</h3><ul>
<li>单位阶跃函数 &amp; 单位跃阶序列</li>
</ul>
<script type="math/tex; mode=display">
\varepsilon(t) = U(t) =\left\{\begin{matrix}
 1 \ (t > 0)\\0 \ (t < 0)

\end{matrix}\right.\\
\\
 \varepsilon(0) 可以等于任何值 \\
 u[n] = \left\{\begin{matrix}
 1 \ (n \ge 0)\\0 \ (n < 0) 

\end{matrix}\right.</script><ul>
<li><p>单位冲激函数 &amp; 单位冲激序列</p>
<script type="math/tex; mode=display">
  \delta(t) = \dfrac{d\varepsilon(t)}{dt} = \left\{\begin{matrix}
   \infty \ (t = 0)\\0 \ (其他)

  \end{matrix}\right. \\
   \int_{-\infty}^{+\infty}\delta(t)dt = 1 \\
   \delta[n] =\left\{\begin{matrix}
   1 \ (n = 0)\\0 \ (n \ne 0) 

  \end{matrix}\right. \\
  重要公式\ x[n] = \sum_{k = -\infty}^{+\infty}x[k]\delta[n - k]</script></li>
<li><p>抽样函数</p>
<script type="math/tex; mode=display">
  Sa(t) = \dfrac{\sin t}{t} = \left\{\begin{matrix}
   1 \ (t = 0)\\ \dfrac{\sin t}{t} \ (其他)\end{matrix}\right.</script><p>  抽样函数的性质有 </p>
<script type="math/tex; mode=display">
  \int_0^{\infty} Sa(t)dt = \dfrac{\pi}{2}
  \\ \int_{-\infty}^{+\infty}Sa(t)dt = \pi</script><blockquote>
<p>简单证明以下 $\int_0^{\infty} Sa(t)dt = \dfrac{\pi}{2}$</p>
<p>证明如下：</p>
<script type="math/tex; mode=display">
\int_0^{\infty}Sa(t)dt</script></blockquote>
</li>
<li><p>单位斜变函数</p>
</li>
</ul>
<script type="math/tex; mode=display">
r(t) = t\varepsilon(t) =  \left\{\begin{matrix}
 t \ (t > 0)\\0 \ (t \le 0)

\end{matrix}\right.
\\ BTW,r(at - t_0) = (at - t_0)\varepsilon(at - t_0)</script><ul>
<li>符号函数</li>
</ul>
<script type="math/tex; mode=display">
sgn(t) =  \left\{\begin{matrix}
 1 \ (t > 0)\\-1 \ (t < 0) 

\end{matrix}\right.\\ = 2\varepsilon(t) - 1 = \varepsilon(t) - \varepsilon(-t)</script><ul>
<li>门函数</li>
</ul>
<script type="math/tex; mode=display">
g_{\tau}(t) = \left\{\begin{matrix}
 1 \ (-\dfrac{\tau}{2} < t < \dfrac{\tau}{2})\\0 \ (others) 

\end{matrix}\right.</script><ul>
<li><p>广义函数</p>
<p>粗浅的说，选择一类性能良好的函数 $\phi(t)$ 称为检验函数（相当于定义域），一个广义函数 $g(t)$ 是对检验函数空间中每个函数 $\phi(t)$ 赋予一个数值 $N$ 的映射，记作 $N[g(t), \phi(t)]$，可写作 $\int_{-\infty}^{+\infty} g(t)\phi(t)dt = N[g(t), \phi(t)]$。</p>
</li>
<li><p>冲激函数的性质</p>
<p>$\int_{-\infty}^{+\infty}\delta(t)dt = 1$ 证明如下</p>
<p><img src="E:\Blog\Ana_Su\source\_posts\Signals-and-Systems\1.4-1.png" alt="1.4-1"></p>
<p>$\int_{-\infty}^{+\infty}x(t)\delta(t)dt = x(0)$ 证明如下</p>
<p><img src="E:\Blog\Ana_Su\source\_posts\Signals-and-Systems\1.4-2.png" alt="1.4-2"></p>
<p>$x(t)\delta(t) = x(0)\delta(t)$</p>
<blockquote>
<p>特殊的，$x(t)\delta(t) = x(t_0)\delta(t - t_0)$</p>
</blockquote>
<p><strong>重要定义：我们称 $f_1(t) = f_2(t)$ 是指对任意函数 $y(t)$ 有：$\int_{-\infty}^{+\infty} y(t)f_1(t)dt = \int_{-\infty}^{+\infty} y(t)f_2(t)dt$（勒贝格定义）</strong> </p>
<p><img src="E:\Blog\Ana_Su\source\_posts\Signals-and-Systems\1.4-3.png" alt="1.4-3"></p>
<p>$\delta(at) = \dfrac{1}{|a|}\delta(t)$</p>
<blockquote>
<p>特殊的，$\delta(at + b) = \dfrac{1}{|a|}\delta(t + \dfrac{b}{a})$</p>
</blockquote>
<p><img src="E:\Blog\Ana_Su\source\_posts\Signals-and-Systems\1.4-4.png" alt="1.4-4"></p>
<p><img src="E:\Blog\Ana_Su\source\_posts\Signals-and-Systems\1.4-5.png" alt="1.4-5"></p>
<p>值得注意的是，判断两个函数相等的定理对于卷积也适用，如果 $h_1(t) = h_2(t)$ 那么 $x(t) <em> h_1(t) = x(t) </em> h_2(t)$。</p>
<p><img src="E:\Blog\Ana_Su\source\_posts\Signals-and-Systems\1.4-6.png" alt="1.4-6"></p>
<p>$\delta(f(t)) = \sum_{f(t_0 = 0)}\dfrac{\delta(t - t_0)}{|f’(t_0)|}$</p>
<p>$lim_{\omega \to \infty}\dfrac{\sin \omega t}{\pi t} = \delta(t)$（注意到前面抽样函数有讲到 $\int_{-\infty}^{+\infty} \dfrac{\sin (\omega t)}{\pi t} = 1$）</p>
</li>
</ul>
<h3 id="S-1-5-系统的描述"><a href="#S-1-5-系统的描述" class="headerlink" title="$\S 1.5$ 系统的描述"></a>$\S 1.5$ 系统的描述</h3><ul>
<li><p>描述连续系统的数学模型是微分方程，描述离散系统的数学模型是差分方程</p>
</li>
<li><p>连续系统和离散系统通常混合起来使用，称为混沌系统。</p>
</li>
<li><p>系统的框图表示</p>
<p><img src="1.5-1.jpg" alt="1.5-1"></p>
</li>
</ul>
<h3 id="S-1-6-系统的特性和分析方法"><a href="#S-1-6-系统的特性和分析方法" class="headerlink" title="$\S 1.6$ 系统的特性和分析方法"></a>$\S 1.6$ 系统的特性和分析方法</h3><p><strong>线性系统（Linear System）</strong>：假设 $\forall x(t)$ 经过系统得到 $y(t)$，则有：</p>
<ul>
<li>$ax(t) \to ay(t)(\forall a\in \R)$。</li>
<li>$\forall x_1(t) \to y_1(t),\forall x_2(t) \to y_2(t)$，那么则有 $x_1(t) + x_2(t) \to y_1(t) + y_2(t)$。</li>
</ul>
<blockquote>
<p>证明线性系统要证明这两点，但证明不是只用举出一个反例即可。</p>
<p>值得注意的是，齐次性和叠加性对线性缺一不可。</p>
<p>满足齐次性不满足叠加性粒子：</p>
<p>满足叠加性不满足齐次性例子：</p>
</blockquote>
<p><strong>离散线性系统</strong>：假设 $\forall x[n]$ 经过系统得到 $y[n]$，则有：</p>
<ul>
<li>$ax[n] \to ay<a href="\forall a\in \R">n</a>$。</li>
<li>$\forall x_1[n] \to y_1[n],\forall x_2[n] \to y_2[n]$，那么则有 $x_1[n] + x_2[n] \to y_1[n] + y_2[n]$。</li>
</ul>
<blockquote>
<p>线性系统判据（能判断大部分情况）：</p>
<ul>
<li>每一项都有 $x$。</li>
<li>每一项 $x$ 都是一次。</li>
</ul>
</blockquote>
<p><strong>时不变系统（Time-Invariant System）</strong>：假设 $\forall x(t)$ 经过系统得到 $y(t)$，则有：</p>
<ul>
<li>$x(t - t_0) \to y(t-t_0)(\forall t\in \R)$。</li>
</ul>
<p>离散时不变系统同理。</p>
<blockquote>
<p>时不变系统判据（能判断大部分情况）：</p>
<ul>
<li>$t$ 只在 $x$ 的括号里。</li>
<li>$t$ 只能是 $t$，不能是 $t^2$ 或 $3t$ 等其他形式。</li>
</ul>
</blockquote>
<p><strong>因果系统（Causal System）</strong>：假设 $\forall x(t)$ 经过系统得到 $y(t)$，则有：</p>
<ul>
<li>任何时刻的输出只与现在和过去有关。$y$ 的 $t_1$ 大于等于 $x$ 的 $t_0$。</li>
</ul>
<blockquote>
<p>因果系统判据（能判断大部分情况）：</p>
<ul>
<li>$x$ 括号里的数恒小于等于 $y$ 括号里的数。</li>
</ul>
</blockquote>
<p>离散因果系统同理。</p>
<p><strong>无记忆系统（Memoryless System）</strong>：假设 $\forall x(t)$ 经过系统得到 $y(t)$，则有：</p>
<ul>
<li>$y(t)$ 只与 $x(t)$ 有关。</li>
</ul>
<blockquote>
<p>无记忆系统判据（能判断大部分情况）：</p>
<ul>
<li>$x$ 括号里的数恒等于 $y$ 括号里的数。</li>
</ul>
</blockquote>
<p>离散无记忆系统同理。</p>
<p><strong>可逆系统（Invertible System）</strong>：假设 $\forall x(t)$ 经过系统得到 $y(t)$，则有：</p>
<ul>
<li>$x(t)$ 能唯一写成 $y(t)$ 的表达形式。</li>
</ul>
<p>离散可逆系统同理。</p>
<p><strong>稳定系统（Stable System）</strong>：假设 $\forall x(t)$ 经过系统得到 $y(t)$，则有：</p>
<ul>
<li>若 $x(t)$ 有界，则 $y(t)$ 有界。（有界指的是对 $\forall t$，$\exists M$，满足 $|x(t)| &lt; M$）。</li>
</ul>
<p>离散稳定系统同理。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>线性</th>
<th>时不变</th>
<th>无记忆</th>
<th>因果</th>
<th>稳定</th>
</tr>
</thead>
<tbody>
<tr>
<td>$y(t) = e^{x(t)}$</td>
<td>$\times$</td>
<td>$\surd$</td>
<td>$\surd$</td>
<td>$\surd$</td>
<td>$\surd$</td>
</tr>
<tr>
<td>$y[n] = x[n]x[n - 1]$</td>
<td>$\times$</td>
<td>$\surd$</td>
<td>$\times$</td>
<td>$\surd$</td>
<td>$\surd$</td>
</tr>
<tr>
<td>$y(t) = \dfrac{dx(t)}{dt}$</td>
<td>$\surd$</td>
<td>$\surd$</td>
<td>$\times$</td>
<td>$\surd$</td>
<td>$\times$</td>
</tr>
</tbody>
</table>
</div>
<h2 id="第二章-连续系统的时域分析"><a href="#第二章-连续系统的时域分析" class="headerlink" title="第二章 连续系统的时域分析"></a>第二章 连续系统的时域分析</h2><h3 id="S-2-1-LTI-连续系统的响应"><a href="#S-2-1-LTI-连续系统的响应" class="headerlink" title="$\S 2.1$ LTI 连续系统的响应"></a>$\S 2.1$ LTI 连续系统的响应</h3><h3 id="S-2-2-冲激响应和阶跃响应"><a href="#S-2-2-冲激响应和阶跃响应" class="headerlink" title="$\S 2.2$ 冲激响应和阶跃响应"></a>$\S 2.2$ 冲激响应和阶跃响应</h3><h3 id="S-2-3-卷积积分"><a href="#S-2-3-卷积积分" class="headerlink" title="$\S 2.3$ 卷积积分"></a>$\S 2.3$ 卷积积分</h3><h3 id="S-2-4-卷积积分的性质"><a href="#S-2-4-卷积积分的性质" class="headerlink" title="$\S 2.4$ 卷积积分的性质"></a>$\S 2.4$ 卷积积分的性质</h3><h2 id="第三章-离散系统的时域分析"><a href="#第三章-离散系统的时域分析" class="headerlink" title="第三章 离散系统的时域分析"></a>第三章 离散系统的时域分析</h2><h3 id="S-3-1-LTI-离散系统的响应"><a href="#S-3-1-LTI-离散系统的响应" class="headerlink" title="$\S 3.1$ LTI 离散系统的响应"></a>$\S 3.1$ LTI 离散系统的响应</h3><p>LTI 系统时域分析</p>
<p>线性时不变系统（Linear Time-Invariant System）：如果一个系统既线性又时不变，我们则称为线性时不变系统。</p>
<blockquote>
<p>为什么研究 LTI 系统？</p>
</blockquote>
<p>$h[n]$ 是单位脉冲响应。$h[n]$ 是 LTI 系统的唯一标识，两个 LTI 系统的 $h[n]$ 相同，则它们完全相同。</p>
<p>$y[n] = x[n] \ast h[n]$</p>
<blockquote>
<p>如何计算？</p>
<ul>
<li>列表法：<ul>
<li>$y[n]$ 最左（右）边 = $x[n]$ 最左（右）边 +  $h[n]$ 最左（右）边</li>
<li>列出表格，相加计算。</li>
</ul>
</li>
<li>卷积公式法<ul>
<li>$x[n] \ast h[n] = \sum_{k = -\infty}^{+\infty} x[k]h[n - k]$</li>
</ul>
</li>
</ul>
</blockquote>
<p>若 $x[n]$ 长度为 $n_1$，$h[n]$ 长度为 $n_2$，那么 $y[n] = x[n] \ast h[n]$长度为 $n_1 + n_2 - 2$。</p>
<p>若 $x[n]$ 长度为 $N$，$h[n]$ 长度为 $N$，那么 $y[n] = x[n] \ast h[n]$ 乘法运算 $N^2$ 次，加法运算 $(N - 1)^2$ 次。</p>
<p>卷积公式</p>
<p>$x[n] \ast h[n] = \sum_{k = -\infty}^{+\infty} x[k]h[n - k] = \sum_{k = -\infty}^{+\infty} x[k]h[-(k - n)]$</p>
<blockquote>
<p>证明：</p>
<script type="math/tex; mode=display">
先证明\ x[n] = \sum_{k = -\infty}^{+\infty} x[k]\delta[n - k] \\
然后又有\ \delta[n] \to [h](LTI),\ \delta[n - k] \to [h - k](时不变性) \\
x[k]\delta[n - k] \to x[k]h[n - k](线性系统齐次性) \\
\sum_{k = -\infty}^{+\infty}x[k]\delta[n - k] \to \sum_{k = -\infty}^{+\infty}x[k]h[n - k](线性系统叠加性)</script></blockquote>
<h3 id="S-3-2-单位序列和单位序列响应"><a href="#S-3-2-单位序列和单位序列响应" class="headerlink" title="$\S 3.2$ 单位序列和单位序列响应"></a>$\S 3.2$ 单位序列和单位序列响应</h3><h3 id="S-3-3-卷积和"><a href="#S-3-3-卷积和" class="headerlink" title="$\S 3.3$ 卷积和"></a>$\S 3.3$ 卷积和</h3><h3 id="S-3-4-卷反卷积积积分的性质"><a href="#S-3-4-卷反卷积积积分的性质" class="headerlink" title="$\S 3.4$ 卷反卷积积积分的性质"></a>$\S 3.4$ 卷反卷积积积分的性质</h3><h2 id="第四章-傅里叶变换和系统的频域"><a href="#第四章-傅里叶变换和系统的频域" class="headerlink" title="第四章 傅里叶变换和系统的频域"></a>第四章 傅里叶变换和系统的频域</h2>]]></content>
      <tags>
        <tag>大学笔记</tag>
        <tag>专业课</tag>
      </tags>
  </entry>
  <entry>
    <title>算法笔记 | 字符串（一）</title>
    <url>/2023/07/10/String-In-ACM-I/</url>
    <content><![CDATA[<p>Manacher，KMP。</p>
<span id="more"></span>
<h2 id="1-Manacher-算法"><a href="#1-Manacher-算法" class="headerlink" title="1. Manacher 算法"></a>1. Manacher 算法</h2><h3 id="1-1-算法介绍"><a href="#1-1-算法介绍" class="headerlink" title="1.1 算法介绍"></a>1.1 算法介绍</h3><p>该算法可以线性求出字符串的以各个位置为轴的回文子串最大长度</p>
<h3 id="1-2-过程"><a href="#1-2-过程" class="headerlink" title="1.2 过程"></a>1.2 过程</h3><p>本算法求的是以各位置为对称中心的最大对称半径是多少，由于会出现长度为奇数的对称区间（对称中心在两个位置中间），偶数长度的对称区间（对称中心在某一个位置处）。所以我们对原字串进行变换，比如 <code>abcba</code> 变为 <code>##a#b#c#b#a#</code> ，这样的话对称中心就是这个位置本身了。</p>
<p>我们引入一个数组 $len$ ，$len$ 数组表示这个点能够扩展出的回文长度。</p>
<p>我们从前向后遍历一遍，循环变量为 $i$，引入辅助变量 $maxr$ 和 $mid$ ，$maxr$ 表示触及到的最右边的字符位置，$mid$ 表示包含 $maxr$ 回文串的中心轴所在位置。对于每次遍历到的新的位置 $i$，不难发现如果 $i &lt; maxr$，那么 $len[i] = min\{len[mid] \}$</p>
<p>当 $i$ 在 $maxr$ 左边且在 $mid$ 右边时：</p>
<p>设 $i$ 关于 $mid$ 的对称点为 $j$，显然 $len[i]$ 一定不会小于 $len[j]$（对称）。</p>
<p>其中 $j$ 为 $(mid&lt;&lt;1)−i$。</p>
<p>那么我们就设置 $len[i] = min\{len[mid], maxr - i \}$ 然后继续尝试扩展，这样就可以较快地求出 $len[i]$，然后更新 $maxr$ 和 $mid$</p>
<p>当 $i$ 在 $maxr$ 右边时，我们无法得知关于 $len[i]$ 的信息，只好从 $1$ 开始遍历，然后更新 $maxr$ 和 $mid$。</p>
<p>本算法时间复杂度和空间复杂度均为线性的。</p>
<h3 id="1-3-实现"><a href="#1-3-实现" class="headerlink" title="1.3 实现"></a>1.3 实现</h3><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">()</span> </span>{</span><br><span class="line">  s2[<span class="number">0</span>] = s2[<span class="number">1</span>] = <span class="string">'#'</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) {</span><br><span class="line">    s2[i &lt;&lt; <span class="number">1</span>] = s1[i];</span><br><span class="line">    s2[i &lt;&lt; <span class="number">1</span> | <span class="number">1</span>] = <span class="string">'#'</span>;</span><br><span class="line">  }</span><br><span class="line">  n = <span class="number">2</span> * n + <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">manacher</span><span class="params">()</span> </span>{</span><br><span class="line">  <span class="type">int</span> maxr = <span class="number">0</span>, mid = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) {</span><br><span class="line">    <span class="keyword">if</span>(i &lt; maxr) len[i] = <span class="built_in">min</span>(len[(mid &lt;&lt; <span class="number">1</span>) - i], len[mid] + mid - i);</span><br><span class="line">    <span class="keyword">else</span> len[i] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i + len[i] &lt;= n &amp;&amp;  i - len[i] &gt; <span class="number">0</span> &amp;&amp; s2[i + len[i]] == s2[i - len[i]]) len[i]++;</span><br><span class="line">    <span class="keyword">if</span>(len[i] + i &gt; maxr) {</span><br><span class="line">      maxr = len[i] + i;</span><br><span class="line">      mid = i; </span><br><span class="line">    } </span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="2-KMP-算法"><a href="#2-KMP-算法" class="headerlink" title="2. KMP 算法"></a>2. KMP 算法</h2><h3 id="2-1-前缀函数"><a href="#2-1-前缀函数" class="headerlink" title="2.1 前缀函数"></a>2.1 前缀函数</h3><p>给定一个长度为 $n$ 的字符串 $s$，其前缀函数被定义为一个长度为 $n$ 的数组 $\pi$。 其中 $\pi[i]$ 的定义是：最长的相等的正后缀前后缀长度（自身除外），举个例子，字串 $s[0\dots i]$ 有一对相等的真前缀 $s[0\dots k - 1]$ 和真后缀 $s[i - (k - 1) \dots i]$ 它们相等且是这个字串中所能找到最长的前缀后缀，那么 $\pi[i] = k$。</p>
<h3 id="2-2-优化-amp-过程"><a href="#2-2-优化-amp-过程" class="headerlink" title="2.2 优化 &amp; 过程"></a>2.2 优化 &amp; 过程</h3><p>直接最朴素的计算前缀函数时间复杂度为 $O(n^3)$，故我们可以加入优化。</p>
<p>优化一：每次新加入一个数时，贡献最多加 $1$，即 $\pi[i + 1] \le \pi[i] + 1$ ，取等当且仅当 $s[\pi[i] + 1] == s[i + 1]$。</p>
<p>优化二：其实优化一的情况优化了新加入的数依然匹配成功的情况，那么优化二可以优化新加入的数失配的情况。我们假设记录一个数组 $k$，$k[i]$ 表示第 $i + 1$ 位失配之后应该跳到第 $k[i]$ 位上。那么我们每次可以不断向前跳，如果匹配成功就是优化一的情况，匹配不成功就继续回跳。</p>
<p>我们假设向前回跳一次到达的位置为 $j$。仔细观察，我们发现 $s[0\dots j] = s[i - j \dots i] = s<a href="j < \pi[i]">\pi[i] - j \dots \pi[i]</a>$，那么则有 $j = \pi[\pi[i]]$，故每次向前跳只需让 $j = k[j]$，等找到适配时就按优化一更新，一直适配不成功就按 $0$ 来更新 $k[i]$。这样的话相当于让该串自己匹配自己来求 $k[i]$，然后求该串在其他串中出现的位置就让该串与其他串匹配，等到 $j$ 变为该串的长度时，说明整个串出现了，可以记录下出现的位置了。</p>
<h3 id="2-3-实现"><a href="#2-3-实现" class="headerlink" title="2.3 实现"></a>2.3 实现</h3><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">kmp</span><span class="params">()</span> </span>{</span><br><span class="line">  <span class="type">int</span> len_a = <span class="built_in">strlen</span>(a + <span class="number">1</span>), len_b = <span class="built_in">strlen</span>(b + <span class="number">1</span>);</span><br><span class="line">  <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= len_b; i++) { <span class="comment">// i 要从 2 开始，不然的话计算前缀函数会把自身也算上，变为 k[i] = i</span></span><br><span class="line">    <span class="keyword">while</span>(j &amp;&amp; b[j + <span class="number">1</span>] != b[i]) j = k[j];</span><br><span class="line">    <span class="keyword">if</span>(b[j + <span class="number">1</span>] == b[i]) j++;</span><br><span class="line">    k[i] = j;</span><br><span class="line">  }</span><br><span class="line">  j = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= len_a; i++) {</span><br><span class="line">    <span class="keyword">while</span>(j &amp;&amp; b[j + <span class="number">1</span>] != a[i]) j = k[j];</span><br><span class="line">    <span class="keyword">if</span>(b[j + <span class="number">1</span>] == a[i]) j++;</span><br><span class="line">    <span class="keyword">if</span>(j == len_b) cout &lt;&lt; i - j + <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= len_b; i++) cout &lt;&lt; k[i] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
]]></content>
  </entry>
  <entry>
    <title>Study notes | CS61A</title>
    <url>/2023/08/28/UCB-CS61A/</url>
    <content><![CDATA[<p>Start!</p>
<span id="more"></span>
<h1 id="Chapter-1-Building-Abstractions-with-Functions"><a href="#Chapter-1-Building-Abstractions-with-Functions" class="headerlink" title="Chapter 1: Building Abstractions with Functions"></a>Chapter 1: Building Abstractions with Functions</h1><h3 id="1-2-Elements-of-Programing"><a href="#1-2-Elements-of-Programing" class="headerlink" title="1.2 Elements of Programing"></a>1.2 Elements of Programing</h3><h4 id="1-2-3-Importing-Library-Functions"><a href="#1-2-3-Importing-Library-Functions" class="headerlink" title="1.2.3 Importing Library Functions"></a>1.2.3 Importing Library Functions</h4><p>Python defines a very large number of functions, including the operator functions mentioned in the preceding section,so we can import them into our programing.</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> math <span class="keyword">import</span> sqrt</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sqrt(<span class="number">256</span>)</span><br><span class="line"><span class="number">16.0</span></span><br></pre></td></tr></tbody></table></figure>
<h4 id="1-2-4-Names-and-the-Environment"><a href="#1-2-4-Names-and-the-Environment" class="headerlink" title="1.2.4 Names and the Environment"></a>1.2.4 Names and the Environment</h4><p>Names can be bound via <code>=</code> or <code>import</code>.</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> math <span class="keyword">import</span> pi</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pi * <span class="number">71</span> / <span class="number">223</span></span><br><span class="line"><span class="number">1.0002380197528042</span></span><br></pre></td></tr></tbody></table></figure>
<p>Names can be bound to functions. For instance, the name <code>max</code> is bound to the max function we have been using. </p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">max</span></span><br><span class="line">&lt;built-<span class="keyword">in</span> function <span class="built_in">max</span>&gt;</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = <span class="built_in">max</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f</span><br><span class="line">&lt;built-<span class="keyword">in</span> function <span class="built_in">max</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">max</span> = <span class="number">5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">max</span></span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></tbody></table></figure>
<p>Interpreter must maintain some sort of memory which is called <strong>environment</strong> to keep track of the names, values and the bindings.</p>
<p><code>=</code> can combine multiple values and names.</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>area, circumference = pi * radius * radius, <span class="number">2</span> * pi * radius</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x, y = <span class="number">3</span>, <span class="number">4.5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>y, x = x, y</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x</span><br><span class="line"><span class="number">4.5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>y</span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></tbody></table></figure>
<h4 id="1-2-6-The-Non-Pure-Print-Function"><a href="#1-2-6-The-Non-Pure-Print-Function" class="headerlink" title="1.2.6  The Non-Pure Print Function"></a>1.2.6  The Non-Pure Print Function</h4><p><strong>Pure functions.</strong> Functions have some input (their arguments) and return some output (the result of applying them). </p>
<p><strong>Non-pure functions.</strong> In addition to returning a value, applying a non-pure function can generate <em>side effects</em>, which make some change to the state of the interpreter or computer.</p>
<p>Take <code>abs</code> and <code>print</code> as an example.</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">abs</span>(-<span class="number">2</span>)</span><br><span class="line"><span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="built_in">print</span>(<span class="number">1</span>), <span class="built_in">print</span>(<span class="number">2</span>))</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="literal">None</span> <span class="literal">None</span></span><br></pre></td></tr></tbody></table></figure>
<p><img src="pure_function-1.png" alt="pure_function-1"></p>
<p><img src="pure_function-2.png" alt="pure_function-2"></p>
<h3 id="1-3-Defining-New-Functions"><a href="#1-3-Defining-New-Functions" class="headerlink" title="1.3  Defining New Functions"></a>1.3  Defining New Functions</h3><p>The basic fundamental of a function:</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> &lt;name&gt;(&lt;formal parameters&gt;):</span><br><span class="line">    <span class="keyword">return</span> &lt;<span class="keyword">return</span> expression&gt;</span><br></pre></td></tr></tbody></table></figure>
<p>The second line <em>must</em> be indented — most programmers use four spaces to indent.(BTW, python uses indentation to define functions)</p>
<h4 id="1-3-1-Environments"><a href="#1-3-1-Environments" class="headerlink" title="1.3.1  Environments"></a>1.3.1  Environments</h4><p>An environment in which an expression is evaluated consists of a sequence of <em>frames</em>, depicted as boxes.</p>
<p>An <em>environment diagram</em> shows the bindings of the current environment, along with the values to which names are bound.</p>
<p>One function has the intrinsic name and a bound name.(One bound name may refer to different functions, while the intrinsic name can just refer to one only function.)</p>
<p>A description of the formal parameters of a function is called the <strong>function’s signature</strong>.</p>
<h4 id="1-3-5-Choosing-Names-amp-Abstract-funtions"><a href="#1-3-5-Choosing-Names-amp-Abstract-funtions" class="headerlink" title="1.3.5  Choosing Names &amp; Abstract funtions"></a>1.3.5  Choosing Names &amp; Abstract funtions</h4><p>Adapted from the <a href="http://www.python.org/dev/peps/pep-0008">style guide for Python code</a>.</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">Function names are lowercase, with words separated by underscores. Descriptive names are encouraged.</span><br><span class="line">Function names typically evoke operations applied to arguments by the interpreter (e.g., print, add, square) or the name of the quantity that results (e.g., max, abs, sum).</span><br><span class="line">Parameter names are lowercase, with words separated by underscores. Single-word names are preferred.</span><br><span class="line">Parameter names should evoke the role of the parameter in the function, not just the kind of argument that is allowed.</span><br><span class="line">Single letter parameter names are acceptable when their role is obvious, but avoid "l" (lowercase ell), "O" (capital oh), or "I" (capital i) to avoid confusion with numerals.</span><br></pre></td></tr></tbody></table></figure>
<p><strong>Aspects of a functional abstraction.</strong>To master the use of a functional abstraction, it is often useful to consider its three core attributes. The <em>domain</em> of a function is the set of arguments it can take. The <em>range</em> of a function is the set of values it can return. The <em>intent</em> of a function is the relationship it computes between inputs and output (as well as any side effects it might generate). </p>
<h3 id="1-4-Designing-Functions"><a href="#1-4-Designing-Functions" class="headerlink" title="1.4  Designing Functions"></a>1.4  Designing Functions</h3><p>A function definition will often include documentation describing the function, called a <em>docstring</em>, which must be indented along with the function body. Docstrings are conventionally triple quoted. Such as:</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">pressure</span>(<span class="params">v, t, n</span>):</span><br><span class="line">        <span class="string">"""Compute the pressure in pascals of an ideal gas.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Applies the ideal gas law: http://en.wikipedia.org/wiki/Ideal_gas_law</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        v -- volume of gas, in cubic meters</span></span><br><span class="line"><span class="string">        t -- absolute temperature in degrees kelvin</span></span><br><span class="line"><span class="string">        n -- particles of gas</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        k = <span class="number">1.38e-23</span>  <span class="comment"># Boltzmann's constant</span></span><br><span class="line">        <span class="keyword">return</span> n * k * t / v</span><br></pre></td></tr></tbody></table></figure>
<p>You can see the documenatation using:</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">help</span>(pressure)</span><br></pre></td></tr></tbody></table></figure>
<h3 id="1-5-Control"><a href="#1-5-Control" class="headerlink" title="1.5  Control"></a>1.5  Control</h3><p><strong>Practical Guidance.</strong> When indenting a suite, all lines must be indented the same amount and in the same way (use spaces, not tabs). Any variation in indentation will cause an error.</p>
<h4 id="1-5-6-Testing"><a href="#1-5-6-Testing" class="headerlink" title="1.5.6 Testing"></a>1.5.6 Testing</h4><p><strong>Assertions.</strong> Programmers use <code>assert</code> statements to verify expectations, such as the output of a function being tested. An <code>assert</code> statement has an expression in a boolean context, followed by a quoted line of text (single or double quotes are both fine, but be consistent) that will be displayed if the expression evaluates to a false value.</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">assert</span> fib(<span class="number">8</span>) == <span class="number">13</span>, <span class="string">'The 8th Fibonacci number should be 13'</span></span><br></pre></td></tr></tbody></table></figure>
<p>When the expression being asserted evaluates to a true value, executing an assert statement has no effect. When it is a false value, <code>assert</code> causes an error that halts execution.</p>
<p><strong>Doctests.</strong> Python provides a convenient method for placing simple tests directly in the docstring of a function. The first line of a docstring should contain a one-line description of the function, followed by a blank line. A detailed description of arguments and behavior may follow. In addition, the docstring may include a sample interactive session that calls the function:</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">sum_naturals</span>(<span class="params">n</span>):</span><br><span class="line">        <span class="string">"""Return the sum of the first n natural numbers.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; sum_naturals(10)</span></span><br><span class="line"><span class="string">        55</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; sum_naturals(100)</span></span><br><span class="line"><span class="string">        5050</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        total, k = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> k &lt;= n:</span><br><span class="line">            total, k = total + k, k + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> total</span><br></pre></td></tr></tbody></table></figure>
<p>You can verify the interaction via the <a href="http://docs.python.org/py3k/library/doctest.html">doctest module</a>.Such as:</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> doctest <span class="keyword">import</span> testmod</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>testmod()</span><br><span class="line">TestResults(failed=<span class="number">0</span>, attempted=<span class="number">2</span>)</span><br></pre></td></tr></tbody></table></figure>
<p>To verify the doctest interactions for only a single function, we use a <code>doctest</code> function called <code>run_docstring_examples</code>. This function is (unfortunately) a bit complicated to call. Its first argument is the function to test. The second should always be the result of the expression <code>globals()</code>, a built-in function that returns the global environment. The third argument is <code>True</code> to indicate that we would like “verbose” output: a catalog of all tests run.</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> doctest <span class="keyword">import</span> run_docstring_examples</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>run_docstring_examples(sum_naturals, <span class="built_in">globals</span>(), <span class="literal">True</span>)</span><br><span class="line">Finding tests <span class="keyword">in</span> NoName</span><br><span class="line">Trying:</span><br><span class="line">    sum_naturals(<span class="number">10</span>)</span><br><span class="line">Expecting:</span><br><span class="line">    <span class="number">55</span></span><br><span class="line">ok</span><br><span class="line">Trying:</span><br><span class="line">    sum_naturals(<span class="number">100</span>)</span><br><span class="line">Expecting:</span><br><span class="line">    <span class="number">5050</span></span><br><span class="line">ok</span><br></pre></td></tr></tbody></table></figure>
<p>When the return value of a function does not match the expected result, the <code>run_docstring_examples</code> function will report this problem as a test failure.</p>
<p>When writing Python in files, all doctests in a file can be run by starting Python with the doctest command line option:</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">python3 -m doctest &lt;python_source_file&gt;</span><br></pre></td></tr></tbody></table></figure>
<h3 id="1-6-Higher-Older-Functions"><a href="#1-6-Higher-Older-Functions" class="headerlink" title="1.6 Higher-Older Functions"></a>1.6 Higher-Older Functions</h3><p>Functions that manipulate functions are called higher-order functions. </p>
<h4 id="1-6-6-Currying"><a href="#1-6-6-Currying" class="headerlink" title="1.6.6 Currying"></a>1.6.6 Currying</h4><p>We can use higher-order functions to convert a function that takes multiple arguments into a chain of functions that each take a single argument.</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">curried_pow</span>(<span class="params">x</span>):</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">h</span>(<span class="params">y</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">pow</span>(x, y)</span><br><span class="line">        <span class="keyword">return</span> h</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>curried_pow(<span class="number">2</span>)(<span class="number">3</span>)</span><br><span class="line"><span class="number">8</span></span><br></pre></td></tr></tbody></table></figure>
<h4 id="1-6-7-Lambda-Expressions"><a href="#1-6-7-Lambda-Expressions" class="headerlink" title="1.6.7  Lambda Expressions"></a>1.6.7  Lambda Expressions</h4><p>In Python, we can create function values on the fly using <code>lambda</code> expressions, which evaluate to unnamed functions. A lambda expression evaluates to a function that has a single return expression as its body. Assignment and control statements are not allowed.</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">compose1</span>(<span class="params">f, g</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">lambda</span> x: f(g(x))</span><br></pre></td></tr></tbody></table></figure>
<p>We can understand the structure of a <code>lambda</code> expression by constructing a corresponding English sentence:</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">     <span class="keyword">lambda</span>            x            :          f(g(x))</span><br><span class="line"><span class="string">"A function that    takes x    and returns     f(g(x))"</span></span><br></pre></td></tr></tbody></table></figure>
<p>The following definition is correct, but many programmers have trouble understanding it quickly.</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>compose1 = <span class="keyword">lambda</span> f,g: <span class="keyword">lambda</span> x: f(g(x))</span><br></pre></td></tr></tbody></table></figure>
<h4 id="1-6-9-Function-Decorators"><a href="#1-6-9-Function-Decorators" class="headerlink" title="1.6.9  Function Decorators"></a>1.6.9  Function Decorators</h4><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">trace</span>(<span class="params">fn</span>):</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">wrapped</span>(<span class="params">x</span>):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">'-&gt; '</span>, fn, <span class="string">'('</span>, x, <span class="string">')'</span>)</span><br><span class="line">            <span class="keyword">return</span> fn(x)</span><br><span class="line">        <span class="keyword">return</span> wrapped</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>@trace</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">triple</span>(<span class="params">x</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span> * x</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>triple(<span class="number">12</span>)</span><br><span class="line">-&gt;  &lt;function triple at <span class="number">0x102a39848</span>&gt; ( <span class="number">12</span> )</span><br><span class="line"><span class="number">36</span></span><br></pre></td></tr></tbody></table></figure>
<p>The name <code>triple</code> is bound to the returned function value of calling <code>trace</code> on the newly defined <code>triple</code> function. In code, this decorator is equivalent to:</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">triple</span>(<span class="params">x</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span> * x</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>triple = trace(triple)</span><br></pre></td></tr></tbody></table></figure>
<h4 id="1-7-Recursive-Functions"><a href="#1-7-Recursive-Functions" class="headerlink" title="1.7  Recursive Functions"></a>1.7  Recursive Functions</h4><p>A function is called <em>recursive</em> if the body of the function calls the function itself, either directly or indirectly.</p>
<p>Pretty easy to understand, same as recursive functions in c++.</p>
<p>Instead of listing formal parameters for a function, you can write <code>*args</code>. To call another function using exactly those arguments, you call it again with <code>*args</code>. For example,</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">printed</span>(<span class="params">f</span>):</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">def</span> <span class="title function_">print_and_return</span>(<span class="params">*args</span>):</span><br><span class="line"><span class="meta">... </span>        result = f(*args)</span><br><span class="line"><span class="meta">... </span>        <span class="built_in">print</span>(<span class="string">'Result:'</span>, result)</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> result</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> print_and_return</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>printed_pow = printed(<span class="built_in">pow</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>printed_pow(<span class="number">2</span>, <span class="number">8</span>)</span><br><span class="line">Result: <span class="number">256</span></span><br><span class="line"><span class="number">256</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>printed_abs = printed(<span class="built_in">abs</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>printed_abs(-<span class="number">10</span>)</span><br><span class="line">Result: <span class="number">10</span></span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></tbody></table></figure>
<h1 id="Chapter-2-Building-Abstractions-with-Data"><a href="#Chapter-2-Building-Abstractions-with-Data" class="headerlink" title="Chapter 2: Building Abstractions with Data"></a>Chapter 2: Building Abstractions with Data</h1>]]></content>
      <tags>
        <tag>计算机科学</tag>
      </tags>
  </entry>
  <entry>
    <title>学习笔记 | UCB-CS61B</title>
    <url>/2023/07/09/UCB-CS61B/</url>
    <content><![CDATA[<span id="more"></span>
]]></content>
  </entry>
  <entry>
    <title>UCB-CS70</title>
    <url>/2023/08/28/UCB-CS70/</url>
    <content><![CDATA[<span id="more"></span>
]]></content>
  </entry>
  <entry>
    <title>算法笔记 | 杂项（一）</title>
    <url>/2023/07/07/somethingelse-in-ACM/</url>
    <content><![CDATA[<p>CDQ 分治</p>
<span id="more"></span>
<h2 id="1-CDQ-分治"><a href="#1-CDQ-分治" class="headerlink" title="1. CDQ 分治"></a>1. CDQ 分治</h2>]]></content>
      <tags>
        <tag>算法竞赛</tag>
      </tags>
  </entry>
</search>
